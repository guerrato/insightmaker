

if (typeof window === 'undefined') {
    const { JSDOM } = require("jsdom")

    window = (new JSDOM(``, {
        url: 'http://localhost',
        referrer: "http://localhost",
        contentType: "text/html",
        includeNodeLocations: false,
        storageQuota: 10000000,
        // pretendToBeVisual: false,
        userAgent: 'Chrome/87.0.4280.141',
    })).window

    document = window.document
    DOMParser = window.DOMParser
    navigator = window.navigator
    location = window.location
}

const is_owner = true

function isLocal() {
    return true;
}

"use strict";
/*

Copyright 2010-2020 Scott Fortmann-Roe. All rights reserved.

This file may distributed and/or modified under the
terms of the Insight Maker Public License (https://InsightMaker.com/impl).

*/

var translations = {};

function getText(src) {
	if (translations[src]) {
		src = translations[src];
	}

	for (var i = 1; i < arguments.length; i++) {
		src = src.replace("%s", arguments[i]);
	}

	return src;
}


"use strict";
/*

Copyright 2010-2018 Scott Fortmann-Roe. All rights reserved.

This file may distributed and/or modified under the
terms of the Insight Maker Public License (https://InsightMaker.com/impl).

*/

/*

Lightweight shim for mxGraph when not using visualization components. Supports loading saved models and carrying out basic edit operations.

*/

function SimpleNode(){
	
}

SimpleNode.prototype.getAttribute = function(x){
	var v = this["@attributes"][x];
	
	return v;
}

SimpleNode.prototype.setAttribute = function(x, value){
	this["@attributes"][x] = ""+value;
}


function loadXML(modelString){
	var oParser = new DOMParser();
	graph = oParser.parseFromString(modelString, "text/xml");
	graph = mxGraphToJson(graph);
	graph.children[0].value = {nodeName: 'root', id: 1};
	graph.children[0].id = 1;
	
	clearPrimitiveCache();
	var connectors = findType(["Flow", "Link", "Transition"]);
	var items = primitives();
	connectors.forEach(function(x){
		x.source = null;
		x.target = null;
		items.forEach(function(i){
			if(x.children[0].getAttribute("source") && x.children[0].getAttribute("source") == i.id){
				x.source = i;
			}
			if(x.children[0].getAttribute("target") && x.children[0].getAttribute("target") == i.id){
				x.target = i;
			}
		})
	});
	
	clearPrimitiveCache();
	
	function cleanCell(x){
		if(x.children){
			var cells = x.children.filter(function(c){
				return c.value.nodeName == "mxCell";
			});
		
			if(cells.length > 0){
				if(cells[0].getAttribute("parent")){
					setParent(x, findID(cells[0].getAttribute("parent")));
				}
			}
		
			x.children = x.children.filter(function(c){
				return c.value.nodeName != "mxCell";
			});
		
			for(var i = x.children.length - 1; i >= 0; i--){
				cleanCell(x.children[i]);
			};
		}
		
	}
	cleanCell(graph);
	
	clearPrimitiveCache();
	
	return graph;
}

function simpleCloneNode(node, parent){
	var obj = new SimpleNode();
	obj.value = node.cloneNode(true);
	obj.parent = parent;
	obj.parentNode= parent;
	

	var currId = [1].concat(primitives().map(function(x){return x.id}).filter(function(x){return x}));
	
	obj["@attributes"] = {
		id: Math.max.apply(null, currId) + 1
	};
	
	if (node.attributes.length > 0) {
		
		for (var j = 0; j < node.attributes.length; j++) {
			var attribute = node.attributes.item(j);
			obj["@attributes"][attribute.nodeName] = attribute.nodeValue;
		}
		
	}

	obj.id = obj["@attributes"].id;
	
	
	return obj;
}

function mxGraphToJson(xml, parent) {
	
	// Create the return object
	var obj = new SimpleNode();
	obj["@attributes"] = {};
	obj.value = xml;
	obj.parent = parent;
	obj.parentNode = parent;

	if (xml.nodeType == 1) { // element
		// do attributes
		if (xml.attributes.length > 0) {
			
			for (var j = 0; j < xml.attributes.length; j++) {
				var attribute = xml.attributes.item(j);
				obj["@attributes"][attribute.nodeName] = attribute.nodeValue;
			}
			obj.id = obj["@attributes"].id;
			
		}
	} else if (xml.nodeType == 3) { // text
		return null;
	}

	if (xml.hasChildNodes()) {
		obj.children = [];
		for(var i = 0; i < xml.childNodes.length; i++) {
			var item = xml.childNodes.item(i);
			var nodeName = item.nodeName;
			var x = mxGraphToJson(item, obj);
			if(x){
				obj.children.push(x);
			}
		}
	}
	return obj;
};

function setAttributeUndoable(primitive, name, value){
	if(primitive instanceof SimpleNode){
		primitive.setAttribute(name, value);
		clearPrimitiveCache();
	}else{
		var edit = new mxCellAttributeChange(primitive, name, value);
		graph.getModel().execute(edit);
	}
}

"use strict";
/*

Copyright 2010-2020 Scott Fortmann-Roe. All rights reserved.

This file may distributed and/or modified under the
terms of the Insight Maker Public License (https://InsightMaker.com/impl).

*/

var analysisCount = 0;


function getGraphXml(graph) {
	var enc = new mxCodec(mxUtils.createXmlDocument());
	var node = enc.encode(graph.getModel());
	return mxUtils.getPrettyXml(node);
}

var isSendingtoServer = false;
var waitingToSendToServer = false;
var waitingToSendTimeout = -1;
function sendGraphtoServer(graph) {
	if (isSendingtoServer) {
		waitingToSendToServer = true;
	} else {
		if (!unfoldingManager.unfolding) {
			clearTimeout(waitingToSendTimeout);
			waitingToSendToServer = false;
			isSendingtoServer = true;

			sendToParent({
				type: 'save',
				state: {
					data: getGraphXml(graph),
					title: graph_title,
					description: graph_description,
					tags: graph_tags,
					has_article: has_article,
					published: published,
					groups: JSON.stringify(node_groups)
				}
			})
		}
	}

}


function validPrimitiveName(name, primitive) {
	if (primitive.value.nodeName == "Stock" || primitive.value.nodeName == "Variable" || primitive.value.nodeName == "Converter" || primitive.value.nodeName == "Flow" || primitive.value.nodeName == "Display" || primitive.value.nodeName == "Agents" || primitive.value.nodeName == "Transition" || primitive.value.nodeName == "State") {
		if (name.length > 0 && (!(/[\[\]\(\)\{\}\<\>\'\"]/.test(name)))) {
			return true;
		} else {
			mxUtils.alert(getText("Primitive names cannot contain brackets, parenthesis, or quotes."));
			return false;
		}
	} else {
		return true;
	}
}

function isPrimitive(cell) {
	return !(cell.value.nodeName == 'Button' || cell.value.nodeName == 'Picture' || cell.value.nodeName == 'Text');
}

function cellsContainNodename(myCells, name) {
	for (var i = 0; i < myCells.length; i++) {
		if (myCells[i].value.nodeName == name) {
			return true;
		}
	}
}


function connectionType() {
	if (ribbonPanelItems().down('#connect').pressed) {
		return "Flow";
	} else {
		return "Link";
	}
	return "None";
}

function setAllConnectable() {
	graph.setConnectable(true);
	var items = primitives();
	for (var i = 0; i < items.length; i++) {
		items[i].setConnectable(true);
	}
}

var primitiveCache = {};
//cache clearing is set in InsightEditor.js


function primitives(type) {
	if (primitiveCache[" " + type]) {
		return primitiveCache[" " + type];
	}
	var myCells = childrenCells(((graph instanceof SimpleNode) ? graph.children[0] : graph.getModel().getRoot()).children[0]);
	if (type == null) {
		primitiveCache[" " + type] = myCells;
	} else {
		var targetCells = [];
		for (var i = 0; i < myCells.length; i++) {
			if (myCells[i].value.nodeName == type) {
				targetCells.push(myCells[i]);
			}
		}
		primitiveCache[" " + type] = targetCells;
	}
	return primitiveCache[" " + type];
}

function childrenCells(root) {
	var myCells = root ? root.children : null;
	if (myCells != null) {
		var additions = [];
		for (var i = 0; i < myCells.length; i++) {
			//alert(myCells[i].value.nodeName);
			if (myCells[i].value.nodeName == "Folder") {
				additions = additions.concat(childrenCells(myCells[i]));
			}
		}
		myCells = myCells.concat(additions);
		for (var i = myCells.length - 1; i >= 0; i--) {
			if (myCells[i] == null || myCells[i].value == null) {
				myCells.splice(i, 1);
			}
		}
		return myCells;
	}
	return null;
}


var neighborhoodCache = {};
//cache clearing is set in InsightEditor.js

function clearPrimitiveCache() {
	primitiveCache = {};
	neighborhoodCache = {};
}

function neighborhood(target) {
	var targetInAgent = inAgent(target);
	if (neighborhoodCache[target.id]) {
		return neighborhoodCache[target.id];
	}
	var hood = [];
	var myCells = primitives();
	if (myCells != null) {
		if (target != null) {
			var flows = [];
			var links = [];
			if (["Flow", "Link", "Transition"].indexOf(target.value.nodeName) > -1) {
				if (orig(target.source) !== null) {
					hood.push({
						item: orig(target.source),
						type: "direct"
					});
				}
				if (orig(target.target) !== null) {
					hood.push({
						item: orig(target.target),
						type: "direct"
					});
				}
			}
			if (target.value.nodeName == "Agents") {
				if (target.getAttribute("Agent")) {
					hood = hood.concat(getAgentItems(target));
				}
			}
			for (var i = 0; i < myCells.length; i++) {
				if (myCells[i].value.nodeName == "Flow") {
					flows.push(orig(myCells[i]));
				} else if (myCells[i].value.nodeName == "Link") {
					links.push(orig(myCells[i]));
				}
			}
			for (var i = 0; i < flows.length; i++) {
				if (flows[i].source == target) {
					hood.push({
						item: flows[i],
						type: "direct",
						linkHidden: true
					});
				}
				if (flows[i].target == target) {
					hood.push({
						item: flows[i],
						type: "direct",
						linkHidden: true
					});
				}
			}
			for (var i = 0; i < links.length; i++) {
				if (orig(links[i].source) == target && (isDefined(links[i].target) && links[i].target !== null)) {
					var linkHidden = !isTrue(links[i].getAttribute("BiDirectional"));

					hood.push({
						item: orig(links[i].target),
						type: "direct",
						linkHidden: linkHidden
					});
					hood = hood.concat(getAgentItems(links[i].target, linkHidden));
				}
				if (orig(links[i].target) == target && (isDefined(links[i].source) && links[i].source !== null) && !(inAgent(orig(links[i].source)) && !targetInAgent)) {
					hood.push({
						item: orig(links[i].source),
						type: "direct"
					});
					hood = hood.concat(getAgentItems(links[i].source));
				}
			}
		} else {
			for (var i = 0; i < myCells.length; i++) {
				if (isValued(myCells[i])) {
					hood.push({
						item: orig(myCells[i]),
						type: "direct"
					});
				}
			}
		}
	}
	hood = hood.filter(function (x) {
		return x;
	});
	var res = [];

	//Remove duplicated elements
	for (var i = 0; i < hood.length; i++) {
		if (hood[i].linkHidden && strictLinks) {
			continue;
		}
		var found = false;
		for (var j = 0; j < res.length; j++) {
			if (res[j].type == hood[i].type && res[j].item.id == hood[i].item.id) {
				found = true;
				if (res[j].linkHidden && !hood[i].linkHidden) {
					res[j].linkHidden = false;
				}
				break;
			}
		}
		if (!found) {
			if (isValued(hood[i].item) || (hood[i].item.value.nodeName == "Agents")) {
				res.push(hood[i]);
			}
		}
	}
	neighborhoodCache[target.id] = res;
	return res;

	function getAgentItems(agent, linkHidden) {
		var res = [];
		if (orig(agent).value.nodeName == "Agents" && orig(agent).getAttribute("Agent")) {
			var id = orig(agent).getAttribute("Agent");
			if (id) {
				var items = getChildren(findID(id));
				items.forEach(function (x) {
					if (isValued(x) && x.value.nodeName != "Ghost") {
						res.push({
							item: x,
							type: "agent",
							linkHidden: linkHidden,
							name: x.getAttribute("name")
						});
					}
				})
			}
		}

		return res.sort(function (a, b) {
			if (a.name == b.name) {
				return 0;
			} else if (a.name > b.name) {
				return 1
			} else {
				return -1;
			}
		});
	}
}

function doubleArray(arr) {
	var narr = [];
	for (var i = 0; i < arr.length; i++) {
		narr.push([arr[i], arr[i]])
	}
	return narr;
}

function isValued(cell) {
	if (isUndefined(cell) || cell == null || isUndefined(orig(cell))) {
		return false;
	}
	return (orig(cell).value.nodeName == "Converter" || orig(cell).value.nodeName == "Flow" || orig(cell).value.nodeName == "Stock" || orig(cell).value.nodeName == "Variable" || orig(cell).value.nodeName == "Transition" || orig(cell).value.nodeName == "State");
}

function setSaveEnabled(e) {
	if (is_editor && (!is_embed)) {
		var b = ribbonPanelItems().getComponent('savebut');
		if (e && unfoldingManager.unfolding == false) {
			b.setDisabled(false);
			b.setText('Save');
		} else {
			b.setDisabled(true);
			b.setText('Saved');
		}
	}
}

function hasDisplay() {
	var myCells = primitives();
	return cellsContainNodename(myCells, "Display");
}

function urlImage(cell) {
	return cell.getAttribute("Image") && cell.getAttribute("Image").substring(0, 4).toLowerCase() == "http";
}

function setPicture(cell) {

	var styleString = cell.getStyle();
	if (cell.getAttribute("Image") == "None" || cell.getAttribute("Image") == "" || cell.getAttribute("Image") == " " || cell.getAttribute("Image") == "null" || (cell.value.nodeName == "Folder" && !cell.isCollapsed())) {
		styleString = mxUtils.setStyle(styleString, "image", "None");
		if (cell.value.nodeName == "Display" || cell.value.nodeName == "Stock" || cell.value.nodeName == "Folder") {
			styleString = mxUtils.setStyle(styleString, "shape", "rectangle");
		} else if (cell.value.nodeName == "Button") {
			styleString = mxUtils.setStyle(styleString, "shape", "rectangle");
		} else {
			styleString = mxUtils.setStyle(styleString, "shape", "ellipse");
		}
	} else {
		if (urlImage(cell)) {
			styleString = mxUtils.setStyle(styleString, "image", cell.getAttribute("Image"));
		} else {
			styleString = mxUtils.setStyle(styleString, "image", builder_path + "/images/SD/" + cell.getAttribute("Image") + ".png");
		}
		if (isTrue(cell.getAttribute("FlipVertical"))) {
			styleString = mxUtils.setStyle(styleString, "imageFlipV", 1);
		} else {
			styleString = mxUtils.setStyle(styleString, "imageFlipV", 0);
		}
		if (isTrue(cell.getAttribute("FlipHorizontal"))) {
			styleString = mxUtils.setStyle(styleString, "imageFlipH", 1);
		} else {
			styleString = mxUtils.setStyle(styleString, "imageFlipH", 0);
		}
		styleString = mxUtils.setStyle(styleString, "shape", "image");
	}
	var edit = new mxStyleChange(graph.getModel(), cell, styleString);

	graph.getModel().execute(edit);

	propagateGhosts(cell);
}


function setLabelPosition(cell) {

	var labelPos = cell.getAttribute("LabelPosition");

	var styleString = cell.getStyle();

	if (cell.value.nodeName == "Folder" && (!cell.isCollapsed())) {
		styleString = mxUtils.setStyle(styleString, "labelPosition", null);
		styleString = mxUtils.setStyle(styleString, "align", null);

		styleString = mxUtils.setStyle(styleString, "verticalLabelPosition", null);
		styleString = mxUtils.setStyle(styleString, "verticalAlign", null);

	} else {

		if (labelPos == "Top") {
			styleString = mxUtils.setStyle(styleString, "labelPosition", "middle");
			styleString = mxUtils.setStyle(styleString, "align", "center");

			styleString = mxUtils.setStyle(styleString, "verticalLabelPosition", "top");
			styleString = mxUtils.setStyle(styleString, "verticalAlign", "bottom");
		} else if (labelPos == "Bottom") {
			styleString = mxUtils.setStyle(styleString, "labelPosition", "middle");
			styleString = mxUtils.setStyle(styleString, "align", "center");

			styleString = mxUtils.setStyle(styleString, "verticalLabelPosition", "bottom");
			styleString = mxUtils.setStyle(styleString, "verticalAlign", "top");
		} else if (labelPos == "Middle") {
			styleString = mxUtils.setStyle(styleString, "labelPosition", "middle");
			styleString = mxUtils.setStyle(styleString, "align", "center");

			styleString = mxUtils.setStyle(styleString, "verticalLabelPosition", "middle");
			styleString = mxUtils.setStyle(styleString, "verticalAlign", "middle");
		} else if (labelPos == "Left") {
			styleString = mxUtils.setStyle(styleString, "verticalLabelPosition", "middle");
			styleString = mxUtils.setStyle(styleString, "verticalAlign", "middle");

			styleString = mxUtils.setStyle(styleString, "labelPosition", "left");
			styleString = mxUtils.setStyle(styleString, "align", "right");
		} else if (labelPos == "Right") {
			styleString = mxUtils.setStyle(styleString, "verticalLabelPosition", "middle");
			styleString = mxUtils.setStyle(styleString, "verticalAlign", "middle");

			styleString = mxUtils.setStyle(styleString, "labelPosition", "right");
			styleString = mxUtils.setStyle(styleString, "align", "left");
		}
	}

	var edit = new mxStyleChange(graph.getModel(), cell, styleString);

	graph.getModel().execute(edit);

	propagateGhosts(cell);
}


function removeAgent(cell) {
	var items = primitives("Agents");
	for (var i = 0; i < items.length; i++) {
		if (items[i].getAttribute("Agent") == cell.id) {
			items[i].setAttribute("Agent", "");
		}
	}
}


function deletePrimitive(cell) {
	var myCells = primitives();

	var setting = getSetting();
	if (setting.getAttribute("SensitivityPrimitives")) {
		var items = setting.getAttribute("SensitivityPrimitives").split(",");
		var j = items.indexOf(cell.id);
		if (j > -1) {
			items.splice(j, 1);
			setting.setAttribute("SensitivityPrimitives", items.join(","));
		}
	}


	if (cell.value.nodeName == "Folder" && cell.getAttribute("Type") == "Agent") {
		removeAgent(cell);
	}

	for (var i = 0; i < myCells.length; i++) {
		if (myCells[i].value.nodeName == "Display") {
			if (myCells[i].getAttribute("Primitives")) {
				var items = myCells[i].getAttribute("Primitives").split(",");
				var j = items.indexOf(cell.id);
				if (j > -1) {
					items.splice(j, 1);
					myCells[i].setAttribute("Primitives", items.join(","));
				}
			}
		} else if (myCells[i].value.nodeName == "Converter") {
			if (myCells[i].getAttribute("Source") == cell.id) {
				myCells[i].setAttribute("Source", "Time");
			} else if (cell.value.nodeName == "Link") {
				testConverterSource(myCells[i]);
			}
		} else if (myCells[i].value.nodeName == "Ghost") {
			if (myCells[i].value.getAttribute("Source") == cell.id) {
				var k = myCells[i];

				deletePrimitive(k);
				graph.removeCells([k], false);

			}
		}
	}
}


function linkBroken(edge) {
	var myCells = primitives();
	for (var i = 0; i < myCells.length; i++) {
		if (myCells[i].value.nodeName == "Converter") {
			testConverterSource(myCells[i]);
		}
		/*else if(myCells[i].value.nodeName == "Agents") {
						var source = myCells[i].getAttribute("Agent");
			if(source){
				if(! connected(myCells[i], findID(source))){
					myCells[i].setAttribute("Agent", "");
				}
			}
				}*/
	}
	if ((edge.getTerminal(false) !== null) && edge.getTerminal(false).value.nodeName == "Converter") {
		if (typeof (edge.getTerminal(true)) != "undefined") {
			if (isValued(edge.getTerminal(true))) {
				edge.getTerminal(false).setAttribute("Source", orig(edge.getTerminal(true)).id);
			}
		}
	}

}


function testConverterSource(target) {
	var neigh = neighborhood(target);
	var found = false;
	for (var j = 0; j < neigh.length; j++) {
		if (!neigh[j].linkHidden) {
			if (target.getAttribute("Source") == neigh[j].item.id) {
				found = true;
			}
		}
	}
	if (!found) {
		target.setAttribute("Source", "Time");
	}
}


function downloadModel() {
	var data = getGraphXml(graph);
	surpressCloseWarning = true;
	document.getElementById('downloader').title.value = encodeURIComponent(graph_title);
	document.getElementById('downloader').code.value = encodeURIComponent(data);
	document.getElementById('downloader').submit();
}


function getSetting() {
	var myCells = primitives();

	for (var i = 0; i < myCells.length; i++) {
		if (myCells[i].value.nodeName == "Setting") {
			return myCells[i];
		}
	}
	alert("Settings primitive could not be found.")
	return null;
}


function handelCursors() {
	graph.container.style.cursor = 'auto';
}


var propertiesWin;

function updateProperties() {
	var model_title;
	if (graph_title == "") {
		model_title = "Untitled Insight";
	} else {
		model_title = graph_title;
	}

	if (!propertiesWin) {
		propertiesWin = new Ext.Window({
			applyTo: 'property-win',
			layout: {
				type: 'vbox',
				align: "stretch"
			},
			modal: true,
			width: 550,
			title: "Save Insight",
			autoHeight: true,
			minHeight: 300,
			minWidth: 450,
			closable: true,
			resizable: true,
			autoScroll: true,
			closeAction: 'hide',
			defaults: {
				width: 230,
				labelWidth: 150
			},
			items: [new Ext.form.TextField({
				fieldLabel: 'Insight Title',
				name: 'sinsightTitle',
				id: 'sinsightTitle',
				allowBlank: false,
				selectOnFocus: true,
				value: model_title,
				margin: 9
			}), new Ext.form.TextField({
				fieldLabel: 'Tags',
				name: 'sinsightTags',
				id: 'sinsightTags',
				allowBlank: true,
				emptyText: "Environment, Health Care, Finance",
				value: graph_tags,
				margin: 9
			}), {
				xtype: 'fieldcontainer',
				fieldLabel: 'Description',
				allowBlank: true,
				items: [
					Ext.create('Ext.toolbar.Toolbar', {
						style: { padding: '6px 0px' },
						enableOverflow: true,
						items: [
							{
								glyph: 0xf032,
								tooltip: 'Bold',
								handler: () => {
									document.execCommand('bold');
								}
							},
							{
								glyph: 0xf033,
								tooltip: 'Italic',
								handler: () => {
									document.execCommand('italic');
								}
							},
							{
								glyph: 0xf0cd,
								tooltip: 'Underline',
								handler: () => {
									document.execCommand('underline');
								}
							},
							'-',
							{
								glyph: 0xf036,
								tooltip: 'Left align',
								handler: () => {
									document.execCommand('justifyLeft');
								}
							},
							{
								glyph: 0xf037,
								tooltip: 'Center',
								handler: () => {
									document.execCommand('justifyCenter');
								}
							},
							{
								glyph: 0xf038,
								tooltip: 'Right align',
								handler: () => {
									document.execCommand('justifyRight');
								}
							},
							'-',
							{
								glyph: 0xf0c1,
								tooltip: 'Insert link',
								handler: () => {
									var url = prompt('Enter a URL')
									if (url) {
										document.execCommand('createLink', true, url);
										$('#sinsightDescription a').attr('target', '_blank');
									}
								}
							},
							'-',
							{
								glyph: 0xf0cb,
								tooltip: 'Numbered list',
								handler: () => {
									document.execCommand('insertOrderedList');
								}
							},
							{
								glyph: 0xf0ca,
								tooltip: 'Bullet list',
								handler: () => {
									document.execCommand('insertUnorderedList');
								}
							}
						]
					}),
					{
						html: '<div id="sinsightDescription" style="height: 130px; border: solid 1px #cecece; padding: 4px 6px 3px 6px; overflow: auto;" contenteditable>' + clean(graph_description) + '</div>'
					}
				],
				margin: 9,
				minHeight: 100,
				flex: 1
			},
			{
				xtype: 'fieldcontainer',
				fieldLabel: 'Insight Access',
				layout: 'hbox',
				defaults: {
					flex: 1,
					hideLabel: true
				},
				margin: 9,
				items: [
					{
						xtype: "segmentedbutton",
						items: [
							{
								glyph: 0xf0ac,
								text: 'Public Insight',
								pressed: published,
								id: 'insightPublic',
								tooltip: "This Insight is public. Anyone can view it, but only you can edit it."
							},
							{
								glyph: 0xf084,
								text: 'Private Insight',
								pressed: !published,
								tooltip: "This Insight is private. Only people you have given access to can view it."
							}
						]
					}
				]
			}, Ext.create('Ext.form.field.Tag', {
				hidden: user_groups.length == 0,
				fieldLabel: 'Share with Groups',
				name: 'sinsightGroups',
				id: 'sinsightGroups',
				value: node_groups,
				allowBlank: true,
				filterPickList: true,
				store: group_titles,
				margin: 9
			})
			],

			buttons: [{
				text: 'Cancel',
				scale: "large",
				glyph: 0xf05c,
				handler: function () {
					propertiesWin.hide();
				}
			}, {
				glyph: 0xf00c,
				scale: "large",
				text: 'Save',
				handler: function () {
					if (Ext.getCmp("sinsightTitle").validate()) {
						propertiesWin.hide();
						graph_title = Ext.String.trim(Ext.getCmp('sinsightTitle').getValue());
						graph_description = clean(Ext.String.trim($('#sinsightDescription').html()));
						graph_description = graph_description.replace(/^(\u200b|&nbsp;)/g, "");
						graph_description = graph_description.replace(/(\u200b|&nbsp;)$/g, "");
						if (graph_description == "<br>" || graph_description == "<br/>" || graph_description == "\u200b" || graph_description == "&nbsp;") {
							graph_description = "";
						}
						graph_tags = Ext.getCmp('sinsightTags').getValue();
						node_groups = Ext.getCmp('sinsightGroups').getValue();
						published = Ext.getCmp('insightPublic').pressed;
						setSaveEnabled(true);
						sendGraphtoServer(graph);
						selectionChanged(false);
					} else {
						showNotification(getText("You must specify a name for the Insight."), "error", true);
					}
				}
			}]


		});
	} else {
		if (graph_title != "") {
			Ext.getCmp('sinsightTitle').setValue(graph_title);
			Ext.getCmp('sinsightTags').setValue(graph_tags);
			$('#sinsightDescription').html(clean(graph_description));
		}
	}
	propertiesWin.show();
	Ext.getCmp("sinsightTitle").focus(true, 300);
}


function isTrue(item) {
	return (item != "false" && item != "No" && item != 0) && (item == 1 || item == -1 || item == "True" || item == "true" || item == true || item == "Yes");
}


function customUnits() {
	if (typeof (getSetting().getAttribute("Units")) != "undefined") {
		var rows = getSetting().getAttribute("Units").split("\n");
		for (var i = 0; i < rows.length; i++) {
			rows[i] = rows[i].split("<>");
		}
		return rows;
	} else {
		return [];
	}
}


function orig(cell) {
	if (!cell) {
		return null;
	} else if (cell.value.nodeName === "Ghost") {
		if (!cell.origCache) {
			cell.origCache = findID(cell.value.getAttribute("Source"));
		}
		return cell.origCache;
	} else {
		return cell;
	}
}


function currentStyleIs(val) {
	var tmp = graph.getCellStyle(graph.getSelectionCell())[mxConstants.STYLE_FONTSTYLE];
	for (var i = 3; i >= 1; i--) {
		tmp = tmp - val * (Math.pow(2, i));
		if (tmp < 0) {
			tmp = tmp + val * Math.pow(2, i);
		}
	}
	return (tmp >= val);
}


function setStyles() {
	if ((!is_embed) && is_editor) {
		var selected = !graph.isSelectionEmpty();

		var r = ribbonPanelItems();

		if (selected) {
			r.down('#bold').setChecked(currentStyleIs(mxConstants.FONT_BOLD));
			r.down('#italic').setChecked(currentStyleIs(mxConstants.FONT_ITALIC));
			r.down('#underline').setChecked(currentStyleIs(mxConstants.FONT_UNDERLINE));
			var style = graph.getCellStyle(graph.getSelectionCell());
			r.down("#sizeCombo").setValue(style[mxConstants.STYLE_FONTSIZE]);
			r.down("#fontCombo").setValue(style[mxConstants.STYLE_FONTFAMILY]);
		} else {
			r.down('#bold').setChecked(false);
			r.down('#italic').setChecked(false);
			r.down('#underline').setChecked(false);
			r.down("#fontCombo").setValue("");
			r.down("#sizeCombo").setValue("");
		}
	}
}


function stringArray(items, comma, and) {
	if (items.length == 0) {
		return "";
	} else if (items.length == 1) {
		return items[0];
	} else {
		var i = items.slice();
		var last = i.pop();
		var first = i.join(comma);
		return first + and + last;
	}
}


function quickLabel(label, title, objects) {
	var setting = getSetting();

	return processLabel(label, title, objects, setting.getAttribute("TimeUnits"), setting.getAttribute("TimeStep"), setting.getAttribute("SolutionAlgorithm"));
}


function processLabel(label, title, objects, units, timeStep, algorithm) {
	var ph = "<PERCENTSIGNPLACEHOLDER>";
	label = replaceAll(label, "%%", ph);

	label = replaceAll(label, "%u", units);
	label = replaceAll(label, "%t", title);
	label = replaceAll(label, "%o", objects);
	label = replaceAll(label, "%ts", timeStep);
	label = replaceAll(label, "%a", algorithm);

	label = replaceAll(label, ph, "%");

	return clean(label);
}


function replaceAll(txt, replace, with_this) {

	if (isUndefined(txt)) {
		return "";
	}
	return txt.replace(new RegExp(replace, 'g'), with_this);
}


function loadBackgroundColor() {
	mxPanel.el.dom.style["background-color"] = getSetting().getAttribute("BackgroundColor");

	mxPanel.el.dom.style.backgroundColor = getSetting().getAttribute("BackgroundColor");
}


function isUndefined(item) {
	return typeof item == "undefined";
}


function isDefined(item) {
	return !isUndefined(item);
}


function isTouch() {
	return mxClient.IS_TOUCH;
}


function propagateGhosts(cell) {
	var ghosts = primitives("Ghost");
	for (var i = 0; i < ghosts.length; i++) {
		if (ghosts[i].getAttribute("Source") == cell.id) {
			var style = cell.getStyle();
			style = mxUtils.setStyle(style, "opacity", 30);
			ghosts[i].setStyle(style);
			var edit = setAttributeUndoable(ghosts[i], "name", cell.getAttribute("name"));

		}
	}
}


function propagateName(cell, oldName) {
	if (isValued(cell)) {

		var newValue = getName(cell);
		var patt = new RegExp("\\[" + oldName + "\\]", "gi");

		var connected = graph.getConnections(cell);
		for (var i = 0; i < connected.length; i++) {
			if ((!connected[i].target) || (!connected[i].source)) {
				continue;
			}
			var neighbor;
			if (connected[i].value.nodeName == "Flow" || connected[i].value.nodeName == "Transition") {
				neighbor = connected[i];
			} else if (connected[i].target.id == cell.id) {
				neighbor = connected[i].source;
			} else {
				neighbor = connected[i].target;
			}

			if (isValued(neighbor) || (neighbor && neighbor.value.nodeName == "Action")) {
				setValue(neighbor, getValue(neighbor).replace(patt, "[" + newValue + "]"))
			}
		}
	}
}


function map(val, fn) {
	if (val instanceof Array) {
		return val.map(fn);
	} else {
		return fn(val);
	}
}


function unitsUsedInModel() {
	var items = primitives();
	var us = [];
	for (var i = 0; i < items.length; i++) {
		var u = items[i].getAttribute("Units");
		if (items[i].value.nodeName != "Setting" && isDefined(u) && u !== null && u != "Unitless") {
			us.push(u);
		}
	}
	return Ext.Array.unique(us);
}


function changeNodeName(node, newName) {
	var doc = mxUtils.createXmlDocument();
	var newNode = doc.createElement(newName);
	var attrs = node.attributes;
	for (var i = 0; i < attrs.length; i++) {
		newNode.setAttribute(attrs[i].name, attrs[i].value)
	}
	return newNode;
}


function cmd(key) {
	if (mxClient.IS_MAC) {
		return "<span style='color:grey'>(&#8984;" + key + ")</span>";
	} else {
		return "<span style='color:grey'>(Ctrl-" + key + ")</span>";
	}
}


function inAgent(cell) {
	if ((!cell) || cell == null) {
		return false;
	}

	var p = getParent(cell);
	if (p) {
		//console.log(p);
		if (p.getAttribute("Type") == "Agent") {
			return true;
		}
	}
	return inAgent(p);
}


function parentAgent(cell) {
	if ((!cell) || cell == null) {
		return undefined;
	}

	var p = getParent(cell);
	if (p) {
		//console.log(p);
		if (p.getAttribute("Type") == "Agent") {
			return p;
		}
	}
	return parentAgent(p);
}


function isGray(color) {
	if (isUndefined(color)) {
		return true;
	}
	var c;
	if (color[0] == "#") {
		c = color;
	} else {
		c = colourNameToHex(color);
	}
	if (c == "#6482B9") {
		return true; //treat flows as grey alwayse
	}
	var start = c[1];
	if (c.length == 4) {
		for (var i = 2; i < c.length; i++) {
			if (c[i] != start) {
				return false;
			}
		}
	} else if (c.length == 7) {
		for (var i = 1; i < c.length; i = i + 2) {
			if (c[i] != start) {
				return false;
			}
		}
		var start = c[2];
		for (var i = 2; i < c.length; i = i + 2) {
			if (c[i] != start) {
				return false;
			}
		}
	}
	return true;
}

function colourNameToHex(colour) {
	var colours = {
		"aliceblue": "#f0f8ff",
		"antiquewhite": "#faebd7",
		"aqua": "#00ffff",
		"aquamarine": "#7fffd4",
		"azure": "#f0ffff",
		"beige": "#f5f5dc",
		"bisque": "#ffe4c4",
		"black": "#000000",
		"blanchedalmond": "#ffebcd",
		"blue": "#0000ff",
		"blueviolet": "#8a2be2",
		"brown": "#a52a2a",
		"burlywood": "#deb887",
		"cadetblue": "#5f9ea0",
		"chartreuse": "#7fff00",
		"chocolate": "#d2691e",
		"coral": "#ff7f50",
		"cornflowerblue": "#6495ed",
		"cornsilk": "#fff8dc",
		"crimson": "#dc143c",
		"cyan": "#00ffff",
		"darkblue": "#00008b",
		"darkcyan": "#008b8b",
		"darkgoldenrod": "#b8860b",
		"darkgray": "#a9a9a9",
		"darkgreen": "#006400",
		"darkkhaki": "#bdb76b",
		"darkmagenta": "#8b008b",
		"darkolivegreen": "#556b2f",
		"darkorange": "#ff8c00",
		"darkorchid": "#9932cc",
		"darkred": "#8b0000",
		"darksalmon": "#e9967a",
		"darkseagreen": "#8fbc8f",
		"darkslateblue": "#483d8b",
		"darkslategray": "#2f4f4f",
		"darkturquoise": "#00ced1",
		"darkviolet": "#9400d3",
		"deeppink": "#ff1493",
		"deepskyblue": "#00bfff",
		"dimgray": "#696969",
		"dodgerblue": "#1e90ff",
		"firebrick": "#b22222",
		"floralwhite": "#fffaf0",
		"forestgreen": "#228b22",
		"fuchsia": "#ff00ff",
		"gainsboro": "#dcdcdc",
		"ghostwhite": "#f8f8ff",
		"gold": "#ffd700",
		"goldenrod": "#daa520",
		"gray": "#808080",
		"green": "#008000",
		"greenyellow": "#adff2f",
		"honeydew": "#f0fff0",
		"hotpink": "#ff69b4",
		"indianred ": "#cd5c5c",
		"indigo ": "#4b0082",
		"ivory": "#fffff0",
		"khaki": "#f0e68c",
		"lavender": "#e6e6fa",
		"lavenderblush": "#fff0f5",
		"lawngreen": "#7cfc00",
		"lemonchiffon": "#fffacd",
		"lightblue": "#add8e6",
		"lightcoral": "#f08080",
		"lightcyan": "#e0ffff",
		"lightgoldenrodyellow": "#fafad2",
		"lightgrey": "#d3d3d3",
		"lightgreen": "#90ee90",
		"lightpink": "#ffb6c1",
		"lightsalmon": "#ffa07a",
		"lightseagreen": "#20b2aa",
		"lightskyblue": "#87cefa",
		"lightslategray": "#778899",
		"lightsteelblue": "#b0c4de",
		"lightyellow": "#ffffe0",
		"lime": "#00ff00",
		"limegreen": "#32cd32",
		"linen": "#faf0e6",
		"magenta": "#ff00ff",
		"maroon": "#800000",
		"mediumaquamarine": "#66cdaa",
		"mediumblue": "#0000cd",
		"mediumorchid": "#ba55d3",
		"mediumpurple": "#9370d8",
		"mediumseagreen": "#3cb371",
		"mediumslateblue": "#7b68ee",
		"mediumspringgreen": "#00fa9a",
		"mediumturquoise": "#48d1cc",
		"mediumvioletred": "#c71585",
		"midnightblue": "#191970",
		"mintcream": "#f5fffa",
		"mistyrose": "#ffe4e1",
		"moccasin": "#ffe4b5",
		"navajowhite": "#ffdead",
		"navy": "#000080",
		"oldlace": "#fdf5e6",
		"olive": "#808000",
		"olivedrab": "#6b8e23",
		"orange": "#ffa500",
		"orangered": "#ff4500",
		"orchid": "#da70d6",
		"palegoldenrod": "#eee8aa",
		"palegreen": "#98fb98",
		"paleturquoise": "#afeeee",
		"palevioletred": "#d87093",
		"papayawhip": "#ffefd5",
		"peachpuff": "#ffdab9",
		"peru": "#cd853f",
		"pink": "#ffc0cb",
		"plum": "#dda0dd",
		"powderblue": "#b0e0e6",
		"purple": "#800080",
		"red": "#ff0000",
		"rosybrown": "#bc8f8f",
		"royalblue": "#4169e1",
		"saddlebrown": "#8b4513",
		"salmon": "#fa8072",
		"sandybrown": "#f4a460",
		"seagreen": "#2e8b57",
		"seashell": "#fff5ee",
		"sienna": "#a0522d",
		"silver": "#c0c0c0",
		"skyblue": "#87ceeb",
		"slateblue": "#6a5acd",
		"slategray": "#708090",
		"snow": "#fffafa",
		"springgreen": "#00ff7f",
		"steelblue": "#4682b4",
		"tan": "#d2b48c",
		"teal": "#008080",
		"thistle": "#d8bfd8",
		"tomato": "#ff6347",
		"turquoise": "#40e0d0",
		"violet": "#ee82ee",
		"wheat": "#f5deb3",
		"white": "#ffffff",
		"whitesmoke": "#f5f5f5",
		"yellow": "#ffff00",
		"yellowgreen": "#9acd32"
	};

	if (typeof colours[colour.toLowerCase()] != 'undefined')
		return colours[colour.toLowerCase()];

	return false;
}


function flatten(arr) {
	var r = [];

	function recFlatten(a) {
		var i, ln, v;

		for (i = 0, ln = a.length; i < ln; i++) {
			v = a[i];

			if (Array.isArray(v)) {
				recFlatten(v);
			} else {
				r.push(v);
			}
		}

		return r;
	}

	return recFlatten(arr);
}

var downloadButton = function (name) {
	return {
		xtype: 'button',
		text: 'Download CSV',
		glyph: 0xf0ed,
		handler: function () {
			var grid = this.up("gridpanel");
			var store = grid.getStore();
			var columns = grid.columns;

			var res = "";

			res += columns.filter(function (x) {
				return !x.hidden;
			}).map(function (x) {
				return '"' + (x.text || x.name).replace(/"/g, '""') + '"';
			}).join(",");

			store.each(function (record) {
				var cells = [];
				columns.forEach(function (col) {
					var name = col.name || col.dataIndex;
					if (name) {
						//if (Ext.isFunction(col.renderer)) {
						// var value = col.renderer(record.get(name), null, record);
						//} else {
						var value = "" + record.get(name);
						//}
						cells.push('"' + value.replace(/"/g, '""') + '"');
					}
				});


				res += "\r\n" + cells.join(",");
			});

			downloadFile(name, res, 'text/csv');
		}
	};
}


function deepClone(target, obj, depth, fn) {
	var options, name, src, copy, copyIsArray, clone;

	// Only deal with non-null/undefined values
	if ((options = arguments[1]) != null) {
		// Extend the base object
		for (name in options) {
			src = target[name];
			copy = options[name];

			// Prevent never-ending loop
			if (target === copy) {
				continue;
			}
			if (fn) {
				var x = fn(copy);
				if (x) {
					target[name] = x;
					continue;
				}
			}
			// Recurse if we're merging plain objects or arrays
			if (depth > 0 && copy && ((copyIsArray = Array.isArray(copy)) || typeof (copy) == "object")) {
				if (copyIsArray) {
					copyIsArray = false;
					clone = src && Array.isArray(src) ? src : [];

				} else {
					clone = src && typeof (srv) == "object" ? src : {};
				}

				// Never move original objects, clone them
				target[name] = deepClone(clone, copy, depth - 1, fn);

				// Don't bring in undefined values
			} else if (copy !== undefined) {
				target[name] = copy;
			}
		}
	}

	// Return the modified object
	return target;

}


function exportSvg() {
	var scale = graph.view.scale;
	var bounds = graph.getGraphBounds();

	// Prepares SVG document that holds the output
	var svgDoc = mxUtils.createXmlDocument();
	var root = (svgDoc.createElementNS != null) ?
		svgDoc.createElementNS(mxConstants.NS_SVG, 'svg') : svgDoc.createElement('svg');

	if (root.style != null) {
		root.style.backgroundColor = '#FFFFFF';
	} else {
		root.setAttribute('style', 'background-color:#FFFFFF');
	}

	if (svgDoc.createElementNS == null) {
		root.setAttribute('xmlns', mxConstants.NS_SVG);
	}

	root.setAttribute('width', Math.ceil(bounds.width * scale + 2) + 'px');
	root.setAttribute('height', Math.ceil(bounds.height * scale + 2) + 'px');
	root.setAttribute('xmlns:xlink', mxConstants.NS_XLINK);
	root.setAttribute('version', '1.1');

	// Adds group for anti-aliasing via transform
	var group = (svgDoc.createElementNS != null) ?
		svgDoc.createElementNS(mxConstants.NS_SVG, 'g') : svgDoc.createElement('g');
	group.setAttribute('transform', 'translate(0.5,0.5)');
	root.appendChild(group);
	svgDoc.appendChild(root);

	// Renders graph. Offset will be multiplied with state's scale when painting state.
	var svgCanvas = new mxSvgCanvas2D(group);
	svgCanvas.translate(Math.floor(1 / scale - bounds.x), Math.floor(1 / scale - bounds.y));
	svgCanvas.scale(scale);

	var imgExport = new mxImageExport();
	imgExport.drawState(graph.getView().getState(graph.model.root), svgCanvas);


	var xml = (mxUtils.getXml(root));

	downloadFile(
		"Insight Maker Diagram.svg",
		xml,
		"text/svg");
};


"use strict";
/*

Copyright 2010-2020 Scott Fortmann-Roe. All rights reserved.

This file may distributed and/or modified under the
terms of the Insight Maker Public License (https://InsightMaker.com/impl).

*/

/*
Class: Insight Maker API

Functions to manipulate Insight Maker models.

Introduction:

The following is a set of API functions for Insight Maker. JavaScript is the language used for these interfaces. In addition to the Insight Maker specific functions listed here,
standard JavaScript is also supported in buttons.

There are three primary avenues for making use of this API.

* For the "Action" of Buttons embedded within models.

* For a parent page to manipulate an embedded IFRAME containing an Insight Maker model.

* Using the JavaScript console of the web browser to manipulate a model. To find the built-in JavaScript console for a web browser, 
see the relevant browser's documentation.

Primitive Types:

A number of the API function refer to primitives by their type. The following are the valid types. Types are usually quoted when used and should always be capitalized (e.g. "Stock").

* Stock
* Variable
* Converter
* Flow
* Link
* Text
* Picture
* Folder
* Button
* Ghost

Examples:

The following examples illustrate the usage of the API for certain scenarios.

Using Dialogs:

Ask the user to specify a URL and opens a new web page at the location.

> showURL(showPrompt("What page should I open?"));

Expanding and Collapsing Folders:

This example expands all the folders in the model.

> expandFolder(findType("Folder"));

And this collapses them.

> collapseFolder(findType("Folder"));

Notes:

Show the notes for all flow and link primitives in the model.

> var connectors = findType(["Flow", "Link"]);
> showNote(connectors);

Using Opacity:

Makes the currently selected primitives partially transparent.

> setOpacity(getSelected(), 50);

Rabbit Birth Rate:

This  example will  work with the default Insight Maker model.
It prompts the user to specify the birth rate for the rabbit population.
It then sets the relevant primitive to that value and runs the model.

> var birthRate = showPrompt("Enter the birth rate for the rabbits:", 0.1);
> var birthPrimitive = findName("Rabbit Birth Rate");
> setValue(birthPrimitive, birthRate);
> runModel();

This could also be written more compactly as

> setValue(findName("Rabbit Birth Rate"), showPrompt("Enter the birth rate for the rabbits:", 0.1));
> runModel();

Building a Model:

This example creates a new model with two stocks connected by a flow.

> clearModel();
>
> var source = createPrimitive("Source", "Stock", [100, 50], [140, 50]);
> setValue(source, 100); //Give the source an initial value of 100
>
> var sink = createPrimitive("Sink", "Stock", [100, 300], [140, 50]);
>
> var myFlow = createConnector("Leakage", "Flow", source, sink);
> setValue(myFlow, "0.1*[Source]"); //10% of the source's volume moves to the sink each time period

Manipulating a Model in an IFRAME:

To access the API of an embedded IFRAME, first give the IFRAME an "id" property. This is not added by default in Insight Maker. For instance change

> <IFRAME SRC="...

to

> <IFRAME ID="InsightMakerModel1" SRC="...

Then from the parent page you can use the following JavaScript syntax to call API functions. This example calls the API's <clearModel> function.

> document.getElementById('InsightMakerModel1').contentWindow.postMessage("clearModel()", "*");


*/


/*

Group: Dialogs and User Input

*/


/*
Method: showMessage

Shows a message in a dialog window.

Parameters:

message - The string to show as the message.

See also:

<showPrompt>, <showChoice>
*/


function showMessage(message) {
	alert(message);
	//Ext.Msg.alert('', message);
}

/*
Method: showPrompt

Shows a prompt in a dialog window and provides a text input for the user to enter a value.

Parameters:

message - The string to show as the prompt.
defaultValue - The default value for the prompt. This parameter is optional.

Returns:

The value entered by the user.

See also:

<showMessage>, <showChoice>
*/

function showPrompt(message, defaultValue) {
	return prompt(message, defaultValue)
}

/*
Method: showChoice

Shows a prompt in a dialog window and provides the user the option to click "OK" or "Cancel". Returns the value the user clicked as a boolean.

Parameters:

message - The string to show as the prompt.

Returns:

The value of the button clicked by the user as a boolean. "OK" is true, "Cancel" is false.

See also:

<showMessage>, <showPrompt>
*/


function showChoice(message) {
	return confirm(message);
}

/*
Method: showURL

Creates a new web browser window and sets the URL.

Parameters:

url - The URL to show.

*/

function showURL(url) {
	var win = window.open(url, '', 'scrollbars=yes,menubar=yes,height=500,width=700,resizable=yes,toolbar=yes,location=yes,status=yes');
	if (open == win || typeof (win) == 'undefined') {
		Ext.Msg.alert('', "<big><big><center><a href='" + url + "' target='_blank'><i class='fa fa-external-link-square'></i> Open Link</a></center></big></big>")
	}
}

/*
Method: downloadFile

Downloads a file.

Parameters:

fileName - The name of the file to download
data - The data to download
type - The type of file

*/

function downloadFile(fileName, data, type) {
	var a = document.createElement("a");
	document.body.appendChild(a);

	var blob = new Blob([data], { type: type || "octet/stream" }),
		url = window.URL.createObjectURL(blob);
	a.href = url;
	a.download = fileName;
	a.click();
	window.URL.revokeObjectURL(url);
	a.remove();
};

/*
Method: showData

Creates a display to showcase data. Multiple tabs of data may be shown. This function is passed an array of objects each representing an individual tab.

Parameters:

title - The title for the data window
tabs - An array of tab objects
size - The dimensions of the window in the form [width, height] (optional)

Tab Objects:

Each tab object contains several properties.

name - The name of the tab
type - The tab type. E.g. "text", "HTML", "table" or "chart"
data - The data for the tab

The different types of tabs are as follows.

Text Tab:

A text tab displays a large amount of text. For a text tab, the data property should be the text string that will be displayed.

HTML Tab:

An HTML tab displays HTML content. For an HTML tab, the data property should be the HTML content that will be displayed.

Table Tab:

A table tab displays a grid of data. For a table tab, the data object should be an array of arrays. Each inner array represents a column in the resulting table. The following property is also supported for tables.

header - For a table, an array containing containing the titles of the columns (optional)

Chart Tab:

A chart creates a graphical display of your data. In this case the data should be an array of series objects.

The following properties are also supported.

xData - The x coordinates for the series (each series must have the same number of points with the same x-coordinates). In the form [x1, x2, ..., xn]
xType - The data type for the x-axis can be "numeric" or "category" (for use with categorical data such as column charts). By default, "numeric" data is assumed. (optional)
xLabel - A string for the x-Axis label (optional)
yLabel - A string for the y-Axis label (optional)
legend - A string controlling the position of the legend. Can be "left", "right", "bottom", "top", or "none" (optional)
verticalGrid - True/false value whether or not to plot a vertical grid (optional)
horizontalGird - True/false value whether or not to plot a horizontal grid (optional)
xMin - The minimum value of the x-Axis (optional)
xMax - The maximum value of the x-Axis (optional)
yMin - The minimum value of the y-Axis (optional)
yMax - The maximum value of the y-Axis (optional)

Each series object has the following the properties:

data - An array containing the data for the series of the form [y1, y2, ..., yn]
type - The display type for the series. Can be "line" or "bar"
name - The series name as a string (for display in the legend)
color - The color of the series. A string such as "green" or "#00ff00" (optional)
hideLegend - Prevents the series from being displayed in the legend (optional)
fill - If the series is a line series, creates a solid filled area between the line and  the x-axis (optional)
hideMarkers - Hides the markers for individual data points (optional)

Returns:

The window object that was created.

Example:

> showData("Sample Data",
>  [
>  {name: "A Chart",
>	type: "chart",
>	xLabel: "Chart x-Axis",
>	yLabel: "Chart y-Axis",
>	legend: "top",
>	horizontalGrid: true,
>	verticalGrid: true,
>	xType: "numeric",
>	xData: [1,2,3,4,5],
>	data: [{
>		data: [1,4,9,16,25],
>		type: "line",
>		name: "Energy"
>	},{
>		data: [1,2,3,4,5],
>		type: "line",
>		name: "Cost"
>	}]
>	},
>  {name: "I'm a Text Tab",
>	type: "text",
>	data: "This is a long data string..."
>	},
>  {name: "I'm an HTML Tab",
>	type: "html",
>	data: "<center><p>This is <b>HTML</b> content.</p></center>"
>	},
>  {name: "Here's a Grid",
>	type: "table",
>	data: [[1,2,3,4],[1,4,9,16]],
>	header: ["Value", "Value^2"]
>	}
>  ]
> )


*/

function showData(title, tabs, size) {
	if (!size) {
		size = [Math.min(Ext.getBody().getViewSize().width, 640), Math.min(Ext.getBody().getViewSize().height, 480)];
	}

	var tabItems = [];
	for (var i = 0; i < tabs.length; i++) {
		var tab = {
			layout: "fit"
		};
		tab.title = tabs[i].name;
		if (tabs[i].type.toLowerCase() == "text") {
			var textData = {
				xtype: "textareafield",
				value: tabs[i].data,
				readOnly: true
			};
			tab.items = [textData];
		} else if (tabs[i].type.toLowerCase() == "html") {
			var htmlData = {
				title: "Insight Equations",
				xtype: "box",
				html: tabs[i].data,
				style: "background-color: white",
				autoScroll: true
			};
			tab.items = [htmlData];
		} else if (tabs[i].type.toLowerCase() == "table") {
			var gridData = {
				xtype: "grid"
			};
			var gridColumns = [];
			var storeFields = [];
			var data = []
			for (var j = 0; j < tabs[i].data.length; j++) {
				gridColumns.push({
					dataIndex: "a" + j,
					text: tabs[i].header ? tabs[i].header[j] : ""
				});
				var columnType = "float";
				for (var k = 0; k < tabs[i].data[j].length; k++) {
					if ((typeof tabs[i].data[j][i]) == "string") {
						columnType = "string";
					}
				}
				storeFields.push({
					name: "a" + j,
					type: columnType
				})

			}
			for (var k = 0; k < tabs[i].data[0].length; k++) {
				data.push({});
			}
			for (var j = 0; j < tabs[i].data.length; j++) {
				for (var k = 0; k < tabs[i].data[0].length; k++) {
					data[k]["a" + j] = tabs[i].data[j][k];
				}
			}

			gridData.columns = gridColumns;
			gridData.store = new Ext.data.JsonStore({
				fields: storeFields,
				data: data
			});
			if (!tabs[i].header) {
				gridData.hideHeaders = true;
			}

			gridData.dockedItems = [{
				xtype: 'toolbar',
				dock: 'bottom',
				items: ["->", downloadButton(tabs[i].name)]
			}];
			tab.items = [gridData];

		} else if (tabs[i].type.toLowerCase() == "chart") {
			var defaultColors = ["#94ae0a", "#115fa6", "#a61120", "#ff8809", "#ffd13e", "#a61187", "#24ad9a", "#7c7474", "#a66111"];
			var defaultColorIndex = 0;
			var colors = [];
			for (var j = 0; j < tabs[i].data.length; j++) {
				if (tabs[i].data[j].color) {
					colors.push(tabs[i].data[j].color);
				} else {
					colors.push(defaultColors[defaultColorIndex]);
					defaultColorIndex++;
					defaultColorIndex = defaultColorIndex % defaultColors.length;
				}
			}

			var dataSeries = [];
			var storeFields = [{
				name: "x",
				type: tabs[i].xType.toLowerCase() == "numeric" ? "float" : "string"
			}];
			var yFields = [];
			var data = [];
			for (var j = 0; j < tabs[i].xData.length; j++) {
				data.push({
					x: tabs[i].xData[j]
				});
			}

			for (var j = 0; j < tabs[i].data.length; j++) {
				storeFields.push({
					name: "a" + j,
					type: "float"
				});

				dataSeries.push({
					shadow: false,
					type: tabs[i].data[j].fill ? "area" : tabs[i].data[j].type.toLowerCase(),
					title: tabs[i].data[j].name,
					colors: [colors[j]],
					axis: 'left',
					xField: 'x',
					yField: "a" + j,
					showInLegend: tabs[i].data[j].hideLegend ? false : true,
					showMarkers: tabs[i].data[j].hideMarkers ? false : true,
					style: {
						opacity: 1,
						"stroke-width": 3
					},
					marker: {
						radius: 3
					},
					animation: false
				});
				if (tabs[i].data[j].fill) {
					dataSeries[dataSeries.length - 1].style["stroke-width"] = 0;
				}

				yFields.push("a" + j);

				for (var k = 0; k < tabs[i].data[j].data.length; k++) {
					data[k]["a" + j] = tabs[i].data[j].data[k];
				}
			}



			var chartData = {
				xtype: "cartesian",

				animation: false,
				shadow: false,
				interactions: 'crosszoom',

				store: new Ext.data.JsonStore({
					fields: storeFields,
					data: data
				}),
				axes: [{
					position: "bottom",
					type: tabs[i].xType ? tabs[i].xType.toLowerCase() : "numeric",
					grid: tabs[i].verticalGrid ? tabs[i].verticalGrid : false,
					title: {
						text: tabs[i].xLabel ? tabs[i].xLabel : "",
						fontSize: 14
					},
					fields: ["x"],
					minimum: tabs[i].xMin,
					maximum: tabs[i].xMax
				}, {
					position: "left",
					type: "numeric",
					grid: tabs[i].horizontalGrid ? tabs[i].horizontalGrid : false,

					title: {
						text: tabs[i].yLabel ? tabs[i].yLabel : "",
						fontSize: 14
					},
					titleMargin: 20,
					fields: yFields,
					minimum: tabs[i].yMin,
					maximum: tabs[i].yMax
				}],
				series: dataSeries
			};

			if (tabs[i].legend && tabs[i].legend != 'none') {
				chartData.legend = {};
				chartData.legend.docked = tabs[i].legend;
				chartData.legend.toggleable = !tabs[i].legendStatic;
			}


			tab.items = [chartData];



		} else {
			alert("Unknown tab type: " + tabs[i].type);
		}
		tabItems.push(tab);
	}

	var win = new Ext.Window({
		title: title,
		layout: 'fit',
		closeAction: 'destroy',
		border: false,
		modal: false,
		resizable: true,
		closable: true,
		maximizable: true,
		minimizable: true,
		shadow: true,
		width: size[0],
		height: size[1],
		items: [{
			xtype: "tabpanel",
			layout: "fit",
			items: tabItems
		}]
	});

	win.on('minimize', function (w) {
		if (w.expandedState) {
			w.expandedState = false;
			w.collapse();
		} else {
			w.expandedState = true;
			win.expand();
		}
	});


	win.show();

	return win;
}

/*
Method: frontWindow

Gets the front-most window (if one exists).

Returns:

A window object.

*/

function frontWindow() {
	return Ext.WindowMgr.getActive();
}

/*
Method: closeAllWindows

Closes all open windows.

*/

function closeAllWindows() {
	var w;
	while (w = Ext.WindowMgr.getActive()) {
		w.close();
	}
}


/*
Method: openFile

Prompts the user to select one or more files on their computer. Information about the selected files are made available and the contents of the files are optionally read into memory.

Note that this function needs to be called as a direct result of user actions (such as the user clicking on a button). Browser security restrictions will prevent the function from operating if it is not called in response a user actions. Note also that this function is not supported on Internet Explorer 9.

Parameters:

config - A configuration object with the following optional properties:
multiple - If false, only a single file may be selected; if true, one or more files may be selected at a time.
accept - A string containing a MIME file type to filter file selection. If defined, only files matching the specified type may be selected. For example, "image/*" may be used to only accept image files.
read - If defined the selected files will be opened and their contents loaded. Read may either be "binary" in which case the contents is loaded as a binary string, "text" in which case the contents is loaded as a regular text string, or "xlsx" in which case an Excel file is loaded as an object.
onCompleted - A function to handle results. The openFile function is asynchronous. Once it completes, the callback function is called with the resulting data as a parameter.
onError - A function to handle the occurrence of an error.
onSelected - A function fired once files have been selected but before data has been read.

Returns:

The openFile function is asynchronous and returns nothing directly. On the successful selection of files, the callback is called with the results. 

If config.multiple is false, these results are a single file object. If config.multiple is true, then these results are an array of file objects. Each file object has the following properties:

file - The original file object.
name - The name of the selected file.
type - The type of the selected file.
size - The size of the selected file.
contents - If config.read is true, the contents in the file is loaded with the specified type.

Examples:

>// Select a single text file and display its contents
>openFile({
>	read: "text",
>	multiple: false,
>	onCompleted: function(result){
>		alert(result.contents);
>	}
>});

*/

function openFile(config) {
	config = config || {
		multiple: false,
		accept: null,
		onCompleted: null,
		onSelected: null,
		onError: null,
		read: false
	};
	if (config.read) {
		config.read = config.read.toLowerCase();
	}
	if (config.read == "xlsx" && (!config.accept)) {
		config.accept = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
	}

	var opener = document.createElement("input");
	opener.setAttribute("type", "file");
	if (config.multiple) {
		opener.setAttribute("multiple", true);
	}
	if (config.accept) {
		opener.setAttribute("accept", config.accept);
	}

	var res = null;

	var loadCount = 0;
	var handleLoad = function () {
		$(opener).remove();

		if (!res.length) {
			config.onCompleted(res);
		} else {
			loadCount++;
			if (loadCount == res.length) {
				config.onCompleted(res);
			}
		}

	}

	var processFile = function (file) {
		var data = {};
		data.file = file;
		data.size = file.size;
		data.name = file.name;
		data.type = file.type;

		var reader = new FileReader();
		reader.onloadend = function (evt) {
			if (config.read == "xlsx") {
				require(['jszip'], function () {
					require(['xlsx'], function () {
						data.contents = XLSX.read(reader.result, {
							type: "binary"
						});
						handleLoad();
					});
				});
			} else {
				data.contents = reader.result;
				handleLoad();
			}
		};
		reader.onerror = function () {
			if (config.onError) {
				config.onError(reader.error)
			} else {
				alert("FileReader error.");
				console.log("FileReader Error");
				console.log(reader.error);
			}
		};

		reader.onabort = function () {
			if (config.onError) {
				config.onError(reader.error)
			} else {
				alert("FileReader aborted.");
				console.log("FileReader Error");
				console.log(reader.error);
			}

		}

		if (config.read == "binary") {
			reader.readAsBinaryString(file);
		} else if (config.read == "text") {
			reader.readAsText(file);
		} else if (config.read == "xlsx") {
			reader.readAsBinaryString(file);
		} else if (!config.read) {
			// leaving empty means don't load
			setTimeout(handleLoad, 1);
		} else {
			throw "Unknown data read type: " + config.type;
		}
		return data;
	}

	var callback = function () {

		var files = opener.files;

		if (config.onSelected) {
			config.onSelected(files);
		}

		if (config.onCompleted) {

			if (typeof files[0] == "undefined") {
				config.onCompleted(null);
			}

			if (!config.multiple) {
				res = processFile(files[0]);
			} else {
				res = Array.prototype.slice.call(files).map(function (x) {
					return processFile(x);
				});
			}
		}
	}

	opener.onchange = callback;
	document.body.appendChild(opener);
	opener.click();
}


/*

Group: General Model Functions

*/

/*
Method: runModel

Runs a simulation and optionally returns the results.

Parameters:

config - A configuration object. For compatibility, if set to the Boolean value, equivalent to calling runModel with a configuration object with the silent property set to the boolean value.
config.silent - If false or undefined, behaves the same way as if the user clicked the run simulation button. If true, no visible response is shown to running the simulation and the results of the simulation are returned as an object.
config.selectedDisplay - The selected tab in the display, should be a display primitive.
config.rate - A multiplier to control the speed of the animation in the result window. Use -1 to skip animation.
config.onSuccess(results) - Callback called when the simulation completes successfully.
config.onError(results) - Callback called when an error occurs during the simulation.
config.onPause(results) - Callback called when the simulation is paused. If this is set and a pause interval is defined for the model, then the simulation will be asynchronous and a results object will not be returned directly by the function call. 

Returns:

If silent is true, returns the simulation results as a results object. If callbacks are defined, the callbacks are called with a results object. This object contains the following properties.

times - The times for each period of the simulation as an array.
value(primitive) - A function that takes a primitive reference and returns an array of the values that primitive took on over the course of the simulation.
lastValue(primitive) - A function that takes a primitive reference and returns the last value of the primitive during the simulation.
window - The results window object (if config.silent is false).
error - "none" if no simulation error occurred, otherwise an error message.
errorPrimitive - The primitive that caused the error.
resume() - If the simulation was paused, this function may be called to resume the simulation. Please note that Insight Maker currently only supports running a single simulation at a time. When a new simulation is started, any currently paused simulations will be terminated immediately.
setValue(primitive, value) - If the simulation is paused, allows changing the value of a primitive. Value can be any equation that does not depend on the model state. E.g. "{Cows: 1, Sheep: 2} * 2" is a valid Value, but "[Other Primitive] + 1" is not.
stochastic - True if the simulation contained an element of randomness.

Examples:

> # Runs a simulation, and displays the average value of the Stock named "Rabbits"
> runModel({
>   onSuccess: function(results){
>      var sum = 0;
>      for(var i = 0; i < results.times.length; i++){
>          sum += results.value(findName("Rabbits"))[i];
>      }
>      showMessage("The average value is: " + sum/results.times.length);
>   }
> })

> # Create interactive run of the model where the primitive "Rate" is adjusted each pause interval
> runModel({
> 	silent: true,
> 	onPause: function(results){
> 		console.log("Simulation Step");
> 		results.setValue(findName("Rate"), prompt("Enter New 'Rate' Value"));
>		results.resume();
> 	},
> 	onSuccess: function(results){
> 		console.log("Simulation Done");
> 		console.log(results);
> 	},
> 	onError: function(){
> 		alert("A simulation error occurred.");
> 	}
> });

*/

function runModel(config) {
	if (simulationRunning()) {
		if ((!simulate.config.silent) && (!config.resultsWindow)) {
			mxUtils.alert(getText("You have an existing simulation running that has not yet completed. Either close the results window or press the window's 'Stop' button. You may then run a new simulation."));
			simulate.resultsWindow.show();
			return;
		}
	}

	if (isUndefined(config)) {
		config = { silent: graph instanceof SimpleNode };
	} else if (typeof config == 'boolean') {
		config = {
			silent: config
		};
	}
	return runSimulation(config);
}

function simulationRunning() {
	return simulate && (!simulate.completed());
}

function endRunningSimulation() {
	if (simulate) {
		simulate.terminate();
	}
}

/*
Method: saveModel

Saves the model.

Parameters:

dialog - Pass true to show the properties dialog (e.g. name, description, tags). The dialog is always shown if this is the first save.

*/



function saveModel(dialog) {
	if (dialog || graph_title == "") {
		updateProperties();
	} else {
		if (!unfoldingManager.unfolding) {
			sendGraphtoServer(graph);
		}
	}
}


/*
Method: clearModel

Removes all primitives from the model.
*/


function clearModel() {
	if (graph instanceof SimpleNode) {
		graph.children[0].children[0].children = graph.children[0].children[0].children.filter(function (x) {
			return x.value.nodeName == "Setting";
		});
		clearPrimitiveCache();
	} else {
		graph.getModel().beginUpdate();
		graph.allowButtonSelect = true;
		graph.selectAll();
		graph.allowButtonSelect = false;
		graph.removeCells(graph.getSelectionCells(), false);
		graph.getModel().endUpdate();
	}
}

/*
Method: layoutModel

Reorganizes the primitives in the model according to an algorithm.

Parameters:

algorithm - The algorithm used to calculate the new positions of the primitive. Either "organic" or "circular".

*/

function layoutModel(algorithm) {
	if (algorithm == "organic") {
		var layout = new mxFastOrganicLayout(graph);
		layout.forceConstant = 50;
		executeLayout(layout, true);
	} else if (algorithm == "circular") {
		executeLayout(new mxCircleLayout(graph), true);
	} else if (algorithm == "hierarchical") {
		var layout = new mxCompactTreeLayout(graph);
		layout.horizontal = false;
		layout.resizeParent = false;
		layout.moveTree = false;
		executeLayout(layout, true);
	} else {
		alert("Unknown layout algorithm: " + algorithm);
	}
}

var executeLayout = function (layout, animate, ignoreChildCount) {
	var cell = graph.getSelectionCell();

	if (cell == null || (!ignoreChildCount && graph.getModel().getChildCount(cell) == 0)) {
		cell = graph.getDefaultParent();
	}

	graph.getModel().beginUpdate();
	try {
		layout.execute(cell);
	} catch (e) {
		throw e;
	} finally {
		// Animates the changes in the graph model except
		// for Camino, where animation is too slow
		if (animate && navigator.userAgent.indexOf('Camino') < 0) {
			// New API for animating graph layout results asynchronously
			var morph = new mxMorphing(graph);
			morph.addListener(mxEvent.DONE, function () {
				graph.getModel().endUpdate();
			});

			morph.startAnimation();
		} else {
			graph.getModel().endUpdate();
		}
	}

};

/*
Method: setZoom

Sets the scale of the diagram display.

Parameters:

scale - The diagram scale. If this is a number, then it determine the scale level. 1 means 100%, 0.5 means 50%, 2 means 200% and so on. You also pass one of the following strings: "fit" to fit the model to the diagram area, "actual" to reset the scale, "in" to zoom further in based on the current scale, and "out" to further out based on the current scale.

*/

function setZoom(scale) {
	if (scale == "fit") {
		graph.fit();
	} else if (scale == "actual") {
		graph.zoomActual();
	} else if (scale == "in") {
		graph.zoomIn();
	} else if (scale == "out") {
		graph.zoomOut();
	} else {
		graph.getView().setScale(scale);
	}
}


/*

Group: Simulation Settings

*/

/*
Method: getTimeStep

Gets the time step used in the simulation.

Returns:

The time step for the simulation as a floating point number.

See also:

<setTimeStep>
*/


function getTimeStep() {
	return parseFloat(getSetting().getAttribute("TimeStep"));
}


/*
Method: setTimeStep

Sets the time step used in the simulation.

Parameters:

timeStep - The time step to be used in the simulation.

See also:

<getTimeStep>
*/


function setTimeStep(timeStep) {
	setAttributeUndoable(
		getSetting(), "TimeStep",
		timeStep);

}

/*
Method: getTimeStart

Gets the start time for the simulation.

Returns:

The start time for the simulation as a floating point number.

See also:

<setTimeStart>
*/


function getTimeStart() {
	return parseFloat(getSetting().getAttribute("TimeStart"));
}


/*
Method: setTimeStart

Sets the start time for the simulation.

Parameters:

timeStart - The start time for the simulation.

See also:

<getTimeStart>
*/


function setTimeStart(timeStart) {
	setAttributeUndoable(
		getSetting(), "TimeStart",
		timeStart);

}

/*
Method: getTimeLength

Gets the length of the simulation.

Returns:

The length of the simulation as a floating point number.

See also:

<setTimeLength>
*/

function getTimeLength() {
	return parseFloat(getSetting().getAttribute("TimeLength"));
}


/*
Method: setTimeLength

Sets the length of the simulation.

Parameters:

timeLength - The length of the simulation.

See also:

<getTimeLength>
*/


function setTimeLength(timeLength) {
	setAttributeUndoable(
		getSetting(), "TimeLength",
		timeLength);
}

/*
Method: getPauseInterval

Gets the intervals at which to pause the simulation.

Returns:

The pause interval as a floating point number. Returns undefined if a pause interval has not been specified.

See also:

<setPauseInterval>
*/

function getPauseInterval() {
	return parseFloat(getSetting().getAttribute("TimePause"));
}


/*
Method: setPauseInterval

Sets the intervals at which to pause the simulation.

Parameters:

pauseInterval - The pause interval for the simulation.

See also:

<setPauseInterval>
*/


function setPauseInterval(pauseInterval) {
	setAttributeUndoable(
		getSetting(), "TimePause",
		pauseInterval);
}

/*
Method: getTimeUnits

Gets the time units of the simulation.

Returns:

The time units of the simulation (e.g. "Seconds", "Minutes", "Days", "Years").

See also:

<setTimeUnits>
*/


function getTimeUnits() {
	return getSetting().getAttribute("TimeUnits");
}


/*
Method: setTimeUnits

Sets the time units of the simulation.

Parameters:

units - The time units of the simulation (e.g. "Seconds", "Minutes", "Days", "Years").

See also:

<getTimeUnits>
*/


function setTimeUnits(units) {
	setAttributeUndoable(
		getSetting(), "TimeUnits",
		units);
}


/*
Method: getAlgorithm

Gets the algorithm for the simulation.

Returns:

The algorithm for the simulation as a string. "RK1" indicates Euler's method. "RK4" indicates a 4th order Runge-Kutta method.

See also:

<setAlgorithm>
*/


function getAlgorithm() {
	return getSetting().getAttribute("SolutionAlgorithm");
}


/*
Method: setAlgorithm

Sets the algorithm of the simulation.

Parameters:

algorithm - The algorithm for the simulation. "RK1" indicates Euler's method. "RK4" indicates a 4th order Runge-Kutta method.

See also:

<getAlgorithm>
*/


function setAlgorithm(algorithm) {
	setAttributeUndoable(
		getSetting(), "SolutionAlgorithm",
		algorithm);

}

/*
Method: getMacros

Gets the macros for the insight.

Returns:

The macros for the insight as a string.

See also:

<setMacros>
*/


function getMacros() {
	return getSetting().getAttribute("Macros");
}


/*
Method: setMacros

Sets the macros of the insight.

Parameters:

macros - The macros for the insight.

See also:

<getMacros>
*/


function setMacros(macros) {
	setAttributeUndoable(
		getSetting(), "Macros",
		macros);
}

/*

Group: Finding and Accessing Specific Primitives

*/

/*
Method: findName

Finds and returns a primitive by its name. If more than one primitive with the same name exists, returns an array of primitives.

Parameters:

name - The name of the primitive to return as a string. Also accepts an array of strings in which case all the primitives named in the array will be returned.

Return:

A primitive. If multiple primitives exist with the same name, an array of primitives will be returned. Returns null if no primitives are found.

See also:

<findType>, <findAll>, <findID>, <findNote>, <findValue>

*/


function findName(name) {
	var res = map(name, function (name) {
		var res = [];
		var myCells = findAll();
		for (var i = 0; i < myCells.length; i++) {
			if (isDefined(myCells[i].getAttribute("name")) && myCells[i].getAttribute("name").toLowerCase() == name.toLowerCase()) {
				res.push(myCells[i]);
			}
		}
		return res;
	});

	res = flatten(res);
	res = res.filter(function (val) {
		return val !== null;
	});

	if (name instanceof Array) {
		return res;
	} else {
		if (res.length == 0) {
			return null;
		} else if (res.length == 1) {
			return res[0];
		} else {
			return res;
		}

	}

}

/*
Method: findAll

Finds and returns all primitives in the model.

Return:

An array of primitives.

See also:

<findName>, <findType>, <findID>, <findNote>, <findValue>

*/


function findAll() {
	var all = primitives();
	var res = [];
	for (var i = 0; i < all.length; i++) {
		if (!(all[i].value.nodeName == "Setting" || all[i].value.nodeName == "Display")) {
			res.push(all[i]);
		}
	}
	return res;
}




/*
Method: findType

Finds and returns all primitives of a specific type.

Parameters:

type - The type of primitives to return. For instance: "Stock", "Flow", "Link", "Text", "Button", "Picture", "Converter" or "Variable". An array of type strings may also be passed.

Return:

An array of primitives of the specified type.

See also:

<findName>, <findAll>, <findID>, <findNote>, <findValue>

*/


function findType(type) {
	var res = map(type, function (type) {
		var t = type;
		return primitives(t);

	});
	res = flatten(res);
	return res;

}

/*
Method: findID

Finds and returns a primitive using its ID.

Parameters:

ID - The ID of the primitive to find. May also be an array of IDs.

Return:

A primitive. If an array of IDs was passed, returns an array of primitives.

See also:

<findName>, <findType>, <findAll>, <findValue>, <findNote>, <getID>

*/



function findID(id) {
	var myCells = primitives();
	var res = map(id, function (id) {
		for (var i = 0; i < myCells.length; i++) {
			if (myCells[i].id == id) {
				return myCells[i];
			}
		}
		return null;
	});
	if (res === null) {
		return res;
	}
	if (id instanceof Array) {
		return res;
	} else {
		if (res.length == 1) {
			return res[0];
		} else {
			return res;
		}
	}
}

/*
Method: findValue

Finds and returns all primitives whose values match a regular expression.

Parameters:

search - The regular expression to search for. Can also be a string in which case the primitive values will be tested for strict case-sensitive equality against the string. May also be an array of regular expressions and strings in which case any primitive with a value that matches one element of the array will be returned.

Return:

An array of primitives whose values match the regular expression. Returns an empty array if no primitives match.

Example:

> // Returns all primitives that use the log function
> var containingLog = findValue(/log\(/i);
>
> // Returns all primitives whose value is strictly "1"
> var isOne = findValue("1");

See also:

<findName>, <findType>, <findAll>, <findNote>, <getID>

*/


function findValue(search) {
	var myCells = findAll();


	var res = map(search, function (regEx) {
		var res = [];
		for (var i = 0; i < myCells.length; i++) {
			if (regEx instanceof RegExp) {
				if (regEx.test(getValue(myCells[i]))) {
					res.push(myCells[i]);
				}
			} else {
				if (getValue(myCells[i]) == regEx) {
					res.push(myCells[i]);
				}
			}
		}
		return res;
	});

	return uniquePrimitives(flatten(res));
}

/*
Method: findNote

Finds and returns all primitives whose notes match a regular expression.

Parameters:

search - The regular expression to search for. Can also be a string in which case the primitive notes will be tested for strict case-sensitive equality against the string. May also be an array of regular expressions and strings in which case any primitive with a note that matches one element of the array will be returned.

Return:

An array of primitives whose notes match the regular expression. Returns an empty array if no primitives match.

See also:

<findName>, <findType>, <findAll>, <findValue>, <getID>

*/


function findNote(search) {
	var myCells = findAll();


	var res = map(search, function (regEx) {
		var res = [];
		for (var i = 0; i < myCells.length; i++) {
			if (regEx instanceof RegExp) {
				if (regEx.test(getNote(myCells[i]))) {
					res.push(myCells[i]);
				}
			} else {
				if (getNote(myCells[i]) == regEx) {
					res.push(myCells[i]);
				}
			}
		}
		return res;
	});

	return uniquePrimitives(flatten(res));
}


/*

Group: Create and Delete Primitives

*/

/*
Method: createPrimitive

Creates a new primitive and adds it to the model. This function is only for node-type primitives not connectors (e.g. flows or links).

Parameters:

name - The name of the primitive to add.
type - The type of the primitive to add. For example, "Variable" or "Stock".
position - The location of the upper-left corner of the primitive in the form: [x, y].
size - The dimensions of the primitive in the form: [width, height].

Return:

The newly created primitive.

See also:

<createConnector>, <removePrimitive>

*/

function createPrimitive(name, type, position, size) {


	var t = type.toLowerCase();

	if (graph instanceof SimpleNode) {
		var parent = graph.children[0].children[0];
		var vertex = simpleCloneNode(primitiveBank[t], parent);
		parent.children.push(vertex);
		clearPrimitiveCache();
	} else {
		var parent = graph.getDefaultParent();

		var vertex = graph.insertVertex(parent, null, primitiveBank[t].cloneNode(true), position[0], position[1], size[0], size[1], t);
	}



	setName(vertex, name);

	if (vertex.value.nodeName == "Converter") {
		setConverterInit(vertex);
	}

	if (isValued(vertex) || vertex.value.nodeName == "Agents") {
		var displays = primitives("Display");
		for (var i = 0; i < displays.length; i++) {
			var d = displays[i];
			if (isTrue(d.getAttribute("AutoAddPrimitives")) && d.getAttribute("Type") != "Scatterplot" && (d.getAttribute("Type") != "Map" || vertex.value.nodeName == "Agents")) {
				var s = d.getAttribute("Primitives");
				if (typeof (s) == "undefined") {
					d.setAttribute("Primitives", vertex.id);
				} else {
					var items = s.split(",");
					items.push(vertex.id);
					d.setAttribute("Primitives", items.join(","));
				}
			}
		}
	}



	return vertex;
}

/*
Method: createConnector

Creates a new connector primitive and adds it to the model.

Parameters:

name - The name of the primitive to add.
type - The type of the primitive to add: "Link" or "Flow".
alpha - The primitive that will be at the start of the connector.
omega - The primitive that will be at the end of the connector.

Return:

The newly created connector primitive.

See also:

<createPrimitive>, <removePrimitive>

*/

function createConnector(name, type, alpha, omega) {


	var x;
	var usedTemp = false;


	var t = (type).toLowerCase();

	if (graph instanceof SimpleNode) {
		var parent = graph.children[0].children[0];

		if (alpha) {
			parent = alpha.parent;
		}
		if (omega) {
			parent = omega.parent;
		}
		var edge = simpleCloneNode(primitiveBank[t], parent);
		parent.children.push(edge);
		setEnds(edge, [alpha, omega]);
		clearPrimitiveCache();
	} else {
		var parent = graph.getDefaultParent();

		if (omega == null && alpha == null) {
			usedTemp = true;
			x = createPrimitive("temp stock xyz", "Stock", [300, 300], [10, 10]);
			alpha = x;
			omega = x;
		} else if (alpha == null) {
			usedTemp = true;

			var pos = getPosition(omega);
			var size = getSize(omega);
			x = createPrimitive("temp stock xyz", "Stock", [pos[0] + size[0] / 2 - 5, pos[1] - 120], [10, 10]);

			alpha = x;

		} else if (omega == null) {
			usedTemp = true;

			var pos = getPosition(alpha);
			var size = getSize(alpha);
			x = createPrimitive("temp stock xyz", "Stock", [pos[0] + size[0] / 2 - 5, pos[1] + 120 + size[1]], [10, 10]);

			omega = x;
		}

		var edge = graph.insertEdge(parent, null, primitiveBank[t].cloneNode(true), alpha, omega, t);
	}




	setName(edge, name);

	if (usedTemp) {
		removePrimitive(x);
	}


	return edge;
}


/*
Method: removePrimitive

Removes a primitive from the model. You should not attempt to access or modify a primitive once it has been removed.

Parameters:

primitive - The primitive to delete, can also be an array of primitives.

See also:

<createPrimitive>, <createConnector>

*/

function removePrimitive(primitive) {
	if (!(primitive instanceof Array)) {
		primitive = [primitive];
	}


	if (graph instanceof SimpleNode) {

		var connectors = findType(["Flow", "Transition", "Link"]);
		primitive.forEach(function (x) {
			x.parent.children.splice(x.parent.children.indexOf(x), 1);
			connectors.forEach(function (c) {
				if (c.source == x) {
					c.source = null;
					if (c.target && c.target.parent !== c.parent) {
						setParent(c, c.target.parent);
					}
				}
				if (c.target == x) {
					c.target = null;
					if (c.source && c.source.parent !== c.parent) {
						setParent(c, c.source.parent);
					}
				}
			})
		});
		clearPrimitiveCache();
	} else {
		graph.removeCells(primitive, false);
	}

}

/*

Group: Primitive Selections

*/


/*
Method: highlight

Highlights a single primitive. Selects the primitive, expands any collapsed folders the primitive is in, and scrolls to the position of the primitive.

Parameters:

primitive - The primitive to highlight.

*/

function highlight(primitive) {
	var folder = getParent(primitive);
	while (folder) {
		if (getCollapsed(folder)) {
			expandFolder(folder);
		}
		folder = getParent(folder);
	}

	setSelected(primitive);
	graph.scrollCellToVisible(primitive);
}


/*
Method: getSelected

Finds and returns the currently selected primitives.

Return:

An array of the selected primitives.

See also:

<setSelected>, <isSelected>
*/

function getSelected() {
	return graph.getSelectionCells();
}

/*
Method: setSelected

Sets the currently selected primitives.

Parameters:

primitives - An array of primitives to select. Can also be a single primitive.

See also:

<getSelected>, <isSelected>

*/

function setSelected(primitives) {
	graph.allowButtonSelect = true;
	if (primitives instanceof Array) {
		graph.setSelectionCells(primitives);
	} else {
		graph.setSelectionCells([primitives]);
	}
	graph.allowButtonSelect = false;
}

/*
Method: isSelected

Indicates whether a primitive is selected.

Parameters:

primitive - A primitive to return the selection status for. May also be an array of primitives.

Return:

Whether the primitive is selected or not as a boolean. If an array of primitives was passed to the function, an array of booleans is returned.

See also:

<getSelected>, <setSelected>

*/

function isSelected(primitive) {
	var selected = getSelected();
	return map(primitive, function (primitive) {
		return (primitiveIndex(selected, primitive) > -1);
	});
}



/*

Group: General Primitive Functions

*/

/*
Method: getID

Gets the ID of the passed primitive. The ID remains constant even if the name of a primitive changes. The ID is a string.

Parameters:

primitive - The primitive for which the ID is requested. May also be an array of primitives.

Return:

The ID of the primitive as a string. If an array of primitives was passed, returns an array of IDs.

See also:

<findID>
*/



function getID(primitive) {
	return map(primitive, function (primitive) {
		return primitive.id;
	});
}

/*
Method: getType

Gets the type of the passed primitive.

Parameters:

primitive - The primitive for which the type is requested. May also be an array of primitives.

Return:

The type of the primitive as a string. If an array of primitives was passed, returns an array of IDs.

*/



function getType(primitive) {
	return map(primitive, function (primitive) {
		return primitive.value.nodeName;
	});
}



/*
Method: getName

Gets the name of the passed primitive.

Parameters:

primitive - The primitive for which the name is requested. May also be an array of primitives.

Return:

The name of the primitive as a string. If an array of primitives was passed, returns an array of names.

See also:

<setName>
*/

function getName(primitive) {
	return map(primitive, function (primitive) {
		return primitive.getAttribute("name");
	});
}

/*
Method: setName

Sets the name of the passed primitive.

Parameters:

primitive - The primitive for which the name will be set. May also be an array of primitives in which case they will all be set to the same name.
name - The new name for the primitive.

See also:

<getName>
*/

function setName(primitive, name) {

	map(primitive, function (primitive) {
		if (validPrimitiveName(String(name), primitive)) {
			setAttributeUndoable(primitive, "name", String(name));
			propagateGhosts(primitive);
		}
	});

}

/*
Method: getUnits

Gets the units of the passed primitive.

Parameters:

primitive - The primitive for which the units are requested. May also be an array of primitives.

Return:

The units of the primitive as a string. If an array of primitives was passed, returns an array of units.

See also:

<setUnits>
*/



function getUnits(primitive) {
	return map(primitive, function (primitive) {
		return primitive.getAttribute("Units");
	});
}

/*
Method: setUnits

Sets the units of the passed primitive.

Parameters:

primitive - The primitive for which the units will be set. May also be an array of primitives in which case they will all be set to the same units.
units - The new units for the primitive.

See also:

<getUnits>
*/


function setUnits(primitive, units) {

	map(primitive, function (primitive) {
		setAttributeUndoable(primitive, "Units", String(units));
	});

}

/*
Method: getConstraints

Gets the upper and lower bounds on the passed primitive to test against during simulation.

Parameters:

primitive - The primitive for which the constraints are requested. May also be an array of primitives.

Return:

The constraints of the primitive as an array. The format is [MinimumConstraint, MinimumConstraintMode, MaximumConstraint, MaximumConstraintMode]. Constraint mode is false to disable the constraint and true to enable it.

See also:

<setConstraints>
*/


function getConstraints(primitive) {
	return map(primitive, function (primitive) {
		return [primitive.getAttribute("MinConstraint"), isTrue(primitive.getAttribute("MinConstraintUsed")), primitive.getAttribute("MaxConstraint"), isTrue(primitive.getAttribute("MaxConstraintUsed"))];
	});
}

/*
Method: setConstraints

Sets the upper and lower bounds on the passed primitive to test against during simulation.

Parameters:

primitive - The primitive for which the units will be set. May also be an array of primitives in which case they will all be set to the same constraints.
constraints - The constraints of the primitive as an array. The format is [MinimumConstraint, MinimumConstraintMode, MaximumConstraint, MaximumConstraintMode]. Constraint mode is false to disable the constraint and true to enable it.


See also:

<getConstraints>
*/


function setConstraints(primitive, constraints) {
	map(primitive, function (primitive) {
		setAttributeUndoable(primitive, "MinConstraint", constraints[0]);
		setAttributeUndoable(primitive, "MinConstraintUsed", constraints[1]);
		setAttributeUndoable(primitive, "MaxConstraint", constraints[2]);
		setAttributeUndoable(primitive, "MaxConstraintUsed", constraints[3]);
	});

}

/*
Method: getNote

Gets the note of the passed primitive.

Parameters:

primitive - The primitive for which the note is requested. May also be an array of primitives.

Return:

The note of the primitive as a string. If an array of primitives was passed, returns an array of notes.

See also:

<setNote>
*/

function getNote(primitive) {
	return map(primitive, function (primitive) {
		return primitive.getAttribute("Note");
	});
}

/*
Method: setNote

Sets the note of the passed primitive.

Parameters:

primitive - The primitive for which the note will be set. May also be an array of primitives in which case they will all be set to the same note.
note - The new note for the primitive.

See also:

<getNote>
*/

function setNote(primitive, note) {

	map(primitive, function (primitive) {
		setAttributeUndoable(primitive, "Note", String(note));
	});

}

/*
Method: showNote

Shows the note for the passed primitive. The note is shown as a closable tooltip next to the primitive. If the note is empty, the note will not be shown.

Parameters:

primitive - The primitive for which the note will be shown. May also be an array of primitives in which case they will all have their notes shown.

See also:

<hideNote>
*/



function showNote(primitive) {
	return map(primitive, function (cell) {
		if (!(cell.value.getAttribute("Note", null) === null || cell.value.getAttribute("Note") == "")) {
			var x = Ext.getCmp("note" + cell.id);
			if (isUndefined(x)) {

				var state = graph.view.getState(cell);
				if (state) {
					var tooltip = new Ext.ToolTip({
						html: "<big>" + clean(cell.value.getAttribute("Note").replace(/\n/g, "<br/>")) + "</big>",
						autoHide: false,
						closable: true,
						width: 300,
						draggable: true,
						id: "note" + cell.id,
						title: clean(cell.value.getAttribute("name")),
						closeAction: "destroy"
					});

					tooltip.showAt([state.x + mxPanel.getEl().getLeft() + state.width + 4 - graph.container.scrollLeft, state.y + mxPanel.getEl().getTop() - graph.container.scrollTop]);
				}

			}
		}
	});
}

/*
Method: hideNote

Hides the note for the passed primitive. The note is shown as a closable tooltip next to the primitive.

Parameters:

primitive - The primitive for which the note will be hidden. May also be an array of primitives in which case they will all have their notes hidden.

See also:

<showNote>
*/



function hideNote(primitive) {
	return map(primitive, function (cell) {
		var x = Ext.getCmp("note" + cell.id);
		if (!isUndefined(x)) {
			x.destroy();
		}
	});
}

/*
Method: showEditor

Shows the value editor for the passed primitive.

Parameters:

primitive - The primitive for which the editor will be shown. 
annotations - An optional array containing a list of annotations. Only valid for primitives with equations.

Example:

> showEditor(primitive, [{type: "error", row: 7, text: "Incorrect syntax"}])

*/


function showEditor(primitive, annotations) {
	if (primitive.value.nodeName == "Converter") {
		var editorWindow = new ConverterWindow({
			parent: "",
			cell: primitive,
			oldKeys: primitive.getAttribute("Data"),
			interpolation: primitive.getAttribute("Interpolation")
		});
		editorWindow.show();
	} else if (primitive.value.nodeName == "Stock") {
		var checkbox = new Ext.form.field.Checkbox({
			xtype: "checkboxfield",
			boxLabel: getText('Restrict this stock to positive values'),
			checked: getNonNegative(primitive),
			autoEl: {
				'data-qtip': "If checked, the value of the stock will not be allowed to fall below zero. The rates of outflows may be adjusted to ensure this condition is met."
			}
		});

		var editorWindow = new EquationWindow({
			parent: "",
			cell: primitive,
			equation: getValue(primitive),
			annotations: annotations,
			extra: checkbox,
			saveExtra: function (extra) {
				setNonNegative(primitive, checkbox.getValue())
			}
		});
		editorWindow.show();
	} else if (primitive.value.nodeName == "Flow") {
		var checkbox = new Ext.form.field.Checkbox({
			xtype: "checkboxfield",
			boxLabel: getText('Restrict this flow to positive rates'),
			checked: getNonNegative(primitive),
			autoEl: {
				'data-qtip': "If checked, the flow will not be applied if the calculated rate is less than zero."
			}
		});

		var editorWindow = new EquationWindow({
			parent: "",
			cell: primitive,
			equation: getValue(primitive),
			annotations: annotations,
			extra: checkbox,
			saveExtra: function (extra) {
				setNonNegative(primitive, checkbox.getValue());
			}
		});
		editorWindow.show();
	} else if (primitive.value.nodeName == "Transition") {
		var testVisibility = function () {
			var cond = trigger.getValue() == "Condition";
			recalculate.setDisabled(cond);
			repeat.setDisabled(cond);
		}

		var trigger = new Ext.form.ComboBox({
			triggerAction: "all",
			store: ['Timeout', 'Probability', 'Condition'],
			editable: false,
			selectOnFocus: false,
			value: getTriggerType(primitive),
			fieldLabel: 'Trigger Type',
			width: 240,
			listeners: {
				change: function () {
					testVisibility();
				}
			}
		});

		var recalculate = new Ext.form.field.Checkbox({
			xtype: "checkboxfield",
			boxLabel: getText('Recalculate each time step'),
			checked: getTriggerRecalculate(primitive),
			margin: '0 0 0 15',
			autoEl: {
				'data-qtip': "If this is not true, the equation will be evaluated once and the trigger time scheduled based on that calculation. If this is true, the timeout or probability will be recalculated as the state of the system changes."
			}
		});

		var repeat = new Ext.form.field.Checkbox({
			xtype: "checkboxfield",
			boxLabel: getText('Repeat after triggering'),
			checked: getTriggerRepeat(primitive),
			margin: '0 0 0 15',
			autoEl: {
				'data-qtip': "If this is true, the transition will be rescheduled after it is triggered. If this is not true, the transition will only be rescheduled if its source state becomes active again."
			}
		});

		var items = {
			xtype: 'container',
			layout: 'hbox',
			items: [trigger, recalculate, repeat]
		}

		testVisibility();

		var editorWindow = new EquationWindow({
			parent: "",
			cell: primitive,
			equation: getValue(primitive),
			annotations: annotations,
			extra: items,
			saveExtra: function (extra) {
				setTriggerType(primitive, trigger.value);
				setTriggerRecalculate(primitive, recalculate.getValue());
				setTriggerRepeat(primitive, repeat.getValue());
			}
		});
		editorWindow.show();
	} else {
		var editorWindow = new EquationWindow({
			parent: "",
			cell: primitive,
			equation: getValue(primitive),
			annotations: annotations
		});
		editorWindow.show();
	}
}

/*
Method: getValue

Gets the value of the passed primitive. The value depends on the type of the primitive. For instance, the value of stock is its initial value while the value of a flow is its rate.

Parameters:

primitive - The primitive for which the value is requested. May also be an array of primitives.

Return:

The value of the primitive as a string. If an array of primitives was passed, returns an array of values.

See also:

<setValue>
*/



function getValue(primitive) {
	return map(primitive, function (primitive) {
		var n = primitive.value.nodeName;
		var v;
		if (n == "Stock") {
			v = primitive.getAttribute("InitialValue");
		} else if (n == "Flow") {
			v = primitive.getAttribute("FlowRate");
		} else if (n == "Transition") {
			v = primitive.getAttribute("Value");
		} else if (n == "State") {
			v = primitive.getAttribute("Active");
		} else if (n == "Variable") {
			v = primitive.getAttribute("Equation");
		} else if (n == "Button") {
			v = primitive.getAttribute("Function");
		} else if (n == "Converter") {
			v = primitive.getAttribute("Data");
		} else if (n == "Action") {
			v = primitive.getAttribute("Action");
		} else if (n == "Agents") {
			v = primitive.getAttribute("Size");
		}
		if (isDefined(v)) {
			return v;
		} else {
			return "";
		}
	});
}

/*
Method: setValue

Sets the value of the passed primitive. The value depends on the type of the primitive. For instance, the value of stock is its initial value while the value of a flow is its rate.

Parameters:

primitive - The primitive for which the value will be set. May also be an array of primitives in which case they will all be set to the same value.
value - The new value for the primitive. Can be a number or a string.

See also:

<getValue>
*/


function setValue(primitive, value) {

	map(primitive, function (primitive) {
		if (getValue(primitive) != value) {
			var n = primitive.value.nodeName;
			if (n == "Stock") {
				setAttributeUndoable(primitive, "InitialValue", String(value));
			} else if (n == "Flow") {
				setAttributeUndoable(primitive, "FlowRate", String(value));
			} else if (n == "Transition") {
				setAttributeUndoable(primitive, "Value", String(value));
			} else if (n == "State") {
				setAttributeUndoable(primitive, "Active", String(value));
			} else if (n == "Variable") {
				setAttributeUndoable(primitive, "Equation", String(value));
			} else if (n == "Button") {
				setAttributeUndoable(primitive, "Function", String(value));
			} else if (n == "Converter") {
				setAttributeUndoable(primitive, "Data", String(value));
			} else if (n == "Action") {
				setAttributeUndoable(primitive, "Action", String(value));
			} else if (n == "Agents") {
				if (value < 0 || Math.round(value) != value) {
					alert("The agent population size must be a non-negative integer.");
					return;
				}
				setAttributeUndoable(primitive, "Size", parseFloat(value));
			}


		}
	});

}

/*
Method: getSize

Gets the size of the passed primitive.

Parameters:

primitive - The primitive for which the position is requested. May also be an array of primitives.

Return:

The size as an array of the form: [width, height].

*/



function getSize(primitive) {
	return map(primitive, function (primitive) {
		if (graph instanceof SimpleNode) {
			return [0, 0];
		}
		var size = graph.getCellBounds(primitive);
		var scale = graph.view.getScale();

		return [size.width / scale, size.height / scale];
	});
}


/*
Method: getPosition

Gets the position of the passed primitive.

Parameters:

primitive - The primitive for which the position is requested. May also be an array of primitives.

Return:

The position as an array of the form [x, y]. The position is measured from the top-left corner of the graph.

See also:

<setPosition>
*/



function getPosition(primitive) {
	return map(primitive, function (primitive) {
		if (graph instanceof SimpleNode) {
			return [0, 0];
		}
		var state = graph.view.getState(primitive);
		var scale = graph.view.getScale();

		return [state.x / scale, state.y / scale];
	});
}

/*
Method: setPosition

Sets the position of the passed primitive.

Parameters:

primitive - The primitive for which the position will be set. May also be an array of primitives in which case they will all be set to the same position.
position - The new position for the primitive in the form [x, y]. The position is measured from the top-left corner of the graph.

See also:

<getPosition>
*/


function setPosition(primitive, position) {

	map(primitive, function (primitive) {
		var state = graph.view.getState(primitive);

		var scale = graph.view.getScale();

		var geo = primitive.geometry;

		var dx = state.x / scale - geo.x;
		var dy = state.y / scale - geo.y;

		var res = geo.clone();

		res.x = position[0] - dx;
		res.y = position[1] - dy;

		graph.getModel().setGeometry(primitive, res);
	});

}

/*

Group: Primitive Styling Functions

*/

/*
Method: flash

Temporarily changes the opacity of a primitive. Opacity between 0 (invisible) to 100 (fully opaque).

Parameters:

primitive - The primitive which will be flashed. May also be an array of primitives.
opacity - Optional temporary opacity for the primitive. Defaults to 0.
duration - Optional duration the primitive will be at the temporary opacity in milliseconds. Defaults to 100.

Example:

> flash(getSelected());

*/

function flash(primitive, opacity, duration) {
	map(primitive, function (primitive) {
		if (primitive.value.nodeName == "Folder") {
			flash(getChildren(primitive, false), opacity, duration);
		}
		var orig = getOpacity(primitive);
		setOpacity(primitive, opacity || 0);
		setTimeout(function () {
			setOpacity(primitive, orig);
		}, duration || 100);
	})
}

/*
Method: getShowSlider

Gets the show slider property of the passed primitive.

Parameters:

primitive - The primitive for which the show slider property will be returned. May also be an array of primitives.

Return:

Whether to show the slider property of the primitive. A boolean.

*/

function getShowSlider(primitive) {
	return map(primitive, function (primitive) {
		return isTrue(primitive.getAttribute("ShowSlider"));
	});

}

/*
Method: setShowSlider

Sets the show slider property of the passed primitive. 

Parameters:

primitive - The primitive for which the show slider property will be set. May also be an array of primitives in which case they will all be set to the same show slider value.
showSlider - Boolean whether to show the slider.

*/

function setShowSlider(primitive, showSlider) {

	map(primitive, function (primitive) {
		setAttributeUndoable(primitive, "ShowSlider", showSlider);
	});

}

/*
Method: getSliderMin

Gets the slider min property of the passed primitive.

Parameters:

primitive - The primitive for which the slider min property will be returned. May also be an array of primitives.

Return:

The minimum allowed value for the slider

*/

function getSliderMin(primitive) {
	return map(primitive, function (primitive) {
		return primitive.getAttribute("SliderMin");
	});

}

/*
Method: setSliderMin

Sets the slider min property of the passed primitive. 

Parameters:

primitive - The primitive for which the slider property will be set. May also be an array of primitives in which case they will all be set to the same slider value.
sliderMin - The minimum value of the slider.

*/

function setSliderMin(primitive, sliderMin) {

	map(primitive, function (primitive) {
		setAttributeUndoable(primitive, "SliderMin", sliderMin);
	});

}

/*
Method: getSliderMax

Gets the slider max property of the passed primitive.

Parameters:

primitive - The primitive for which the slider max property will be returned. May also be an array of primitives.

Return:

The maximum allowed value for the slider

*/

function getSliderMax(primitive) {
	return map(primitive, function (primitive) {
		return primitive.getAttribute("SliderMax");
	});

}

/*
Method: setSliderMax

Sets the slider max property of the passed primitive. 

Parameters:

primitive - The primitive for which the slider property will be set. May also be an array of primitives in which case they will all be set to the same slider value.
sliderMax - The maximum value of the slider.

*/

function setSliderMax(primitive, sliderMax) {

	map(primitive, function (primitive) {
		setAttributeUndoable(primitive, "SliderMax", sliderMax);
	});

}

/*
Method: getSliderStep

Gets the slider step property of the passed primitive.

Parameters:

primitive - The primitive for which the slider property will be returned. May also be an array of primitives.

Return:

The step value for the slider

*/

function getSliderStep(primitive) {
	return map(primitive, function (primitive) {
		return primitive.getAttribute("SliderStep");
	});

}

/*
Method: setSliderStep

Sets the slider step property of the passed primitive. 

Parameters:

primitive - The primitive for which the slider property will be set. May also be an array of primitives in which case they will all be set to the same slider value.
sliderStep - The step value of the slider.

*/

function setSliderStep(primitive, sliderStep) {

	map(primitive, function (primitive) {
		setAttributeUndoable(primitive, "SliderStep", sliderStep);
	});

}


/*
Method: getOpacity

Gets the opacity of the passed primitive. Opacity is a value between 0 (invisible) to 100 (fully opaque).

Parameters:

primitive - The primitive for which the opacity will be returned. May also be an array of primitives.

Return:

The opacity of the primitive

*/

function getOpacity(primitive) {
	return map(primitive, function (primitive) {
		return graph.getCellStyle(primitive).opacity;
	});

}

/*
Method: setOpacity

Sets the opacity of the passed primitive. Opacity is a value between 0 (invisible) to 100 (fully opaque).

Parameters:

primitive - The primitive for which the opacity will be set. May also be an array of primitives in which case they will all be set to the same opacity.
opacity - The new opacity for the primitive.

*/

function setOpacity(primitive, opacity) {

	map(primitive, function (primitive) {
		var style = primitive.getStyle();
		style = mxUtils.setStyle(style, "opacity", opacity);
		style = mxUtils.setStyle(style, mxConstants.STYLE_TEXT_OPACITY, opacity);

		graph.getModel().execute(new mxStyleChange(graph.getModel(),
			primitive,
			style));

		propagateGhosts(primitive);

	});

}


/*
Method: getLineColor

Gets the line color of the passed primitive.

Parameters:

primitive - The primitive for which the line color will be returned. May also be an array of primitives.

Return:

The line color of the primitive

*/

function getLineColor(primitive) {
	return map(primitive, function (primitive) {
		return graph.getCellStyle(primitive).strokeColor;
	});
}

/*
Method: setLineColor

Sets the line color of the passed primitive.

Parameters:

primitive - The primitive for which the line color will be set. May also be an array of primitives in which case they will all be set to the same color.
lineColor - The new line color for the primitive.

*/

function setLineColor(primitive, lineColor) {

	map(primitive, function (primitive) {
		var style = primitive.getStyle();
		style = mxUtils.setStyle(style, "strokeColor", lineColor);

		graph.getModel().execute(new mxStyleChange(graph.getModel(),
			primitive,
			style));

		propagateGhosts(primitive);

	});

}

/*
Method: getFontColor

Gets the font color of the passed primitive.

Parameters:

primitive - The primitive for which the font color will be returned. May also be an array of primitives.

Return:

The font color of the primitive

*/

function getFontColor(primitive) {
	return map(primitive, function (primitive) {
		return graph.getCellStyle(primitive).fontColor;
	});

}

/*
Method: setFontColor

Sets the font color of the passed primitive.

Parameters:

primitive - The primitive for which the font color will be set. May also be an array of primitives in which case they will all be set to the same color.
fontColor - The new font color for the primitive.

*/

function setFontColor(primitive, fontColor) {

	map(primitive, function (primitive) {
		var style = primitive.getStyle();
		style = mxUtils.setStyle(style, "fontColor", fontColor);

		graph.getModel().execute(new mxStyleChange(graph.getModel(),
			primitive,
			style));

		propagateGhosts(primitive);

	});

}

/*
Method: getFillColor

Gets the fill color of the passed primitive.

Parameters:

primitive - The primitive for which the fill color will be returned. May also be an array of primitives.

Return:

The fill color of the primitive

*/

function getFillColor(primitive) {
	return map(primitive, function (primitive) {
		return graph.getCellStyle(primitive).fillColor;
	});

}

/*
Method: setFillColor

Sets the fill color of the passed primitive.

Parameters:

primitive - The primitive for which the fill color will be set. May also be an array of primitives in which case they will all be set to the same color.
fillColor - The new fill color for the primitive.

*/

function setFillColor(primitive, fillColor) {

	map(primitive, function (primitive) {
		var style = primitive.getStyle();
		style = mxUtils.setStyle(style, "fillColor", fillColor);

		graph.getModel().execute(new mxStyleChange(graph.getModel(),
			primitive,
			style));

		propagateGhosts(primitive);

	});

}


/*
Method: getImage

Gets the image of the passed primitive.

Parameters:

primitive - The primitive for which the image will be returned. May also be an array of primitives.

Return:

The image of the primitive as a string

*/

function getImage(primitive) {
	return map(primitive, function (primitive) {
		return primitive.getAttribute("Image");
	});

}

/*
Method: setImage

Sets the image of the passed primitive.

Parameters:

primitive - The primitive for which the image will be set. May also be an array of primitives in which case they will all be set to the same image.
image - The image url or alias as a string.

*/

function setImage(primitive, image) {

	map(primitive, function (primitive) {
		primitive.setAttribute("Image", image);
		setPicture(primitive);
	});

}

/*

Group: Stocks

*/

/*
Method: getNonNegative

Gets the non-negative property of stocks (also applicable to flows). A non-negative stock will never become negative.

Parameters:

primitive - The stock for which the value is requested. May also be an array of stock.

Return:

The non-negative value of the stock. If an array of primitives was passed, returns an array of values.

See also:

<setNonNegative>
*/


function getNonNegative(primitive) {
	return map(primitive, function (primitive) {
		if (primitive.value.nodeName == "Stock") {
			return isTrue(primitive.getAttribute("NonNegative"));
		} else {
			return isTrue(primitive.getAttribute("OnlyPositive"));
		}
	});
}

/*
Method: setNonNegative

Sets the non-negative value of the passed stocks (also applicable to flows).

Parameters:

primitive - The stock for which the non-negative value will be set. May also be an array of stocks in which case they will all be set to the same value.
nonNegative - The new non-negative status for the stock. Either true or false.

See also:

<getNonNegative>
*/


function setNonNegative(primitive, nonNegative) {
	map(primitive, function (primitive) {
		if (primitive.value.nodeName == "Stock") {
			setAttributeUndoable(primitive, "NonNegative", nonNegative);
		} else {
			setAttributeUndoable(primitive, "OnlyPositive", nonNegative);
			if (!(primitive instanceof SimpleNode)) {
				if (nonNegative) {
					graph.setCellStyles(mxConstants.STYLE_STARTARROW, "", [primitive]);
				} else {
					graph.setCellStyles(mxConstants.STYLE_STARTARROW, "block", [primitive]);
					graph.setCellStyles("startFill", 0, [primitive]);
				}
			}


		}
	});
}

/*
Method: getStockType

Gets the type of the stock. The type affects the behavior of the stock and may either be "Store" (the default) or "Conveyor".

Parameters:

primitive - The stock for which the type is requested. May also be an array of stocks.

Return:

The type of the stock as a string. If an array of stocks was passed, returns an array of strings.

See also:

<setStockType>
*/

function getStockType(primitive) {
	return map(primitive, function (primitive) {
		return primitive.getAttribute("StockMode");
	});
}

/*
Method: setStockType

Sets the type of the passed stock.

Parameters:

primitive - The stock for which the type will be set. May also be an array of stocks in which case they will all be set to the same type.
type - The type of the stock as a string. Either "Store" (the default) or "Conveyor".

See also:

<getStockType>
*/

function setStockType(primitive, type) {
	map(primitive, function (primitive) {
		setAttributeUndoable(primitive, "StockMode", type);
	});
}


/*
Method: getDelay

Gets the delay length of conveyor stocks.

Parameters:

primitive - The stock for which the value is requested. May also be an array of stocks.

Return:

The delay length of the stock. If an array of stocks was passed, returns an array of lengths.

See also:

<setDelay>
*/

function getDelay(primitive) {
	return map(primitive, function (primitive) {
		return primitive.getAttribute("Delay");
	});
}

/*
Method: setDelay

Sets the delay length of the passed conveyor stock.

Parameters:

primitive - The stock for which the delay length will be set. May also be an array of stocks in which case they will all be set to the same value.
delay - The delay length for the stock.

See also:

<getDelay>
*/

function setDelay(primitive, delay) {
	map(primitive, function (primitive) {
		setAttributeUndoable(primitive, "Delay", delay);
	});

}

/* 

Group: Connectors

See <getNonNegative> and <setNonNegative> for setting the only-positive property of flows.

*/

/*
Method: getEnds

Gets the alpha and omega for the connector

Parameters:

connector - The connector for which the ends are requested. Can also be an array of connectors.

Return:

The alpha and omega as an array: [alpha, omega]. Array elements are returned as null if no connection exists.

See also:

<setEnds>
*/

function getEnds(connector) {
	return map(connector, function (primitive) {
		return [primitive.source, primitive.target];
	});
}

/*
Method: setEnds

Sets the alpha and omega for a connector.

Parameters:

connector - The connector for which the alpha and omega will be set. May also be an array of connectors.
ends - The new alpha and omega for the connector as an array: [alpha, omega]. Use null for either alpha or omega to disconnect an end.

See also:

<getEnds>
*/

function setEnds(connector, ends) {
	map(connector, function (primitive) {
		if (!(connector instanceof SimpleNode)) {
			var edit = new mxTerminalChange(graph.model, primitive, ends[0], true);
			graph.getModel().execute(edit);
			edit = new mxTerminalChange(graph.model, primitive, ends[1], false);
			graph.getModel().execute(edit);
		} else {
			primitive.source = ends[0];
			primitive.target = ends[1];
			clearPrimitiveCache();
		}

	});
}

/*
Method: connected

Determines two primitives are connected by a link, flow, or transition. Alternatively if one of the primitives is a connector, checks if it connects directly to the other primitive.

Parameters:

primitive1 - A primitive.
primitive2 - A primitive to test whether it is connected to primitive1.

Return:

A boolean. True if the primitives are connected, false otherwise.
*/

function connected(primitive1, primitive2) {
	if (primitive1.isEdge) {
		if (primitive1.source !== null && primitive1.source.id === primitive2.id) {
			return true;
		} else if (primitive1.target !== null && primitive1.target.id === primitive2.id) {
			return true;
		}
	}
	if (primitive2.isEdge) {
		if (primitive2.source !== null && primitive2.source.id === primitive1.id) {
			return true;
		} else if (primitive2.target !== null && primitive2.target.id === primitive1.id) {
			return true;
		}
	}
	var items = findType(["Flow", "Link", "Transition"]);
	for (var i = 0; i < items.length; i++) {
		if (items[i].source !== null && items[i].target !== null) {
			if (items[i].source.id === primitive1.id && items[i].target.id === primitive2.id) {
				return true;
			}
			if (items[i].target.id === primitive1.id && items[i].source.id === primitive2.id) {
				return true;
			}
		}
	}
	return false;
}

/* 

Group: States

*/


/*
Method: getResidency

Gets the residency property of a state primitive.

Parameters:

state - The state for which the residency property is requested. May also be an array of states.

Return:

The residency property as a string.

See also:

<setResidency>
*/

function getResidency(state) {
	return map(state, function (state) {
		return state.getAttribute("Residency");
	});
}

/*
Method: setResidency

Sets the residency property of a state primitive.

Parameters:

state - The state primitive for which the residency property will be set. May also be an array of states.
residency - The new value for the residency property.

See also:

<getResidency>
*/

function setResidency(state, residency) {
	map(state, function (primitive) {
		setAttributeUndoable(primitive, "Residency", residency);
	});
}

/* 

Group: Transitions and Actions

*/

/*
Method: getTriggerType

Gets the trigger type of a transition or action.

Parameters:

primitive - The transition or action for which the trigger is requested. May also be an array of transitions or actions.

Return:

The trigger mode as a string. May be "Timeout", "Probability" or "Condition".

See also:

<setTriggerType>
*/

function getTriggerType(primitive) {
	return map(primitive, function (primitive) {
		return primitive.getAttribute("Trigger");
	});
}

/*
Method: setTriggerType

Sets the trigger type for a transition or action.

Parameters:

primitive - The transition or action for which the trigger will be set. May also be an array of transitions or actions.
trigger - The new trigger for the transition or action. May be "Timeout" "Probability" or "Condition".

See also:

<getTriggerType>
*/

function setTriggerType(primitive, trigger) {
	map(primitive, function (primitive) {
		setAttributeUndoable(primitive, "Trigger", trigger);
	});
}

/*
Method: getTriggerValue

Gets the trigger value equation of a transition or action.

Parameters:

primitive - The transition or action for which the trigger value equation is requested. May also be an array of transitions or actions.

Return:

The trigger value equation as a string.

See also:

<setTriggerValue>
*/

function getTriggerValue(primitive) {
	return map(primitive, function (primitive) {
		return primitive.getAttribute("Value");
	});
}

/*
Method: setTriggerValue

Sets the trigger value for a transition or action.

Parameters:

primitive - The transition or action for which the trigger will be set. May also be an array of transitions or actions.
value - The new trigger value equation as a string.

See also:

<getTriggerValue>
*/

function setTriggerValue(primitive, value) {
	map(primitive, function (primitive) {
		setAttributeUndoable(primitive, "Value", value);
	});
}

/*
Method: getTriggerRepeat

Gets the trigger Repeat property of a transition or action.

Parameters:

primitive - The transition or action for which the property is requested. May also be an array of transitions or actions.

Return:

The trigger Repeat property as a boolean.

See also:

<setTriggerRepeat>
*/

function getTriggerRepeat(primitive) {
	return map(primitive, function (primitive) {
		return isTrue(primitive.getAttribute("Repeat"));
	});
}

/*
Method: setTriggerRepeat

Sets the trigger Repeat property for a transition or action.

Parameters:

primitive - The transition or action for which the Repeat property will be set. May also be an array of transitions or actions.
repeat - A boolean determining whether to repeat the trigger

See also:

<getTriggerRepeat>
*/

function setTriggerRepeat(primitive, repeat) {
	map(primitive, function (primitive) {
		setAttributeUndoable(primitive, "Repeat", repeat);
	});
}

/*
Method: getTriggerRecalculate

Gets the trigger Recalculate property of a transition or action.

Parameters:

primitive - The transition or action for which the property is requested. May also be an array of transitions or actions.

Return:

The trigger Recalculate property as a boolean.

See also:

<setTriggerRecalculate>
*/

function getTriggerRecalculate(primitive) {
	return map(primitive, function (primitive) {
		return isTrue(primitive.getAttribute("Recalculate"));
	});
}

/*
Method: setTriggerRecalculate

Sets the trigger Recalculate property for a transition or action.

Parameters:

primitive - The transition or action for which the Recalculate property will be set. May also be an array of transitions or actions.
recalculate - A boolean determining whether to recalculate each time step

See also:

<getTriggerRecalculate>
*/

function setTriggerRecalculate(primitive, recalculate) {
	map(primitive, function (primitive) {
		setAttributeUndoable(primitive, "Recalculate", recalculate);
	});
}

/* 

Group: Converters

*/

/*
Method: getData

Gets the data of a converter.

Parameters:

converter - The converter for which the data is requested. May also be an array of Converters.

Return:

The Converter data as a string. A set of input/output pairs separated by semicolons. Example data form: "1,1;2,4;3,9"

See also:

<setData>
*/

function getData(converter) {
	return map(converter, function (primitive) {
		return primitive.getAttribute("Data");
	});
}

/*
Method: setData

Sets the data of a converter.

Parameters:

converter - The converter for which the data will be set. May also be an array of Converters in which case they will all be set to the same value.
data - The data for the converter as a string. A set of input/output pairs separated by semicolons. Example data form: "1,1;2,4;3,9"

See also:

<getData>
*/

function setData(converter, data) {
	map(converter, function (primitive) {
		setAttributeUndoable(primitive, "Data", data);
	});
}


/*
Method: getConverterInput

Gets the input source of a converter.

Parameters:

converter - The converter for which the input source is requested. May also be an array of Converters.

Return:

The input source. If the input source is a primitive, returns the primitive. Otherwise returns null (indicating the use of time as the input source).

See also:

<setInputSource>
*/

function getConverterInput(converter) {
	return map(converter, function (primitive) {
		var x = primitive.getAttribute("Source");
		if (x == "Time") {
			return null;
		} else {
			return findID(x);
		}
	});
}

/*
Method: setConverterInput

Sets the input source of a converter.

Parameters:

converter - The converter for which the input source will be set. May also be an array of Converters in which case they will all be set to the same value.
input - The input source. Pass either a primitive or use null to indicate the usage of time as the input.

See also:

<getConverterInput>
*/

function setConverterInput(converter, input) {
	map(converter, function (primitive) {
		if (input == null) {
			setAttributeUndoable(primitive, "Source", "Time");
		} else {
			setAttributeUndoable(primitive, "Source", input.id);
		}
	});
}


/*
Method: getInterpolation

Gets the interpolation mode of a converter.

Parameters:

converter - The converter for which the interpolation is requested. May also be an array of Converters.

Return:

The interpolation mode as a string. May be "Linear" or "Discrete".

See also:

<setInterpolation>
*/

function getInterpolation(converter) {
	return map(converter, function (primitive) {
		return primitive.getAttribute("Interpolation");
	});
}

/*
Method: setInterpolation

Sets the interpolation mode of a converter.

Parameters:

converter - The converter for which the interpolation will be set. May also be an array of Converters in which case they will all be set to the same value.
interpolation - The interpolation mode for the converter as a string. May either be "Linear" or "Discrete".

See also:

<getInterpolation>
*/

function setInterpolation(converter, interpolation) {
	map(converter, function (primitive) {
		setAttributeUndoable(primitive, "Interpolation", interpolation);
	});
}


/* 

Group: Buttons

*/

/*
Method: pressButton

Simulates a press of the passed button(s) firing its action. Can be useful for chaining together methods.

Parameter:

button - The button to be pressed. Can also be an array of buttons.

*/



function pressButton(button) {
	"use strict";

	graph.getModel().beginUpdate();

	map(button, function (primitive) {
		runAction(primitive.getAttribute("Function"), '<p>There was an error with the Action for the button <i>' + primitive.getAttribute("name") + '</i>.</p><br/>', primitive);

	});

	graph.getModel().endUpdate();

}

var trusted = is_owner;
function runAction(code, errHeader, button) {
	try {
		var msg = 'This insight is requesting permission to execute custom code. For security reasons, you should only run custom code in trusted insights.\n\nAre you sure you want to run code in this insight?';
		if (trusted || confirm(msg)) {
			if (!trusted) {
				sendToParent({
					type: 'start_action'
				});
			}
			trusted = true;
			eval("\"use strict;\"\n\n" + code);
		}
	} catch (err) {
		errHeader = errHeader || '';
		Ext.Msg.show({
			title: getText('Action Error'),
			msg: errHeader + '<p><tt>' + err + "</tt></p><p><b>Code:</b></p><p><tt><pre>" + code + "</pre></tt></p>",
			buttons: Ext.Msg.OK,
			icon: Ext.Msg.ERROR
		});

		if (button) {
			setTimeout(function () {
				highlight(button);
			}, 100)
		}
	}
}



/*

Group: Agents

*/


/*
Method: getPopulationSize

Gets the size of the agent population.

Parameters:

agents - The agent population for which the size will be returned. May also be an array of agent populations.

Return:

The population size.

See also:

<setPopulationSize>
*/

function getPopulationSize(agents) {
	return map(agents, function (primitive) {
		return primitive.getAttribute("Size");
	});
}

/*
Method: setPopulationSize

Sets the size of the agent population.

Parameters:

agents - The agent population for which the size will be set. May also be an array of agent populations.
size - The new population size.

See also:

<getPopulationSize>
*/

function setPopulationSize(agents, size) {
	map(agents, function (primitive) {
		setAttributeUndoable(primitive, "Size", size);
	});
}

/*
Method: getAgentBase

Gets the base agent for the population.

Parameters:

agents - The agent population for which the base agent will be returned. May also be an array of agent populations.

Return:

The base agent folder.

See also:

<setAgentBase>
*/

function getAgentBase(agents) {
	return map(agents, function (primitive) {
		return findID(primitive.getAttribute("Agent"));
	});
}

/*
Method: setAgentBase

Sets the base agent for the population.

Parameters:

agents - The agent population for which the base agent will be set. May also be an array of agent populations.
folder - The base agent folder. The type for this folder should be set to "Agent".

See also:

<getAgentBase>
*/

function setAgentBase(agents, folder) {
	map(agents, function (primitive) {
		setAttributeUndoable(primitive, "Agent", folder.id);
	});
}


/*
Method: getGeometryWrap

Whether the geometry should wrap across edges.

Parameters:

agents - The agent population for which the geometry wrap property will be returned. May also be an array of agent populations.

Return:

The wrap property as a boolean

See also:

<setGeometryWrap>
*/

function getGeometryWrap(agents) {
	return map(agents, function (primitive) {
		return isTrue(primitive.getAttribute("GeoWrap"));
	});
}

/*
Method: setGeometryWrap

Sets the wrap property for the population area geometry.

Parameters:

agents - The agent population for which geometry wrap property will be set. May also be an array of agent populations.
wrap - The wrap property for the geometry.

See also:

<getGeometryWrap>
*/

function setGeometryWrap(agents, wrap) {
	map(agents, function (primitive) {
		setAttributeUndoable(primitive, "GeoWrap", wrap);
	});
}

/*
Method: getGeometryUnits

Gets the units for the population area geometry.

Parameters:

agents - The agent population for which the units will be returned. May also be an array of agent populations.

Return:

The units as a string

See also:

<setGeometryUnits>
*/

function getGeometryUnits(agents) {
	return map(agents, function (primitive) {
		return primitive.getAttribute("GeoDimUnits");
	});
}

/*
Method: setGeometryUnits

Sets the units for the population area geometry.

Parameters:

agents - The agent population for which geometry units will be set. May also be an array of agent populations.
units - The units as a string.

See also:

<getGeometryUnits>
*/

function setGeometryUnits(agents, units) {
	map(agents, function (primitive) {
		setAttributeUndoable(primitive, "GeoDimUnits", units);
	});
}

/*
Method: getGeometryWidth

Gets the width for the population area geometry.

Parameters:

agents - The agent population for which the width will be returned. May also be an array of agent populations.

Return:

The width of the geometry

See also:

<setGeometryWidth>
*/

function getGeometryWidth(agents) {
	return map(agents, function (primitive) {
		return primitive.getAttribute("GeoWidth");
	});
}

/*
Method: setGeometryWidth

Sets the width for the population area geometry.

Parameters:

agents - The agent population for which geometry width will be set. May also be an array of agent populations.
width - The desired width.

See also:

<getGeometryWidth>
*/

function setGeometryWidth(agents, width) {
	map(agents, function (primitive) {
		setAttributeUndoable(primitive, "GeoWidth", width);
	});
}

/*
Method: getGeometryHeight

Gets the height for the population area geometry.

Parameters:

agents - The agent population for which the height will be returned. May also be an array of agent populations.

Return:

The height of the geometry

See also:

<setGeometryHeight>
*/

function getGeometryHeight(agents) {
	return map(agents, function (primitive) {
		return primitive.getAttribute("GeoHeight");
	});
}

/*
Method: setGeometryHeight

Sets the height for the population area geometry.

Parameters:

agents - The agent population for which geometry height will be set. May also be an array of agent populations.
height - The desired height.

See also:

<getGeometryHeight>
*/

function setGeometryHeight(agents, height) {
	map(agents, function (primitive) {
		setAttributeUndoable(primitive, "GeoHeight", height);
	});
}

/*
Method: getAgentPlacement

The placement method for the agent population.

Parameters:

agents - The agent population for which the placement method will be returned. May also be an array of agent populations.

Return:

The placement method for the agent population. One of "Random", "Network", "Grid" or "Custom Function".

See also:

<setAgentPlacement>
*/

function getAgentPlacement(agents) {
	return map(agents, function (primitive) {
		return primitive.getAttribute("Placement");
	});
}

/*
Method: setAgentPlacement

Sets the placement method for the agent population.

Parameters:

agents - The agent population for which placement method will be set. May also be an array of agent populations.
method - The desired placemennt method. One of "Random", "Network", "Grid" or "Custom Function".

See also:

<getAgentPlacement>
*/

function setAgentPlacement(agents, method) {
	map(agents, function (primitive) {
		setAttributeUndoable(primitive, "Placement", method);
	});
}

/*
Method: getAgentPlacementFunction

A custom placement function for the agent population.

Parameters:

agents - The agent population for which the custom placement function will be returned. May also be an array of agent populations.

Return:

The custom placement function for the agent population.

See also:

<setAgentPlacementFunction>
*/

function getAgentPlacementFunction(agents) {
	return map(agents, function (primitive) {
		return primitive.getAttribute("PlacementFunction");
	});
}

/*
Method: setAgentPlacementFunction

Sets the custom placement function for the agent population. The placement method should be set to "Custom Function" in order for this function to be used.

Parameters:

agents - The agent population for which the custom placement function will be set. May also be an array of agent populations.
func - The desired custom placement function.

See also:

<getAgentPlacementFunction>
*/

function setAgentPlacementFunction(agents, func) {
	map(agents, function (primitive) {
		setAttributeUndoable(primitive, "PlacementFunction", func);
	});
}

/*
Method: getAgentNetwork

The network method for the agent population.

Parameters:

agents - The agent population for which the network method will be returned. May also be an array of agent populations.

Return:

The network method for the agent population. One of "None" or "Custom Function".

See also:

<setAgentNetwork>
*/

function getAgentNetwork(agents) {
	return map(agents, function (primitive) {
		return primitive.getAttribute("Network");
	});
}

/*
Method: setAgentNetwork

Sets the network method for the agent population.

Parameters:

agents - The agent population for which network method will be set. May also be an array of agent populations.
method - The desired placement method. One of "None" or "Custom Function".

See also:

<getAgentNetwork>
*/

function setAgentNetwork(agents, method) {
	map(agents, function (primitive) {
		setAttributeUndoable(primitive, "Network", method);
	});
}

/*
Method: getAgentNetworkFunction

A custom network function for the agent population.

Parameters:

agents - The agent population for which the custom network function will be returned. May also be an array of agent populations.

Return:

The custom network function for the agent population.

See also:

<setAgentNetworkFunction>
*/

function getAgentNetworkFunction(agents) {
	return map(agents, function (primitive) {
		return primitive.getAttribute("NetworkFunction");
	});
}

/*
Method: setAgentNetworkFunction

Sets the custom network function for the agent population. The network method should be set to "Custom Function" in order for this function to be used.

Parameters:

agents - The agent population for which the custom network function will be set. May also be an array of agent populations.
func - The desired custom network function.

See also:

<getAgentNetworkFunction>
*/

function setAgentNetworkFunction(agents, func) {
	map(agents, function (primitive) {
		setAttributeUndoable(primitive, "NetworkFunction", func);
	});
}

/*

Group: Folders

*/

/*
Method: collapseFolder

Collapses a folder or an array of folders.

Parameter:

folder - Either a single folder primitive or an array of folder primitives.

See also:

<expandFolder>, <getCollapsed>

*/

function collapseFolder(folder) {

	map(folder, function (folder) {
		graph.foldCells(true, false, [folder]);
	});

}

/*
Method: expandFolder

Expands a folder or an array of folders.

Parameter:

folder - Either a single folder primitive or an array of folder primitives.

See also:

<collapseFolder>, <getCollapsed>
*/

function expandFolder(folder) {
	map(folder, function (folder) {
		graph.foldCells(false, false, [folder]);
	});
}

/*
Method: getCollapsed

Returns whether or not a given folder is collapsed.

Parameter:

folder - The folder for which the collapsed state is requested.

Return:

True is the folder is collapsed, false if it is expanded.

See also:

<collapseFolder>, <expandFolder>
*/

function getCollapsed(folder) {
	return map(folder, function (f) {
		return f.isCollapsed();
	});
}


/*
Method: getParent

Gets the parent folder for a primitive.

Parameters:

primitive - The primitive for which the parent folder will be returned. May also be an array of primitives.

Return:

The parent folder. Returns null if the primitive is not in a folder.

See also:

<setParent>
*/

function getParent(primitive) {
	var defaultID = "1"; //graph.getDefaultParent().id;
	return map(primitive, function (primitive) {

		var p = primitive.parentNode || primitive.parent;

		if ((p.value && p.value.nodeName == "root") || p.nodeName == "root" || p.id == defaultID) {
			return null;
		} else {
			return p;
		}
	});
}

/*
Method: setParent

Sets the parent folder for a primitive.

Parameters:

primitive - The primitive for which the parent folder will be set. May also be an array of primitives in which case they will all be set to the same parent.
parent - The parent folder primitive. Use null to remove the primitive from all folders.

See also:

<getParent>
*/

function setParent(primitive, parent, preserveLoc) {
	if (graph instanceof SimpleNode) {
		if (parent == null) {
			parent = graph.children[0].children[0];
		}
	} else {
		var p = (parent == null ? graph.getDefaultParent() : parent);
	}
	//console.log(p)
	//console.log(primitive);
	map(primitive, function (primitive) {
		//console.log(primitive.getAttribute("name"));

		if (graph instanceof SimpleNode) {
			primitive.parent.children.splice(primitive.parent.children.indexOf(primitive), 1);
			primitive.parent = parent;
			primitive.parentNode = parent;
			if (!parent.children) {
				parent.children = [];
			}
			parent.children.push(primitive);
		} else {
			var loc = getPosition(primitive);
			var edit = new mxChildChange(graph.getModel(), p, primitive);
			graph.getModel().execute(edit);
			if (!preserveLoc) {
				setPosition(primitive, loc);
			}
		}
	});
}

/*
Method: getFrozen

Gets the frozen state for a primitive.

Parameters:

primitive - The primitive for which the frozen will be returned. May also be an array of primitives.

Return:

The frozen state for the primitive.

See also:

<setFrozen>
*/

function getFrozen(primitive) {
	return map(primitive, function (primitive) {
		return isTrue(primitive.getAttribute("Frozen"));
	});
}

/*
Method: setFrozen

Sets the frozen state for a primitive.

Parameters:

primitive - The primitive for which the frozen state will be set. May also be an array of primitives in which case they will all be set to the same frozen state.
frozen - The new frozen state for the primitive.

See also:

<getFrozen>
*/

function setFrozen(primitive, frozen) {
	map(primitive, function (primitive) {
		setAttributeUndoable(primitive, "Frozen", frozen);
	});
}


/*
Method: getChildren

Returns the children of a folder.

Parameters:

folder - The folder for which the children will be returned.
recursive - Optional. Whether the children of inner folders will be returned. Defaults to true.

Return:

The children primitives of the folder.

*/

function getChildren(folder, recursive) {
	if (isUndefined(recursive)) {
		recursive = true;
	}

	if (!folder.children) {
		return [];
	}

	if (recursive) {
		return flatten(map(folder.children, function (x) {
			if (x.value.nodeName == "Folder") {
				return x.children.concat([x]);
			} else {
				return x;
			}
		}));
	} else {
		return folder.children;
	}
}

/*
Method: getFolderType

Gets the type of a folder.

Parameters:

folder - The folder for which the type is requested. May also be an array of folders.

Return:

The type mode as a string. May be "None" or "Agent".

See also:

<setFolderType>
*/

function getFolderType(folder) {
	return map(folder, function (primitive) {
		return primitive.getAttribute("Type");
	});
}

/*
Method: setFolderType

Sets the type of a folder.

Parameters:

folder - The folder for which the type will be set. May also be an array of folders.
type - The type mode as a string. May be "None" or "Agent".

See also:

<getFolderType>
*/

function setFolderType(folder, type) {
	map(folder, function (primitive) {
		setAttributeUndoable(primitive, "Type", type);
	});
}

/*
Method: getFolderAgentParent

Gets the agent parent of a folder.

Parameters:

folder - The folder for which the agent parent is requested. May also be an array of folders.

Return:

The agent parent as a string.

See also:

<setFolderAgentParent>
*/

function getFolderAgentParent(folder) {
	return map(folder, function (primitive) {
		return primitive.getAttribute("AgentBase");
	});
}

/*
Method: setFolderAgentParent

Sets the agent parent of a folder.

Parameters:

folder - The folder for which the type will be set. May also be an array of folders.
agentParent - The agent parent as a string.

See also:

<getFolderAgentParent>
*/

function setFolderAgentParent(folder, agentParent) {
	map(folder, function (primitive) {
		setAttributeUndoable(primitive, "AgentBase", agentParent);
	});
}


/*
Method: getFolderSolver

Gets the solver configuration for a folder. The configuration is an object with the properties:

enabled - true is the folder should have its own solver
algorithm - the solution algorithm. Current allowed values are "RK1" for Euler's method and "RK4" for a fourth order Runge-Kutta method
timeStep - the time step for the folder's solver

Parameters:

folder - The folder for which the solver is requested. May also be an array of folders.

Return:

The solver object

See also:

<setFolderSolver>
*/

function getFolderSolver(folder) {
	return map(folder, function (primitive) {
		return JSON.parse(primitive.getAttribute("Solver"));
	});
}

/*
Method: setFolderSolver

Sets the solver object for a folder

Parameters:

folder - The folder for which the solver will be set. May also be an array of folders.
solver - The solver object

See also:

<getFolderSolver>
*/

function setFolderSolver(folder, solver) {
	map(folder, function (primitive) {
		setAttributeUndoable(primitive, "Solver", JSON.stringify(solver));
	});
}


/*

Group: Utility Functions

*/


/*
Method: excludeType

Removes a specific type of primitive from an array of primitives.

Parameter:

array - An array of primitives.
type - The type of primitives to remove (e.g. "Flow" or "Stock"). May also be an array of types. 

Return:

A duplicate of the input array without any primitives of the specified type.

*/


function excludeType(array, type) {
	var removeSingle = function (array, type) {
		if (array instanceof Array) {
			var res = [];
			for (var i = 0; i < array.length; i++) {
				if (array[i].value.nodeName != type) {
					res.push(array[i]);
				}
			}
			return res;
		} else {
			if (array == null) {
				return array;
			}
			if (array.value.nodeName == type) {
				return null
			}
			return array;
		}
	}

	if (Array.isArray(type)) {
		for (var i = 0; i < type.length; i++) {
			array = removeSingle(array, type[i]);
		}
		return array;
	} else {
		return removeSingle(array, type);
	}

}

/*
Method: primitiveIndex

Locates the index of a specific primitive in an array of primitives.

Parameter:

array - An array of primitives.
primitive - The specific primitive to find.

Return:

The index of the primitive in the array. Returns -1 if the primitive is not found.

*/


function primitiveIndex(array, primitive) {
	for (var i = 0; i < array.length; i++) {
		if (array[i].id == primitive.id) {
			return i;
		}
	}
	return -1;
}

/*
Method: uniquePrimitives

Returns the passed array with duplicated primitives removed

Parameter:

primitives - An array of primitives.

Return:

An array of primitives with any duplicated elements removed.

*/


function uniquePrimitives(primitives) {
	var res = [];
	for (var i = 0; i < primitives.length; i++) {
		var found = false;
		for (var r = 0; r < res.length; r++) {
			if (res[r].id == primitives[i].id) {
				found = true;
				break;
			}
		}
		if (!found) {
			res.push(primitives[i]);
		}
	}
	return res;
}

/*
Method: setGlobal

Sets the value of a global variable. This can allow communication between buttons or the storing of some state.

Parameter:

name - The name of the global variable.
value - The value of the global variable.

See also:

<getGlobal>


*/

var globalVarBank = {};

function setGlobal(name, value) {
	globalVarBank["_" + name] = value;
}

/*
Method: getGlobal

Gets the value of a global variable. This can allow communication between buttons or the storing of some state.

Parameter:

name - The name of the global variable for which to get the value.

Return:

The value of the global variable specified by name.

Example:

> setGlobal("Example Var 1", 42);
> setGlobal("Example Var 2", "test");
> var z = getGlobal("Example Var 1"); // z is now set to 42
> var y = getGlobal("Example Var 2"); // y is now set to "test"

See also:

<setGlobal>

*/

function getGlobal(name) {
	return globalVarBank["_" + name];
}



/*

Group: Insight Maker Interface

*/

/*
Method: topBarShown

Determines whether or not the Insight Maker top toolbar (which contains the Run Simulation button and other tools) is currently shown.

Return:

True if the top toolbar is shown, false otherwise.

See also:

<toggleTopBar>

*/

function topBarShown() {
	var toolbar = ribbonPanel.getDockedItems()[0];
	return toolbar.isVisible();
}

/*
Method: toggleTopBar

Toggles the visibility of the top toolbar. If it is currently shown, it is hidden. If it is currently hidden, it is shown.

See also:

<topBarShown>

*/

function toggleTopBar() {
	var toolbar = ribbonPanel.getDockedItems()[0];
	if (!toolbar.isVisible()) {
		toolbar.show();
		try {
			Ext.get("toplinks-holder").removeCls("collapsed");
		} catch (err) { }
	} else {
		toolbar.hide();
		try {
			Ext.get("toplinks-holder").addCls("collapsed");
		} catch (err) { }
	}
}


/*
Method: sideBarShown

Determines whether or not the Insight Maker side panel (which contains parameter sliders and information about the selected primitive) is currently shown.

Return:

True if the side panel is shown, false otherwise.

See also:

<toggleSideBar>

*/

function sideBarShown() {
	return (!configPanel.collapsed);
}

/*
Method: toggleSideBar

Toggles the visibility of the side panel. If it is currently shown, it is hidden. If it is currently hidden, it is shown.

See also:

<sideBarShown>

*/

function toggleSideBar() {
	if (sideBarShown()) {
		configPanel.collapse(Ext.Component.DIRECTION_RIGHT, false);
	} else {
		configPanel.expand(false);
	}
}

/*
Method: updateSideBar

Refreshes the values in the side panel to reflect any changes in the model.

*/

function updateSideBar() {
	selectionChanged(true);
}


/*
Some portions:
Copyright (c) 2008, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.net/yui/license.txt
version: 2.5.1
*/

// create org.antlr module
if (typeof org == "undefined" || !org) {
    var org = {};
}
if (typeof org.antlr == "undefined" || !org.antlr) {
    /**
     * The org.antlr global namespace object.  If antlr is already defined, the
     * existing antlr object will not be overwritten so that defined
     * namespaces are preserved.
     * @namespace org.antlr
     */
    org.antlr = {};
}

/**
 * The global JavaScript object.
 */
org.antlr.global = (function() {
    return this;
}).call(null);

/**
 * Returns the namespace specified and creates it if it doesn't exist.
 *
 * Be careful when naming packages. Reserved words may work in some browsers
 * and not others. For instance, the following will fail in Safari:
 * <pre>
 * org.antlr.namespace("really.long.nested.namespace");
 * </pre>
 * This fails because "long" is a future reserved word in ECMAScript
 *
 * @static
 * @param  {Array.<String>} arguments 1-n namespaces to create 
 * @return {Object}  A reference to the last namespace object created
 * @example
 * org.antlr.namespace("org.antlr.property.package");
 */
org.antlr.namespace = function() {
    var a=arguments, o=null, i, j, d;
    for (i=0; i<a.length; i=i+1) {
        d=a[i].split(".");
        o=org.antlr.global;

        // ANTLR is implied, so it is ignored if it is included
        for (j=0; j<d.length; j=j+1) {
            o[d[j]]=o[d[j]] || {};
            o=o[d[j]];
        }
    }

    return o;
};

/**
 * org.antlr.env is used to keep track of what is known about the library and
 * the browsing environment
 * @namespace org.antlr.env
 */
org.antlr.env = org.antlr.env || {};

/**
 * Do not fork for a browser if it can be avoided.  Use feature detection when
 * you can.  Use the user agent as a last resort.  org.antlr.env.ua stores a
 * version number for the browser engine, 0 otherwise.  This value may or may
 * not map to the version number of the browser using the engine.  The value is 
 * presented as a float so that it can easily be used for boolean evaluation 
 * as well as for looking for a particular range of versions.  Because of this, 
 * some of the granularity of the version info may be lost (e.g., Gecko 1.8.0.9 
 * reports 1.8).
 * @namespace org.antlr.env.ua
 */
org.antlr.env.ua = function() {
    var o= /** @lends org.antlr.env.ua */ {

        /**
         * Internet Explorer version number or 0.  Example: 6
         * @property ie
         * @type float
         */
        ie:0,

        /**
         * Opera version number or 0.  Example: 9.2
         * @property opera
         * @type float
         */
        opera:0,

        /**
         * Gecko engine revision number.  Will evaluate to 1 if Gecko 
         * is detected but the revision could not be found. Other browsers
         * will be 0.  Example: 1.8
         * <pre>
         * Firefox 1.0.0.4: 1.7.8   <-- Reports 1.7
         * Firefox 1.5.0.9: 1.8.0.9 <-- Reports 1.8
         * Firefox 2.0.0.3: 1.8.1.3 <-- Reports 1.8
         * Firefox 3 alpha: 1.9a4   <-- Reports 1.9
         * </pre>
         * @property gecko
         * @type float
         */
        gecko:0,

        /**
         * AppleWebKit version.  KHTML browsers that are not WebKit browsers 
         * will evaluate to 1, other browsers 0.  Example: 418.9.1
         * <pre>
         * Safari 1.3.2 (312.6): 312.8.1 <-- Reports 312.8 -- currently the 
         *                                   latest available for Mac OSX 10.3.
         * Safari 2.0.2:         416     <-- hasOwnProperty introduced
         * Safari 2.0.4:         418     <-- preventDefault fixed
         * Safari 2.0.4 (419.3): 418.9.1 <-- One version of Safari may run
         *                                   different versions of webkit
         * Safari 2.0.4 (419.3): 419     <-- Tiger installations that have been
         *                                   updated, but not updated
         *                                   to the latest patch.
         * Webkit 212 nightly:   522+    <-- Safari 3.0 precursor (with native SVG
         *                                   and many major issues fixed).  
         * 3.x yahoo.com, flickr:422     <-- Safari 3.x hacks the user agent
         *                                   string when hitting yahoo.com and 
         *                                   flickr.com.
         * Safari 3.0.4 (523.12):523.12  <-- First Tiger release - automatic update
         *                                   from 2.x via the 10.4.11 OS patch
         * Webkit nightly 1/2008:525+    <-- Supports DOMContentLoaded event.
         *                                   yahoo.com user agent hack removed.
         *                                   
         * </pre>
         * http://developer.apple.com/internet/safari/uamatrix.html
         * @property webkit
         * @type float
         */
        webkit: 0,

        /**
         * The mobile property will be set to a string containing any relevant
         * user agent information when a modern mobile browser is detected.
         * Currently limited to Safari on the iPhone/iPod Touch, Nokia N-series
         * devices with the WebKit-based browser, and Opera Mini.  
         * @property mobile 
         * @type string
         */
        mobile: null,

        /**
         * Adobe AIR version number or 0.  Only populated if webkit is detected.
         * Example: 1.0
         * @property air
         * @type float
         */
        air: 0,

        /**
         * Is this the Rhino interpreter?
         * @property rhino
         * @type Boolean
         */
        rhino: false

    };

    var ua, m;

    try {
        ua = navigator.userAgent;

        // Modern KHTML browsers should qualify as Safari X-Grade
        if ((/KHTML/).test(ua)) {
            o.webkit=1;
        }
        // Modern WebKit browsers are at least X-Grade
        m=ua.match(/AppleWebKit\/([^\s]*)/);
        if (m&&m[1]) {
            o.webkit=parseFloat(m[1]);

            // Mobile browser check
            if (/ Mobile\//.test(ua)) {
                o.mobile = "Apple"; // iPhone or iPod Touch
        } else {
            m=ua.match(/NokiaN[^\/]*/);
            if (m) {
                o.mobile = m[0]; // Nokia N-series, ex: NokiaN95
            }
        }

        m=ua.match(/AdobeAIR\/([^\s]*)/);
        if (m) {
            o.air = m[0]; // Adobe AIR 1.0 or better
        }

        }

        if (!o.webkit) { // not webkit
            // @todo check Opera/8.01 (J2ME/MIDP; Opera Mini/2.0.4509/1316; fi; U; ssr)
            m=ua.match(/Opera[\s\/]([^\s]*)/);
            if (m&&m[1]) {
                o.opera=parseFloat(m[1]);
                m=ua.match(/Opera Mini[^;]*/);
            if (m) {
                o.mobile = m[0]; // ex: Opera Mini/2.0.4509/1316
            }
            } else { // not opera or webkit
                m=ua.match(/MSIE\s([^;]*)/);
                if (m&&m[1]) {
                    o.ie=parseFloat(m[1]);
                } else { // not opera, webkit, or ie
                    m=ua.match(/Gecko\/([^\s]*)/);
                    if (m) {
                        o.gecko=1; // Gecko detected, look for revision
                        m=ua.match(/rv:([^\s\)]*)/);
                        if (m&&m[1]) {
                            o.gecko=parseFloat(m[1]);
                        }
                    }
                }
            }
        }
    } catch(e) {
        // ignore this if we're not in a browser
    }

    try {
        if (typeof window=="undefined" && typeof loadClass!="undefined") {
            o.rhino = true;
        }
    } catch(e) {}

    
    return o;
}();

/**
 * JavaScript runtime library code.
 * @name org.antlr.runtime
 * @namespace
 */
/**
 * JavaScript runtime library tree parser code.
 * @name org.antlr.runtime.tree
 * @namespace
 */
org.antlr.namespace("org.antlr.runtime.tree");

/**
 * Provides the language utilites and extensions used by the library
 * @namespace org.antlr.lang
 */
org.antlr.lang = org.antlr.lang || /** @lends org.antlr.lang */ {
    /**
     * Determines whether or not the provided object is an array.
     * Testing typeof/instanceof/constructor of arrays across frame 
     * boundaries isn't possible in Safari unless you have a reference
     * to the other frame to test against its Array prototype.  To
     * handle this case, we test well-known array properties instead.
     * properties.
     * @param {any} o The object being testing
     * @return {boolean} the result
     */
    isArray: function(o) { 
        if (o) {
           var l = org.antlr.lang;
           return l.isNumber(o.length) && l.isFunction(o.splice);
        }
        return false;
    },

    /**
     * Determines whether or not the provided object is a boolean
     * @param {any} o The object being testing
     * @return {boolean} the result
     */
    isBoolean: function(o) {
        return typeof o === 'boolean';
    },
    
    /**
     * Determines whether or not the provided object is a function
     * @param {any} o The object being testing
     * @return {boolean} the result
     */
    isFunction: function(o) {
        return typeof o === 'function';
    },
        
    /**
     * Determines whether or not the provided object is null
     * @param {any} o The object being testing
     * @return {boolean} the result
     */
    isNull: function(o) {
        return o === null;
    },
        
    /**
     * Determines whether or not the provided object is a legal number
     * @param {any} o The object being testing
     * @return {boolean} the result
     */
    isNumber: function(o) {
        return typeof o === 'number' && isFinite(o);
    },
      
    /**
     * Determines whether or not the provided object is of type object
     * or function
     * @param {any} o The object being testing
     * @return {boolean} the result
     */  
    isObject: function(o) {
return (o && (typeof o === 'object' || org.antlr.lang.isFunction(o))) || false;
    },
        
    /**
     * Determines whether or not the provided object is a string
     * @param {any} o The object being testing
     * @return {boolean} the result
     */
    isString: function(o) {
        return typeof o === 'string';
    },
        
    /**
     * Determines whether or not the provided object is undefined
     * @param {any} o The object being testing
     * @return {boolean} the result
     */
    isUndefined: function(o) {
        return typeof o === 'undefined';
    },
    
    /**
     * IE will not enumerate native functions in a derived object even if the
     * function was overridden.  This is a workaround for specific functions 
     * we care about on the Object prototype. 
     * @param {Function} r  the object to receive the augmentation
     * @param {Function} s  the object that supplies the properties to augment
     * @private
     */
    _IEEnumFix: function(r, s) {
        if (org.antlr.env.ua.ie) {
            var add=["toString", "valueOf"], i;
            for (i=0;i<add.length;i=i+1) {
                var fname=add[i],f=s[fname];
                if (org.antlr.lang.isFunction(f) && f!=Object.prototype[fname]) {
                    r[fname]=f;
                }
            }
        }
    },
       
    /**
     * Utility to set up the prototype, constructor and superclass properties to
     * support an inheritance strategy that can chain constructors and methods.
     * Static members will not be inherited.
     *
     * @method extend
     * @static
     * @param {Function} subc   the object to modify
     * @param {Function} superc the object to inherit
     * @param {Object} [overrides]  additional properties/methods to add to the
     *                              subclass prototype.  These will override the
     *                              matching items obtained from the superclass 
     *                              if present.
     */
    extend: function(subc, superc, overrides) {
        if (!superc||!subc) {
            throw new Error("org.antlr.lang.extend failed, please check that " +
                            "all dependencies are included.");
        }
        var F = function() {};
        F.prototype=superc.prototype;
        subc.prototype=new F();
        subc.prototype.constructor=subc;
        subc.superclass=superc.prototype;
        if (superc.prototype.constructor == Object.prototype.constructor) {
            superc.prototype.constructor=superc;
        }
    
        if (overrides) {
            for (var i in overrides) {
                subc.prototype[i]=overrides[i];
            }

            org.antlr.lang._IEEnumFix(subc.prototype, overrides);
        }
    },
   
    /**
     * Applies all properties in the supplier to the receiver if the
     * receiver does not have these properties yet.  Optionally, one or 
     * more methods/properties can be specified (as additional 
     * parameters).  This option will overwrite the property if receiver 
     * has it already.  If true is passed as the third parameter, all 
     * properties will be applied and _will_ overwrite properties in 
     * the receiver.
     *
     * @param {Function} r  the object to receive the augmentation
     * @param {Function} s  the object that supplies the properties to augment
     * @param {Array.<String>|boolean}  [arguments] zero or more properties
     *        methods  to augment the receiver with.  If none specified,
     *        everything in the supplier will be used unless it would
     *        overwrite an existing property in the receiver. If true
     *        is specified as the third parameter, all properties will
     *        be applied and will overwrite an existing property in
     *        the receiver
     */
    augmentObject: function(r, s) {
        if (!s||!r) {
            throw new Error("Absorb failed, verify dependencies.");
        }
        var a=arguments, i, p, override=a[2];
        if (override && override!==true) { // only absorb the specified properties
            for (i=2; i<a.length; i=i+1) {
                r[a[i]] = s[a[i]];
            }
        } else { // take everything, overwriting only if the third parameter is true
            for (p in s) { 
                if (override || !r[p]) {
                    r[p] = s[p];
                }
            }
            
            org.antlr.lang._IEEnumFix(r, s);
        }
    },
 
    /**
     * Same as org.antlr.lang.augmentObject, except it only applies prototype properties
     * @see org.antlr.lang.augmentObject
     * @param {Function} r  the object to receive the augmentation
     * @param {Function} s  the object that supplies the properties to augment
     * @param {Array.<String>|boolean}  [arguments] zero or more properties methods 
     *        to augment the receiver with.  If none specified, everything 
     *        in the supplier will be used unless it would overwrite an existing 
     *        property in the receiver.  if true is specified as the third 
     *        parameter, all properties will be applied and will overwrite an 
     *        existing property in the receiver
     */
    augmentProto: function(r, s) {
        if (!s||!r) {
            throw new Error("Augment failed, verify dependencies.");
        }
        //var a=[].concat(arguments);
        var a=[r.prototype,s.prototype];
        for (var i=2;i<arguments.length;i=i+1) {
            a.push(arguments[i]);
        }
        org.antlr.lang.augmentObject.apply(this, a);
    },

    /**
     * Returns a new object containing all of the properties of
     * all the supplied objects.  The properties from later objects
     * will overwrite those in earlier objects.
     * @param arguments {Object*} the objects to merge
     * @return the new merged object
     */
    merge: function() {
        var o={}, a=arguments;
        for (var i=0, l=a.length; i<l; i=i+1) {
            org.antlr.lang.augmentObject(o, a[i], true);
        }
        return o;
    },

    /**
     * A convenience method for detecting a legitimate non-null value.
     * Returns false for null/undefined/NaN, true for other values, 
     * including 0/false/''
     * @param o {any} the item to test
     * @return {boolean} true if it is not null/undefined/NaN || false
     */
    isValue: function(o) {
        var l = org.antlr.lang;
return (l.isObject(o) || l.isString(o) || l.isNumber(o) || l.isBoolean(o));
    },

    /** @namespace org.antlr.lang.array Array convenience methods. */
    array: /** @lends org.antlr.lang.array */ {
        /**
         * Retrieve the last element of an array. Throws an error if a is not
         * an array or empty.
         * @param a {Array} the array stack to peek in
         * @return the last element of the array
         */
         peek: function(a) {
            if (!org.antlr.lang.isArray(a)) {
                throw new Error("org.antlr.lang.array.peek: a is not an array.");
            }
            var l = a.length;
            if (l<=0) {
                throw new Error("org.antlr.lang.array.peek: a is empty.");
            }
            return a[l-1];
        }
    }
};


if (typeof org.antlr.runtime == "undefined" || !org.antlr.runtime) {
    /**
     * The org.antlr.runtime namespace object.  If antlr is already defined, the
     * existing antlr object will not be overwritten so that defined
     * namespaces are preserved.
     * @namespace org.antlr.runtime
     */
    org.antlr.runtime = {};
}

/** The root of the ANTLR exception hierarchy.
 *
 *  <p>To avoid English-only error messages and to generally make things
 *  as flexible as possible, these exceptions are not created with strings,
 *  but rather the information necessary to generate an error.  Then
 *  the various reporting methods in Parser and Lexer can be overridden
 *  to generate a localized error message.  For example, MismatchedToken
 *  exceptions are built with the expected token type.
 *  So, don't expect getMessage() to return anything.</p>
 *
 *  <p>ANTLR generates code that throws exceptions upon recognition error and
 *  also generates code to catch these exceptions in each rule.  If you
 *  want to quit upon first error, you can turn off the automatic error
 *  handling mechanism using rulecatch action, but you still need to
 *  override methods mismatch and recoverFromMismatchSet.</p>
 *
 *  <p>In general, the recognition exceptions can track where in a grammar a
 *  problem occurred and/or what was the expected input.  While the parser
 *  knows its state (such as current input symbol and line info) that
 *  state can change before the exception is reported so current token index
 *  is computed and stored at exception time.  From this info, you can
 *  perhaps print an entire line of input not just a single token, for example.
 *  Better to just say the recognizer had a problem and then let the parser
 *  figure out a fancy report.</p>
 *
 *  @class
 *  @param {org.antlr.runtime.CommonTokenStream|org.antlr.runtime.tree.TreeNodeStream|org.antlr.runtime.ANTLRStringStream} input input stream that has an exception.
 *  @extends Error
 *
 */
org.antlr.runtime.RecognitionException = function(input) {
    org.antlr.runtime.RecognitionException.superclass.constructor.call(this);
    this.input = input;
    this.index = input.index();
    if ( input instanceof org.antlr.runtime.TokenStream ) {
        this.token = input.LT(1);
        this.line = this.token.getLine();
        this.charPositionInLine = this.token.getCharPositionInLine();
    }
    if ( input instanceof org.antlr.runtime.tree.TreeNodeStream ) {
        this.extractInformationFromTreeNodeStream(input);
    }
    else if ( input instanceof org.antlr.runtime.CharStream ) {
        // Note: removed CharStream from hierarchy in JS port so checking for
        // StringStream instead
        this.c = input.LA(1);
        this.line = input.getLine();
        this.charPositionInLine = input.getCharPositionInLine();
    }
    else {
        this.c = input.LA(1);
    }

    this.message = this.toString();
};

org.antlr.lang.extend(org.antlr.runtime.RecognitionException, Error,
/** @lends org.antlr.runtime.RecognitionException.prototype */
{
	/**
     * What input stream did the error occur in?
     */
    input: null,

    /** What is index of token/char were we looking at when the error occurred?
     *  @type Number
     */
	index: null,

	/** The current Token when an error occurred.  Since not all streams
	 *  can retrieve the ith Token, we have to track the Token object.
	 *  For parsers.  Even when it's a tree parser, token might be set.
     *  @type org.antlr.runtime.CommonToken
	 */
	token: null,

	/** If this is a tree parser exception, node is set to the node with
	 *  the problem.
     *  @type Object
	 */
	node: null,

	/** The current char when an error occurred. For lexers.
     *  @type Number
     */
	c: null,

	/** Track the line at which the error occurred in case this is
	 *  generated from a lexer.  We need to track this since the
	 *  unexpected char doesn't carry the line info.
     *  @type Number
	 */
	line: null,

    /** The exception's class name.
     *  @type String
     */
    name: "org.antlr.runtime.RecognitionException",

    /** Position in the line where exception occurred.
     *  @type Number
     */
	charPositionInLine: null,

	/** If you are parsing a tree node stream, you will encounter som
	 *  imaginary nodes w/o line/col info.  We now search backwards looking
	 *  for most recent token with line/col info, but notify getErrorHeader()
	 *  that info is approximate.
     *  @type Boolean
	 */
	approximateLineInfo: null,

    /** Gather exception information from input stream.
     *  @param {org.antlr.runtime.CommonTokenStream|org.antlr.runtime.tree.TreeNodeStream|org.antlr.runtime.ANTLRStringStream} input input stream that has an exception.
     */
	extractInformationFromTreeNodeStream: function(input) {
		var nodes = input,
            priorNode,
            priorPayload,
            type,
            text,
            i;

		this.node = nodes.LT(1);
		var adaptor = nodes.getTreeAdaptor(),
		    payload = adaptor.getToken(this.node);
		if ( payload ) {
			this.token = payload;
			if ( payload.getLine()<= 0 ) {
				// imaginary node; no line/pos info; scan backwards
				i = -1;
				priorNode = nodes.LT(i);
				while ( priorNode ) {
					priorPayload = adaptor.getToken(priorNode);
					if ( priorPayload && priorPayload.getLine()>0 ) {
						// we found the most recent real line / pos info
						this.line = priorPayload.getLine();
						this.charPositionInLine = priorPayload.getCharPositionInLine();
						this.approximateLineInfo = true;
						break;
					}
					--i;
					priorNode = nodes.LT(i);
				}
			}
			else { // node created from real token
				this.line = payload.getLine();
				this.charPositionInLine = payload.getCharPositionInLine();
			}
		}
		else if ( this.node instanceof org.antlr.runtime.tree.Tree) {
			this.line = this.node.getLine();
			this.charPositionInLine = this.node.getCharPositionInLine();
			if ( this.node instanceof org.antlr.runtime.tree.CommonTree) {
				this.token = this.node.token;
			}
		}
		else {
			type = adaptor.getType(this.node);
			text = adaptor.getText(this.node);
			this.token = new org.antlr.runtime.CommonToken(type, text);
		}
	},

	/** Return the token type or char of the unexpected input element
     *  @return {Number} type of the unexpected input element.
     */
    getUnexpectedType: function() {
		if ( this.input instanceof org.antlr.runtime.TokenStream ) {
			return this.token.getType();
		}
		else if ( this.input instanceof org.antlr.runtime.tree.TreeNodeStream ) {
			var nodes = this.input;
			var adaptor = nodes.getTreeAdaptor();
			return adaptor.getType(this.node);
		}
		else {
			return this.c;
		}
	}
});


/**
 * A source of characters for an ANTLR lexer.
 * This class should not be instantiated directly.  Instead, use one of its subclasses.
 * @class
 * @extends org.antlr.runtime.IntStream
 */
org.antlr.runtime.CharStream = function() {};
org.antlr.runtime.IntStream = function() {};

org.antlr.lang.extend(org.antlr.runtime.CharStream,
                      org.antlr.runtime.IntStream);  

org.antlr.lang.augmentObject(org.antlr.runtime.CharStream,
/** @lends org.antlr.runtime.CharStream */
{
    /**
     * Token type of the EOF character.
     * @type Number
     */
    EOF: -1
});


// NB: Because Token has static members of type CommonToken, the Token dummy
// constructor is defined in CommonToken.  All methods and vars of Token are
// defined here.  Token is an interface, not a subclass in the Java runtime.

/**
 * @class Abstract base class of all token types.
 * @name Token
 * @memberOf org.antlr.runtime
 */
org.antlr.runtime.Token = function() {};
org.antlr.lang.augmentObject(org.antlr.runtime.Token, /** @lends Token */ {
    EOR_TOKEN_TYPE: 1,

    /** imaginary tree navigation type; traverse "get child" link */
    DOWN: 2,
    /** imaginary tree navigation type; finish with a child list */
    UP: 3,

    MIN_TOKEN_TYPE: 4, // UP+1,

    EOF: org.antlr.runtime.CharStream.EOF,
    EOF_TOKEN: null,

    INVALID_TOKEN_TYPE: 0,
    INVALID_TOKEN: null,

    /** In an action, a lexer rule can set token to this SKIP_TOKEN and ANTLR
     *  will avoid creating a token for this symbol and try to fetch another.
     */
    SKIP_TOKEN: null,

    /** All tokens go to the parser (unless skip() is called in that rule)
     *  on a particular "channel".  The parser tunes to a particular channel
     *  so that whitespace etc... can go to the parser on a "hidden" channel.
     */
    DEFAULT_CHANNEL: 0,

    /** Anything on different channel than DEFAULT_CHANNEL is not parsed
     *  by parser.
     */
    HIDDEN_CHANNEL: 99
});


org.antlr.runtime.MismatchedTokenException = function(expecting, input) {
    if (arguments.length===0) {
        this.expecting = org.antlr.runtime.Token.INVALID_TOKEN_TYPE;
    } else {
        org.antlr.runtime.MismatchedTokenException.superclass.constructor.call(
                this, input);
        this.expecting = expecting;
    }
};

org.antlr.lang.extend(
    org.antlr.runtime.MismatchedTokenException,
    org.antlr.runtime.RecognitionException, {
    toString: function() {
        return "MismatchedTokenException(" +
                this.getUnexpectedType() + "!=" + this.expecting + ")";
    },
    name: "org.antlr.runtime.MismatchedTokenException"
});


/** An extra token while parsing a TokenStream */
org.antlr.runtime.UnwantedTokenException = function(expecting, input) {
    if (arguments.length>0) {
        org.antlr.runtime.UnwantedTokenException.superclass.constructor.call(
                this, expecting, input);
    }
};

org.antlr.lang.extend(
    org.antlr.runtime.UnwantedTokenException,
    org.antlr.runtime.MismatchedTokenException, {
    getUnexpectedToken: function() {
        return this.token;
    },
    toString: function() {
        var exp = ", expected "+this.expecting;
        if ( this.expecting===org.antlr.runtime.Token.INVALID_TOKEN_TYPE ) {
            exp = "";
        }
        if ( !org.antlr.lang.isValue(this.token) ) {
            return "UnwantedTokenException(found="+exp+")";
        }
        return "UnwantedTokenException(found="+this.token.getText()+exp+")";
    },
    name: "org.antlr.runtime.UnwantedTokenException"
});


org.antlr.runtime.CommonToken = function() {
    var oldToken;

    this.charPositionInLine = -1; // set to invalid position
    this.channel = 0; // org.antlr.runtime.CommonToken.DEFAULT_CHANNEL
    this.index = -1;

    if (arguments.length == 1) {
        if (org.antlr.lang.isNumber(arguments[0])) {
            this.type = arguments[0];
        } else {
            oldToken = arguments[0];
            this.text = oldToken.getText();
            this.type = oldToken.getType();
            this.line = oldToken.getLine();
            this.index = oldToken.getTokenIndex();
            this.charPositionInLine = oldToken.getCharPositionInLine();
            this.channel = oldToken.getChannel();
            if ( oldToken instanceof org.antlr.runtime.CommonToken ) {
                this.start = oldToken.start;
                this.stop = oldToken.stop;
            }
        }
    } else if (arguments.length == 2) {
        this.type = arguments[0];
        this.text = arguments[1];
        this.channel = 0; // org.antlr.runtime.CommonToken.DEFAULT_CHANNEL
    } else if (arguments.length == 5) {
        this.input = arguments[0];
        this.type = arguments[1];
        this.channel = arguments[2];
        this.start = arguments[3];
        this.stop = arguments[4];
    }
};

org.antlr.lang.extend(org.antlr.runtime.CommonToken,
                      org.antlr.runtime.Token,
{
    getType: function() {
        return this.type;
    },

    setLine: function(line) {
        this.line = line;
    },

    getText: function() {
        if ( org.antlr.lang.isString(this.text) ) {
            return this.text;
        }
        if ( !this.input ) {
            return null;
        }
        this.text = this.input.substring(this.start,this.stop);
        return this.text;
    },

    /** Override the text for this token.  getText() will return this text
     *  rather than pulling from the buffer.  Note that this does not mean
     *  that start/stop indexes are not valid.  It means that that input
     *  was converted to a new string in the token object.
     */
    setText: function(text) {
        this.text = text;
    },

    getLine: function() {
        return this.line;
    },

    getCharPositionInLine: function() {
        return this.charPositionInLine;
    },

    setCharPositionInLine: function(charPositionInLine) {
        this.charPositionInLine = charPositionInLine;
    },

    getChannel: function() {
        return this.channel;
    },

    setChannel: function(channel) {
        this.channel = channel;
    },

    setType: function(type) {
        this.type = type;
    },

    getStartIndex: function() {
        return this.start;
    },

    setStartIndex: function(start) {
        this.start = start;
    },

    getStopIndex: function() {
        return this.stop;
    },

    setStopIndex: function(stop) {
        this.stop = stop;
    },

    getTokenIndex: function() {
        return this.index;
    },

    setTokenIndex: function(index) {
        this.index = index;
    },

    getInputStream: function() {
        return this.input;
    },

    setInputStream: function(input) {
        this.input = input;
    },

    toString: function() {
        var channelStr = "";
        if ( this.channel>0 ) {
            channelStr=",channel="+this.channel;
        }
        var txt = this.getText();
        if ( !org.antlr.lang.isNull(txt) ) {
            txt = txt.replace(/\n/g,"\\\\n");
            txt = txt.replace(/\r/g,"\\\\r");
            txt = txt.replace(/\t/g,"\\\\t");
        }
        else {
            txt = "<no text>";
        }
        return "[@"+this.getTokenIndex()+","+this.start+":"+this.stop+"='"+txt+"',<"+this.type+">"+channelStr+","+this.line+":"+this.getCharPositionInLine()+"]";
    }
});

/* Monkey patch Token static vars that depend on CommonToken. */
org.antlr.lang.augmentObject(org.antlr.runtime.Token, {
    EOF_TOKEN: new org.antlr.runtime.CommonToken(org.antlr.runtime.CharStream.EOF),
    INVALID_TOKEN: new org.antlr.runtime.CommonToken(0),
    SKIP_TOKEN: new org.antlr.runtime.CommonToken(0)
}, true);


/** The most common stream of tokens is one where every token is buffered up
 *  and tokens are prefiltered for a certain channel (the parser will only
 *  see these tokens and cannot change the filter channel number during the
 *  parse).
 *
 *  TODO: how to access the full token stream?  How to track all tokens matched per rule?
 */
org.antlr.runtime.CommonTokenStream = function(tokenSource, channel) {
    this.p = -1;
    this.channel = org.antlr.runtime.Token.DEFAULT_CHANNEL;
    this.v_discardOffChannelTokens = false;

    this.tokens = [];
    if (arguments.length >= 2) {
        this.channel = channel;
    } else if (arguments.length === 1) {
        this.tokenSource = tokenSource;
    }
};
org.antlr.runtime.TokenStream = function() {};

org.antlr.lang.extend(org.antlr.runtime.CommonTokenStream,
                      org.antlr.runtime.TokenStream,       
{
    /** Reset this token stream by setting its token source. */
    setTokenSource: function(tokenSource) {
        this.tokenSource = tokenSource;
        this.tokens = [];
        this.p = -1;
        this.channel = org.antlr.runtime.Token.DEFAULT_CHANNEL;
    },

    /** Load all tokens from the token source and put in tokens.
     *  This is done upon first LT request because you might want to
     *  set some token type / channel overrides before filling buffer.
     */
    fillBuffer: function() {
        var index = 0,
            t = this.tokenSource.nextToken(),
            discard,
            channelI;
        while ( org.antlr.lang.isValue(t) && 
                t.getType()!=org.antlr.runtime.CharStream.EOF )
        {
            discard = false;
            // is there a channel override for token type?
            if ( this.channelOverrideMap ) {
                channelI = this.channelOverrideMap[t.getType()];
                if ( org.antlr.lang.isValue(channelI) ) {
                    t.setChannel(channelI);
                }
            }
            if ( this.discardSet && this.discardSet[t.getType()] )
            {
                discard = true;
            }
            else if ( this.v_discardOffChannelTokens &&
                    t.getChannel()!=this.channel )
            {
                discard = true;
            }
            if ( !discard )    {
                t.setTokenIndex(index);
                this.tokens.push(t);
                index++;
            }
            t = this.tokenSource.nextToken();
        }
        // leave p pointing at first token on channel
        this.p = 0;
        this.p = this.skipOffTokenChannels(this.p);
    },

    /** Move the input pointer to the next incoming token.  The stream
     *  must become active with LT(1) available.  consume() simply
     *  moves the input pointer so that LT(1) points at the next
     *  input symbol. Consume at least one token.
     *
     *  Walk past any token not on the channel the parser is listening to.
     */
    consume: function() {
        if ( this.p<this.tokens.length ) {
            this.p++;
            this.p = this.skipOffTokenChannels(this.p); // leave p on valid token
        }
    },

    /** Given a starting index, return the index of the first on-channel
     *  token.
     */
    skipOffTokenChannels: function(i) {
        var n = this.tokens.length;
        while ( i<n && (this.tokens[i]).getChannel()!=this.channel ) {
            i++;
        }
        return i;
    },

    skipOffTokenChannelsReverse: function(i) {
        while ( i>=0 && (this.tokens[i]).getChannel()!=this.channel ) {
            i--;
        }
        return i;
    },

    /** A simple filter mechanism whereby you can tell this token stream
     *  to force all tokens of type ttype to be on channel.  For example,
     *  when interpreting, we cannot exec actions so we need to tell
     *  the stream to force all WS and NEWLINE to be a different, ignored
     *  channel.
     */
    setTokenTypeChannel: function(ttype, channel) {
        if ( !this.channelOverrideMap ) {
            this.channelOverrideMap = {};
        }
        this.channelOverrideMap[ttype] = channel;
    },

    discardTokenType: function(ttype) {
        if ( !this.discardSet ) {
            this.discardSet = {};
        }
        this.discardSet[ttype] = true;
    },

    discardOffChannelTokens: function(b) {
        this.v_discardOffChannelTokens = b;
    },

    /** Given a start and stop index, return a List of all tokens in
     *  the token type BitSet.  Return null if no tokens were found.  This
     *  method looks at both on and off channel tokens.
     */
    getTokens: function(start, stop, types) {
        if ( this.p === -1 ) {
            this.fillBuffer();
        }

        if (arguments.length===0) {
            return this.tokens;
        }

        if (org.antlr.lang.isArray(types)) {
            types = new org.antlr.runtime.BitSet(types);
        } else if (org.antlr.lang.isNumber(types)) {
            types = org.antlr.runtime.BitSet.of(types);
        }

        if ( stop>=this.tokens.length ) {
            stop=this.tokens.length-1;
        }
        if ( start<0 ) {
            start=0;
        }
        if ( start>stop ) {
            return null;
        }

        // list = tokens[start:stop]:{Token t, t.getType() in types}
        var filteredTokens = [],
            i,
            t;
        for (i=start; i<=stop; i++) {
            t = this.tokens[i];
            if ( !this.types || types.member(t.getType()) ) {
                filteredTokens.push(t);
            }
        }
        if ( filteredTokens.length===0 ) {
            filteredTokens = null;
        }
        return filteredTokens;
    },

    /** Get the ith token from the current position 1..n where k=1 is the
     *  first symbol of lookahead.
     */
    LT: function(k) {
        if ( this.p === -1 ) {
            this.fillBuffer();
        }
        if ( k===0 ) {
            return null;
        }
        if ( k<0 ) {
            return this.LB(-1*k);
        }
        if ( (this.p+k-1) >= this.tokens.length ) {
            return org.antlr.runtime.Token.EOF_TOKEN;
        }
        var i = this.p,
            n = 1;
        // find k good tokens
        while ( n<k ) {
            // skip off-channel tokens
            i = this.skipOffTokenChannels(i+1); // leave p on valid token
            n++;
        }
        if ( i>=this.tokens.length ) {
            return org.antlr.runtime.Token.EOF_TOKEN;
        }
        return this.tokens[i];
    },

    /** Look backwards k tokens on-channel tokens */
    LB: function(k) {
        if ( this.p === -1 ) {
            this.fillBuffer();
        }
        if ( k===0 ) {
            return null;
        }
        if ( (this.p-k)<0 ) {
            return null;
        }

        var i = this.p,
            n = 1;
        // find k good tokens looking backwards
        while ( n<=k ) {
            // skip off-channel tokens
            i = this.skipOffTokenChannelsReverse(i-1); // leave p on valid token
            n++;
        }
        if ( i<0 ) {
            return null;
        }
        return this.tokens[i];
    },

    /** Return absolute token i; ignore which channel the tokens are on;
     *  that is, count all tokens not just on-channel tokens.
     */
    get: function(i) {
        return this.tokens[i];
    },

    LA: function(i) {
        return this.LT(i).getType();
    },

    mark: function() {
        if ( this.p === -1 ) {
            this.fillBuffer();
        }
        this.lastMarker = this.index();
        return this.lastMarker;
    },

    release: function(marker) {
        // no resources to release
    },

    size: function() {
        return this.tokens.length;
    },

    index: function() {
        return this.p;
    },

    rewind: function(marker) {
        if (!org.antlr.lang.isNumber(marker)) {
            marker = this.lastMarker;
        }
        this.seek(marker);
    },

    reset: function() {
        this.p = 0;
        this.lastMarker = 0;
    },

    seek: function(index) {
        this.p = index;
    },

    getTokenSource: function() {
        return this.tokenSource;
    },

    getSourceName: function() {
        return this.getTokenSource().getSourceName();
    },

    toString: function(start, stop) {
        if (arguments.length===0) {
            if ( this.p === -1 ) {
                this.fillBuffer();
            }
            start = 0;
            stop = this.tokens.length-1;
        }

        if (!org.antlr.lang.isNumber(start) && !org.antlr.lang.isNumber(stop)) {
            if ( org.antlr.lang.isValue(start) && org.antlr.lang.isValue(stop) ) {
                start = start.getTokenIndex();
                stop = stop.getTokenIndex();
            } else {
                return null;
            }
        }

        var buf = "",
            i,
            t;
 
        if ( start<0 || stop<0 ) {
            return null;
        }
        if ( this.p == -1 ) {
            this.fillBuffer();
        }
        if ( stop>=this.tokens.length ) {
            stop = this.tokens.length-1;
        }
        for (i = start; i <= stop; i++) {
            t = this.tokens[i];
            buf = buf + this.tokens[i].getText();
        }
        return buf;
    }
});


/* Useful for dumping out the input stream after doing some
 *  augmentation or other manipulations.
 *
 *  You can insert stuff, replace, and delete chunks.  Note that the
 *  operations are done lazily--only if you convert the buffer to a
 *  String.  This is very efficient because you are not moving data around
 *  all the time.  As the buffer of tokens is converted to strings, the
 *  toString() method(s) check to see if there is an operation at the
 *  current index.  If so, the operation is done and then normal String
 *  rendering continues on the buffer.  This is like having multiple Turing
 *  machine instruction streams (programs) operating on a single input tape. :)
 *
 *  Since the operations are done lazily at toString-time, operations do not
 *  screw up the token index values.  That is, an insert operation at token
 *  index i does not change the index values for tokens i+1..n-1.
 *
 *  Because operations never actually alter the buffer, you may always get
 *  the original token stream back without undoing anything.  Since
 *  the instructions are queued up, you can easily simulate transactions and
 *  roll back any changes if there is an error just by removing instructions.
 *  For example,
 *
 *   CharStream input = new ANTLRFileStream("input");
 *   TLexer lex = new TLexer(input);
 *   TokenRewriteStream tokens = new TokenRewriteStream(lex);
 *   T parser = new T(tokens);
 *   parser.startRule();
 *
 *      Then in the rules, you can execute
 *      Token t,u;
 *      ...
 *      input.insertAfter(t, "text to put after t");}
 *         input.insertAfter(u, "text after u");}
 *         System.out.println(tokens.toString());
 *
 *  Actually, you have to cast the 'input' to a TokenRewriteStream. :(
 *
 *  You can also have multiple "instruction streams" and get multiple
 *  rewrites from a single pass over the input.  Just name the instruction
 *  streams and use that name again when printing the buffer.  This could be
 *  useful for generating a C file and also its header file--all from the
 *  same buffer:
 *
 *      tokens.insertAfter("pass1", t, "text to put after t");}
 *         tokens.insertAfter("pass2", u, "text after u");}
 *         System.out.println(tokens.toString("pass1"));
 *         System.out.println(tokens.toString("pass2"));
 *
 *  If you don't use named rewrite streams, a "default" stream is used as
 *  the first example shows.
 */

org.antlr.runtime.TokenRewriteStream = function() {
    var sup = org.antlr.runtime.TokenRewriteStream.superclass;

    /** You may have multiple, named streams of rewrite operations.
     *  I'm calling these things "programs."
     *  Maps String (name) -> rewrite (List)
     */
    this.programs = null;

    /** Map String (program name) -> Integer index */
    this.lastRewriteTokenIndexes = null;


    if (arguments.length===0) {
        this.init();
    } else {
        sup.constructor.apply(this, arguments);
        this.init();
    }
};

(function(){
var trs = org.antlr.runtime.TokenRewriteStream;

org.antlr.lang.augmentObject(trs, {
    DEFAULT_PROGRAM_NAME: "default",
    PROGRAM_INIT_SIZE: 100,
    MIN_TOKEN_INDEX: 0
});

//
// Define the rewrite operation hierarchy
//

trs.RewriteOperation = function(index, text) {
    this.index = index;
    this.text = text;
};

/** Execute the rewrite operation by possibly adding to the buffer.
 *  Return the index of the next token to operate on.
 */
trs.RewriteOperation.prototype = {
    execute: function(buf) {
        return this.index;
    },
    toString: function() {
        /*String opName = getClass().getName();
        int $index = opName.indexOf('$');
        opName = opName.substring($index+1, opName.length());
        return opName+"@"+index+'"'+text+'"';*/
        return this.text;
    }
};

trs.InsertBeforeOp = function(index, text) {
    trs.InsertBeforeOp.superclass.constructor.call(this, index, text);
};
org.antlr.lang.extend(trs.InsertBeforeOp, trs.RewriteOperation, {
    execute: function(buf) {
        buf.push(this.text);
        return this.index;
    }
});

/** I'm going to try replacing range from x..y with (y-x)+1 ReplaceOp
 *  instructions.
 */
trs.ReplaceOp = function(from, to, text) {
    trs.ReplaceOp.superclass.constructor.call(this, from, text); 
    this.lastIndex = to;
};
org.antlr.lang.extend(trs.ReplaceOp, trs.RewriteOperation, {
    execute: function(buf) {
        if (org.antlr.lang.isValue(this.text)) {
            buf.push(this.text);
        }
        return this.lastIndex+1;
    }
});

trs.DeleteOp = function(from, to) {
    trs.DeleteOp.superclass.constructor.call(this, from, to); 
};
org.antlr.lang.extend(trs.DeleteOp, trs.ReplaceOp);

org.antlr.lang.extend(trs, org.antlr.runtime.CommonTokenStream, {
    init: function() {
        this.programs = {};
        this.programs[trs.DEFAULT_PROGRAM_NAME] = [];
        this.lastRewriteTokenIndexes = {};
    },

    /** Rollback the instruction stream for a program so that
     *  the indicated instruction (via instructionIndex) is no
     *  longer in the stream.  UNTESTED!
     */
    rollback: function() {
        var programName,
            instructionIndex;

        if (arguments.length===1) {
            programName = trs.DEFAULT_PROGRAM_NAME;
            instructionIndex = arguments[0];
        } else if (arguments.length===2) {
            programName = arguments[0];
            instructionIndex = arguments[1];
        }
        var is = this.programs[programName];
        if (is) {
            programs[programName] = is.slice(trs.MIN_TOKEN_INDEX, this.instructionIndex);
        }
    },

    /** Reset the program so that no instructions exist */
    deleteProgram: function(programName) {
        programName = programName || trs.DEFAULT_PROGRAM_NAME;
        this.rollback(programName, trs.MIN_TOKEN_INDEX);
    },

    /** Add an instruction to the rewrite instruction list ordered by
     *  the instruction number (use a binary search for efficiency).
     *  The list is ordered so that toString() can be done efficiently.
     *
     *  When there are multiple instructions at the same index, the instructions
     *  must be ordered to ensure proper behavior.  For example, a delete at
     *  index i must kill any replace operation at i.  Insert-before operations
     *  must come before any replace / delete instructions.  If there are
     *  multiple insert instructions for a single index, they are done in
     *  reverse insertion order so that "insert foo" then "insert bar" yields
     *  "foobar" in front rather than "barfoo".  This is convenient because
     *  I can insert new InsertOp instructions at the index returned by
     *  the binary search.  A ReplaceOp kills any previous replace op.  Since
     *  delete is the same as replace with null text, i can check for
     *  ReplaceOp and cover DeleteOp at same time. :)
     */
    addToSortedRewriteList: function() {
        var programName,
            op;
        if (arguments.length===1) {
            programName = trs.DEFAULT_PROGRAM_NAME;
            op = arguments[0];
        } else if (arguments.length===2) {
            programName = arguments[0];
            op = arguments[1];
        }

        var rewrites = this.getProgram(programName);
        var len, pos, searchOp, replaced, prevOp, i;
        for (pos=0, len=rewrites.length; pos<len; pos++) {
            searchOp = rewrites[pos];
            if (searchOp.index===op.index) {
                // now pos is the index in rewrites of first op with op.index

                // an instruction operating already on that index was found;
                // make this one happen after all the others
                if (op instanceof trs.ReplaceOp) {
                    replaced = false;
                    // look for an existing replace
                    for (i=pos; i<rewrites.length; i++) {
                        prevOp = rewrites[pos];
                        if (prevOp.index!==op.index) {
                            break;
                        }
                        if (prevOp instanceof trs.ReplaceOp) {
                            rewrites[pos] = op; // replace old with new
                            replaced=true;
                            break;
                        }
                        // keep going; must be an insert
                    }
                    if ( !replaced ) {
                        // add replace op to the end of all the inserts
                        rewrites.splice(i, 0, op);
                    }
                } else {
                    // inserts are added in front of existing inserts
                    rewrites.splice(pos, 0, op);
                }
                break;
            } else if (searchOp.index > op.index) {
                rewrites.splice(pos, 0, op);
                break;
            }
        }
        if (pos===len) {
            rewrites.push(op);
        }
    },

    insertAfter: function() {
        var index, programName, text;
        if (arguments.length===2) {
            programName = trs.DEFAULT_PROGRAM_NAME;
            index = arguments[0];
            text = arguments[1];
        } else if (arguments.length===3) {
            programName = arguments[0];
            index = arguments[1];
            text = arguments[2];
        }

        if (index instanceof org.antlr.runtime.Token) {
            // index is a Token, grab it's stream index
            index = index.index; // that's ugly
        }

        // insert after is the same as insert before the next index
        this.insertBefore(programName, index+1, text);
    },

    insertBefore: function() {
        var index, programName, text;
        if (arguments.length===2) {
            programName = trs.DEFAULT_PROGRAM_NAME;
            index = arguments[0];
            text = arguments[1];
        } else if (arguments.length===3) {
            programName = arguments[0];
            index = arguments[1];
            text = arguments[2];
        }

        if (index instanceof org.antlr.runtime.Token) {
            // index is a Token, grab it's stream index
            index = index.index; // that's ugly
        }

        this.addToSortedRewriteList(
                programName,
                new trs.InsertBeforeOp(index,text)
                );
    },

    replace: function() {
        var programName, first, last, text;
        if (arguments.length===2) {
            programName = trs.DEFAULT_PROGRAM_NAME;
            first = arguments[0];
            last = arguments[0];
            text = arguments[1];
        } else if (arguments.length===3) {
            programName = trs.DEFAULT_PROGRAM_NAME;
            first = arguments[0];
            last = arguments[1];
            text = arguments[2];
        } if (arguments.length===4) {
            programName = arguments[0];
            first = arguments[1];
            last = arguments[2];
            text = arguments[3];
        } 

        if (first instanceof org.antlr.runtime.Token) {
            first = first.index;
        }

        if (last instanceof org.antlr.runtime.Token) {
            last = last.index; // that's ugly
        }

        if ( first > last || last<0 || first<0 ) {
            return;
        }
        this.addToSortedRewriteList(
                programName,
                new trs.ReplaceOp(first, last, text));
    },

    // !!! API Break: delete is a JS keyword, so using remove instead.
    remove: function() {
        // convert arguments to a real array
        var args=[], i=arguments.length-1;
        while (i>=0) {
            args[i] = arguments[i];
            i--;
        }

        args.push("");
        this.replace.apply(this, args);
    },

    getLastRewriteTokenIndex: function(programName) {
        programName = programName || trs.DEFAULT_PROGRAM_NAME;
        return this.lastRewriteTokenIndexes[programName] || -1;
    },

    setLastRewriteTokenIndex: function(programName, i) {
        this.lastRewriteTokenIndexes[programName] = i;
    },

    getProgram: function(name) {
        var is = this.programs[name];
        if ( !is ) {
            is = this.initializeProgram(name);
        }
        return is;
    },

    initializeProgram: function(name) {
        var is = [];
        this.programs[name] = is;
        return is;
    },

    toOriginalString: function(start, end) {
        if (!org.antlr.lang.isNumber(start)) {
            start = trs.MIN_TOKEN_INDEX;
        }
        if (!org.antlr.lang.isNumber(end)) {
            end = this.size()-1;
        }

        var buf = [], i;
        for (i=start; i>=trs.MIN_TOKEN_INDEX && i<=end && i<this.tokens.length; i++) {
            buf.push(this.get(i).getText());
        }
        return buf.join("");
    },

    toString: function() {
        var programName, start, end;
        if (arguments.length===0) {
            programName = trs.DEFAULT_PROGRAM_NAME;
            start = trs.MIN_TOKEN_INDEX;
            end = this.size() - 1;
        } else if (arguments.length===1) {
            programName = arguments[0];
            start = trs.MIN_TOKEN_INDEX;
            end = this.size() - 1;
        } else if (arguments.length===2) {
            programName = trs.DEFAULT_PROGRAM_NAME;
            start = arguments[0];
            end = arguments[1];
        }

        var rewrites = this.programs[programName];
        if ( !rewrites || rewrites.length===0 ) {
            return this.toOriginalString(start,end);
        }

        /// Index of first rewrite we have not done
        var rewriteOpIndex = 0,
            tokenCursor=start,
            buf = [],
            op;
        while ( tokenCursor>=trs.MIN_TOKEN_INDEX &&
                tokenCursor<=end &&
                tokenCursor<this.tokens.length )
        {
            // execute instructions associated with this token index
            if ( rewriteOpIndex<rewrites.length ) {
                op = rewrites[rewriteOpIndex];

                // skip all ops at lower index
                while (op.index<tokenCursor && rewriteOpIndex<rewrites.length) {
                    rewriteOpIndex++;
                    if ( rewriteOpIndex<rewrites.length ) {
                        op = rewrites[rewriteOpIndex];
                    }
                }

                // while we have ops for this token index, exec them
                while (tokenCursor===op.index && rewriteOpIndex<rewrites.length) {
                    //System.out.println("execute "+op+" at instruction "+rewriteOpIndex);
                    tokenCursor = op.execute(buf);
                    //System.out.println("after execute tokenCursor = "+tokenCursor);
                    rewriteOpIndex++;
                    if ( rewriteOpIndex<rewrites.length ) {
                        op = rewrites[rewriteOpIndex];
                    }
                }
            }
            // dump the token at this index
            if ( tokenCursor<=end ) {
                buf.push(this.get(tokenCursor).getText());
                tokenCursor++;
            }
        }
        // now see if there are operations (append) beyond last token index
        var opi;
        for (opi=rewriteOpIndex; opi<rewrites.length; opi++) {
            op = rewrites[opi];
            if ( op.index>=this.size() ) {
                op.execute(buf); // must be insertions if after last token
            }
        }

        return buf.join("");
    },

    toDebugString: function(start, end) {
        if (!org.antlr.lang.isNumber(start)) {
            start = trs.MIN_TOKEN_INDEX;
        }
        if (!org.antlr.lang.isNumber(end)) {
            end = this.size()-1;
        }

        var buf = [],
            i;
        for (i=start; i>=trs.MIN_TOKEN_INDEX && i<=end && i<this.tokens.length; i++) {
            buf.push(this.get(i));
        }
        return buf.join("");
    }
});

})();


/**
 * A stream of characters created from a JavaScript string that in turn gets
 * fed to a lexer.
 * @class
 * @extends org.antlr.runtime.CharStream
 * @param {String} data the string from which this stream will be created.
 */
org.antlr.runtime.ANTLRStringStream = function(data) {
    /**
     * Location in the stream.
     * Ranges from 0 to (stream length - 1).
     * @private
     * @type Number
     */
    this.p = 0;

    /**
     * The current line in the input.
     * Ranges from 1 to (number of lines).
     * @private
     * @type Number
     */
    this.line = 1;

    /**
     * The index of the character relative to the beginning of the line.
     * Ranges from 0 to (length of line - 1).
     * @private
     * @type Number
     */
    this.charPositionInLine = 0;

    /**
     * Tracks how deep mark() calls are nested
     * @private
     * @type Number
     */
    this.markDepth = 0;

    /**
     * An Array of objects that tracks the stream state
     * values line, charPositionInLine, and p that can change as you
     * move through the input stream.  Indexed from 1..markDepth.
     * A null is kept at index 0.  Created upon first call to mark().
     * @private
     * @type Array
     */
    this.markers = null;

    /**
     * Track the last mark() call result value for use in rewind().
     * @private
     * @type Number
     */
    this.lastMarker = null;

    /**
     * The data being scanned.
     * @private
     * @type String
     */
    this.data = data;

    /**
     * The number of characters in the stream.
     * @private
     * @type Number
     */
    this.n = data.length;
};

org.antlr.lang.extend(org.antlr.runtime.ANTLRStringStream,
                      org.antlr.runtime.CharStream,
/** @lends org.antlr.runtime.ANTLRStringStream.prototype */
{
    /**
     * Reset the stream so that it's in the same state it was
     * when the object was created *except* the data array is not
     * touched.
     */
    reset: function() {
       this.p = 0;
       this.line = 1;
       this.charPositionInLine = 0;
       this.markDepth = 0;
    },

    /**
     * Consume the next character of data in the stream.
     */
    consume: function() {
        if ( this.p < this.n ) {
            this.charPositionInLine++;
            if ( this.data.charAt(this.p)==="\n" ) {
                this.line++;
                this.charPositionInLine=0;
            }
            this.p++;
        }
    },

    /**
     * Get character at current input pointer + i ahead where i=1 is next int.
     * Negative indexes are allowed.  LA(-1) is previous token (token
     * just matched).  LA(-i) where i is before first token should
     * yield -1, invalid char / EOF.
     * @param {Number} i non-zero amount of lookahead or lookback
     * @returns {String|Number} The charcter at the specified position or -1 if
     *      you fell off either end of the stream.
     */
    LA: function(i) {
        if ( i<0 ) {
            i++; // e.g., translate LA(-1) to use offset i=0; then data[p+0-1]
        }

        var new_pos = this.p+i-1;
        if (new_pos>=this.n || new_pos<0) {
            return org.antlr.runtime.CharStream.EOF;
        }
        return this.data.charAt(new_pos);
    },


    /**
     * Return the current input symbol index 0..n where n indicates the
     * last symbol has been read.  The index is the index of char to
     * be returned from LA(1) (i.e. the one about to be consumed).
     * @returns {Number} the index of the current input symbol
     */
    index: function() {
        return this.p;
    },

    /**
     * The length of this stream.
     * @returns {Number} the length of this stream.
     */
    size: function() {
        return this.n;
    },

    /**
     * Tell the stream to start buffering if it hasn't already.  Return
     * current input position, index(), or some other marker so that
     * when passed to rewind() you get back to the same spot.
     * rewind(mark()) should not affect the input cursor.  The Lexer
     * tracks line/col info as well as input index so its markers are
     * not pure input indexes.  Same for tree node streams.
     *
     * <p>Marking is a mechanism for storing the current position of a stream
     * in a stack.  This corresponds with the predictive look-ahead mechanism
     * used in Lexers.</p>
     * @returns {Number} the current size of the mark stack.
     */
    mark: function() {
        if ( !this.markers ) {
            this.markers = [];
            this.markers.push(null); // depth 0 means no backtracking, leave blank
        }
        this.markDepth++;
        var state = null;
        if ( this.markDepth>=this.markers.length ) {
            state = {};
            this.markers.push(state);
        }
        else {
            state = this.markers[this.markDepth];
        }
        state.p = this.p;
        state.line = this.line;
        state.charPositionInLine = this.charPositionInLine;
        this.lastMarker = this.markDepth;
        return this.markDepth;
    },

    /**
     * Rewind to the input position of the last marker.
     * Used currently only after a cyclic DFA and just
     * before starting a sem/syn predicate to get the
     * input position back to the start of the decision.
     * Do not "pop" the marker off the state.  mark(i)
     * and rewind(i) should balance still. It is
     * like invoking rewind(last marker) but it should not "pop"
     * the marker off.  It's like seek(last marker's input position).
     * @param {Number} [m] the index in the mark stack to load instead of the
     *      last.
     */
    rewind: function(m) {
        if (!org.antlr.lang.isNumber(m)) {
            m = this.lastMarker;
        }

        var state = this.markers[m];
        // restore stream state
        this.seek(state.p);
        this.line = state.line;
        this.charPositionInLine = state.charPositionInLine;
        this.release(m);
    },

    /**
     * You may want to commit to a backtrack but don't want to force the
     * stream to keep bookkeeping objects around for a marker that is
     * no longer necessary.  This will have the same behavior as
     * rewind() except it releases resources without the backward seek.
     * This must throw away resources for all markers back to the marker
     * argument.  So if you're nested 5 levels of mark(), and then release(2)
     * you have to release resources for depths 2..5.
     * @param {Number} marker the mark depth above which all mark states will
     *      be released.
     */
    release: function(marker) {
        // unwind any other markers made after m and release m
        this.markDepth = marker;
        // release this marker
        this.markDepth--;
    },

    /**
     * Set the input cursor to the position indicated by index.  This is
     * normally used to seek ahead in the input stream.  No buffering is
     * required to do this unless you know your stream will use seek to
     * move backwards such as when backtracking.
     *
     * <p>This is different from rewind in its multi-directional
     * requirement and in that its argument is strictly an input cursor
     * (index).</p>
     *
     * <p>For char streams, seeking forward must update the stream state such
     * as line number.  For seeking backwards, you will be presumably
     * backtracking using the mark/rewind mechanism that restores state and
     * so this method does not need to update state when seeking backwards.</p>
     *
     * <p>Currently, this method is only used for efficient backtracking using
     * memoization, but in the future it may be used for incremental
     * parsing.</p>
     *
     * <p>The index is 0..n-1.  A seek to position i means that LA(1) will
     * return the ith symbol.  So, seeking to 0 means LA(1) will return the
     * first element in the stream.</p>
     *
     * <p>Esentially this method method moves the input position,
     * {@link #consume}-ing data if necessary.</p>
     *
     * @param {Number} index the position to seek to.
     */
    seek: function(index) {
        if ( index<=this.p ) {
            this.p = index; // just jump; don't update stream state (line, ...)
            return;
        }
        // seek forward, consume until p hits index
        while ( this.p<index ) {
            this.consume();
        }
    },

    /**
     * Retrieve a substring from this stream.
     * @param {Number} start the starting index of the substring (inclusive).
     * @param {Number} stop the last index of the substring (inclusive).
     * @returns {String}
     */
    substring: function(start, stop) {
        return this.data.substr(start,stop-start+1);
    },

    /**
     * Return the current line position in the stream.
     * @returns {Number} the current line position in the stream (1..numlines).
     */
    getLine: function() {
        return this.line;
    },

    /**
     * Get the index of the character relative to the beginning of the line.
     * Ranges from 0 to (length of line - 1).
     * @returns {Number}
     */
    getCharPositionInLine: function() {
        return this.charPositionInLine;
    },

    /**
     * Set the current line in the input stream.
     * This is used internally when performing rewinds.
     * @param {Number} line
     * @private
     */
    setLine: function(line) {
        this.line = line;
    },

    /**
     * Set the index of the character relative to the beginning of the line.
     * Ranges from 0 to (length of line - 1).
     * @param {Number} pos
     * @private
     */
    setCharPositionInLine: function(pos) {
        this.charPositionInLine = pos;
    },

    /** Where are you getting symbols from? Normally, implementations will
     *  pass the buck all the way to the lexer who can ask its input stream
     *  for the file name or whatever.
     */
    getSourceName: function() {
        return null;
    }
});

/**
 * Alias for {@link #LA}.
 * @methodOf org.antlr.runtime.ANTLRStringStream.prototype
 */
org.antlr.runtime.ANTLRStringStream.prototype.LT = org.antlr.runtime.ANTLRStringStream.prototype.LA;


/** 
 * Loads the contents of a file all at once and passes its contents off to
 * {@link org.antlr.runtime.ANTLRStringStream}.
 * Currently this class can only be used in the Rhino JS interpreter.
 * @class
 * @extends org.antlr.runtime.ANTLRStringStream
 * @param {String} fileName path of the file to be loaded
 * @param {String} [encoding] name of the charset used for decoding
 */
org.antlr.runtime.ANTLRFileStream = function(fileName, encoding) {
    this.fileName = fileName;

    // @todo need to add support for other JS interpreters that have file i/o
    // hooks (SpiderMonkey and WSH come to mind).
    var method;
    if (org.antlr.env.ua.rhino) {
        method = "loadFileUsingJava";
    } else {
        throw new Error(
            "ANTLR File I/O is not supported in this JS implementation."
        );
    }

    var data = this[method](fileName, encoding);
    org.antlr.runtime.ANTLRFileStream.superclass.constructor.call(this, data);
};

org.antlr.lang.extend(org.antlr.runtime.ANTLRFileStream,
                  org.antlr.runtime.ANTLRStringStream,
/** @lends org.antlr.runtime.ANTLRFileStream.prototype */{
    /**
     * Get the file path from which the input was loaded.
     * @returns {String} the file path from which the input was loaded
     */
    getSourceName: function() {
        return this.fileName;
    },

    /**
     * Read the file and return its contents as a JS string.
     * @private
     * @param {String} fileName path of the file to be loaded
     * @param {String} [encoding] name of the charset used for decoding
     * @returns {String} the contents of the file
     */
    loadFileUsingJava: function(fileName, encoding) {
        // read the file using Java methods
        var f = new java.io.File(fileName),
            size = f.length(),
            isr,
            fis = new java.io.FileInputStream(f);
        if (encoding) {
            isr = new java.io.InputStreamReader(fis, encoding);
        } else {
            isr = new java.io.InputStreamReader(fis);
        }
        var data = java.lang.reflect.Array.newInstance(java.lang.Character.TYPE, size);
        isr.read(data, 0, size);

        // convert java char array to a javascript string
        return new String(new java.lang.String(data));
    }
});


/** A generic recognizer that can handle recognizers generated from
 *  lexer, parser, and tree grammars.  This is all the parsing
 *  support code essentially; most of it is error recovery stuff and
 *  backtracking.
 *
 *  <p>This class should not be instantiated directly.  Instead, use one of its
 *  subclasses.</p>
 *
 *  @class
 *  @param {org.antlr.runtime.RecognizerSharedState} [state] state object with
 *      which to initialize this recognizer.
 */
org.antlr.runtime.BaseRecognizer = function(state) {
    /** State of a lexer, parser, or tree parser are collected into a state
     *  object so the state can be shared.  This sharing is needed to
     *  have one grammar import others and share same error variables
     *  and other state variables.  It's a kind of explicit multiple
     *  inheritance via delegation of methods and shared state.
     *  @type org.antlr.runtime.RecognizerSharedState
     */
    this.state = state || new org.antlr.runtime.RecognizerSharedState();
};

org.antlr.lang.augmentObject(org.antlr.runtime.BaseRecognizer, {
    /**
     * @memberOf org.antlr.runtime.BaseRecognizer
     * @type Number
     */
    MEMO_RULE_FAILED: -2,

    /**
     * @memberOf org.antlr.runtime.BaseRecognizer
     * @type Number
     */
    MEMO_RULE_UNKNOWN: -1,

    /**
     * @memberOf org.antlr.runtime.BaseRecognizer
     * @type Number
     */
    INITIAL_FOLLOW_STACK_SIZE: 100,

    /**
     * @memberOf org.antlr.runtime.BaseRecognizer
     * @type Number
     */
    MEMO_RULE_FAILED_I: -2,

    /**
     * @memberOf org.antlr.runtime.BaseRecognizer
     * @type Number
     */
    DEFAULT_TOKEN_CHANNEL: org.antlr.runtime.Token.DEFAULT_CHANNEL,

    /**
     * @memberOf org.antlr.runtime.BaseRecognizer
     * @type Number
     */
    HIDDEN: org.antlr.runtime.Token.HIDDEN_CHANNEL,

    /**
     * @memberOf org.antlr.runtime.BaseRecognizer
     * @type String 
     */
    NEXT_TOKEN_RULE_NAME: "nextToken"
});

org.antlr.runtime.BaseRecognizer.prototype = {
    /** Reset the parser's state.  Subclasses must rewinds the input stream */
    reset: function() {
        var i, len;

        // wack everything related to error recovery
        if (!this.state) {
            return; // no shared state work to do
        }
        this.state._fsp = -1;
        this.state.errorRecovery = false;
        this.state.lastErrorIndex = -1;
        this.state.failed = false;
        this.state.syntaxErrors = 0;
        // wack everything related to backtracking and memoization
        this.state.backtracking = 0;
        // wipe cache
        if (this.state.ruleMemo) {
            for (i=0, len=this.state.ruleMemo.length; i<len; i++) {
                this.state.ruleMemo[i] = null;
            }
        }
    },

    /** Match current input symbol against ttype.  Attempt
     *  single token insertion or deletion error recovery.  If
     *  that fails, throw {@link org.antlr.runtime.MismatchedTokenException}.
     *
     *  <p>To turn off single token insertion or deletion error
     *  recovery, override {@link #mismatchRecover} and have it call
     *  plain {@link #mismatch}, which does not recover.  Then any error
     *  in a rule will cause an exception and immediate exit from
     *  rule.  Rule would recover by resynchronizing to the set of
     *  symbols that can follow rule ref.</p>
     *
     *  @param {org.antlr.runtime.IntStream} input input stream to match against.
     *  @param {Number} ttype  input type to match.
     *  @param {org.antlr.runtime.BitSet} [follow] set of tokens that can follow the
     *      matched token.
     *  @returns {Object} the matched symbol
     */
    match: function(input, ttype, follow) {
        var matchedSymbol = this.getCurrentInputSymbol(input);
        if ( input.LA(1)===ttype ) {
            input.consume();
            this.state.errorRecovery = false;
            this.state.failed = false;
            return matchedSymbol;
        }
        if ( this.state.backtracking>0 ) {
            this.state.failed = true;
            return matchedSymbol;
        }
        matchedSymbol = this.recoverFromMismatchedToken(input, ttype, follow);
        return matchedSymbol;
    },

    /**
     * Match any token.
     * @param {org.antlr.runtime.IntStream} input input stream to match against.
     */
    matchAny: function(input) {
        this.state.errorRecovery = false;
        this.state.failed = false;
        input.consume();
    },

    /**
     * Is the following token (LA(2)) the unwanted type (ttype)?
     * @param {org.antlr.runtime.IntStream} input input stream to match against.
     * @param {Number} ttype the undesired token type.
     * @returns {Boolean} true if and only if the following token is the
     *      unwanted type.
     */
    mismatchIsUnwantedToken: function(input, ttype) {
        return input.LA(2)===ttype;
    },

    /**
     * Does the stream appear to be missing a single token?
     * @param {org.antlr.runtime.IntStream} input input stream to match against.
     * @param {org.antlr.runtime.BitSet} [follow] set of tokens that can follow the
     *      matched token.
     * @returns {Boolean} true if and only if it appears that the stream is
     *      missing a single token.
     */
    mismatchIsMissingToken: function(input, follow) {
        if ( !follow ) {
            // we have no information about the follow; we can only consume
            // a single token and hope for the best
            return false;
        }
        // compute what can follow this grammar element reference
        if ( follow.member(org.antlr.runtime.Token.EOR_TOKEN_TYPE) ) {
            var viableTokensFollowingThisRule = this.computeContextSensitiveRuleFOLLOW();
            follow = follow.or(this.viableTokensFollowingThisRule);
            if ( this.state._fsp>=0 ) { // remove EOR if we're not the start symbol
                follow.remove(org.antlr.runtime.Token.EOR_TOKEN_TYPE);
            }
        }
        // if current token is consistent with what could come after set
        // then we know we're missing a token; error recovery is free to
        // "insert" the missing token

        // BitSet cannot handle negative numbers like -1 (EOF) so I leave EOR
        // in follow set to indicate that the fall of the start symbol is
        // in the set (EOF can follow).
        if ( follow.member(input.LA(1)) ||
             follow.member(org.antlr.runtime.Token.EOR_TOKEN_TYPE) )
        {
            return true;
        }
        return false;
    },

    /** Factor out what to do upon token mismatch so tree parsers can behave
     *  differently.  Override and call {@link #mismatchRecover}
     *  to get single token insertion and deletion.
     *
     *  @param {org.antlr.runtime.IntStream} input input stream to match against.
     *  @param {Number} ttype  input type to match.
     *  @param {org.antlr.runtime.BitSet} [follow] set of tokens that can follow the
     *      matched token.
     */
    mismatch: function(input, ttype, follow) {
        if ( this.mismatchIsUnwantedToken(input, ttype) ) {
            throw new org.antlr.runtime.UnwantedTokenException(ttype, input);
        } else if ( this.mismatchIsMissingToken(input, follow) ) {
            throw new org.antlr.runtime.MissingTokenException(ttype, input, null);
        }
        throw new org.antlr.runtime.MismatchedTokenException(ttype, input);
    },

    /** Report a recognition problem.
     *
     *  <p>This method sets errorRecovery to indicate the parser is recovering
     *  not parsing.  Once in recovery mode, no errors are generated.
     *  To get out of recovery mode, the parser must successfully match
     *  a token (after a resync).  So it will go:</p>
     *  <ol>
     *      <li>error occurs</li>
     *      <li>enter recovery mode, report error</li>
     *      <li>consume until token found in resynch set</li>
     *      <li>try to resume parsing</li>
     *      <li>next match() will reset errorRecovery mode</li>
     *  </ol>
     *
     *  <p>If you override, make sure to update this.state.syntaxErrors if you
     *  care about that.</p>
     *  @param {org.antlr.runtime.RecognitionException} e the error to be reported.
     */
    reportError: function(e) {
        // if we've already reported an error and have not matched a token
        // yet successfully, don't report any errors.
        if ( this.state.errorRecovery ) {
            return;
        }
        this.state.syntaxErrors++;
        this.state.errorRecovery = true;

        this.displayRecognitionError(this.getTokenNames(), e);
    },

    /**
     * Assemble recognition error message.
     * @param {Array} tokenNames array of token names (strings).
     * @param {org.antlr.runtime.RecognitionException} e the error to be reported.
     */
    displayRecognitionError: function(tokenNames, e) {
        var hdr = this.getErrorHeader(e),
            msg = this.getErrorMessage(e, tokenNames);
        this.emitErrorMessage(hdr+" "+msg);
    },

    /**
     * Create error header message.  Format is <q>line
     * lineNumber:positionInLine</q>.
     * @param {org.antlr.runtime.RecognitionException} e the error to be reported.
     * @returns {String} The error header.
     */
    getErrorHeader: function(e) {
        /* handle null input */
        if (!org.antlr.lang.isNumber(e.line)) {
            e.line = 0;
        }
        return "line "+e.line+":"+e.charPositionInLine;
    },

    /**
     * Override this method to change where error messages go.
     * Defaults to "alert"-ing the error in browsers and "print"-ing the error
     * in other environments (e.g. Rhino, SpiderMonkey).
     * @param {String} msg the error message to be displayed.
     */
    emitErrorMessage: function(msg) {
        if (typeof(window) != 'undefined' && window.alert) {
            alert(msg);
        } else {
            print(msg);
        }
    },

    /** What error message should be generated for the various
     *  exception types?
     *
     *  <p>Not very object-oriented code, but I like having all error message
     *  generation within one method rather than spread among all of the
     *  exception classes. This also makes it much easier for the exception
     *  handling because the exception classes do not have to have pointers back
     *  to this object to access utility routines and so on. Also, changing
     *  the message for an exception type would be difficult because you
     *  would have to be subclassing exceptions, but then somehow get ANTLR
     *  to make those kinds of exception objects instead of the default.</p>
     *
     *  <p>For grammar debugging, you will want to override this to add
     *  more information such as the stack frame and no viable alts.</p>
     *
     *  <p>Override this to change the message generated for one or more
     *  exception types.</p>
     *
     * @param {Array} tokenNames array of token names (strings).
     * @param {org.antlr.runtime.RecognitionException} e the error to be reported.
     * @returns {String} the error message to be emitted.
     */
    getErrorMessage: function(e, tokenNames) {
        var msg = (e && e.getMessage) ? e.getMessage() : null,
            mte,
            tokenName;
        if ( e instanceof org.antlr.runtime.UnwantedTokenException ) {
            var ute = e;
            tokenName="<unknown>";
            if ( ute.expecting== org.antlr.runtime.Token.EOF ) {
                tokenName = "EOF";
            } else {
                tokenName = tokenNames[ute.expecting];
            }
            msg = "extraneous input "+this.getTokenErrorDisplay(ute.getUnexpectedToken())+
                " expecting "+tokenName;
        }
        else if ( e instanceof org.antlr.runtime.MissingTokenException ) {
            mte = e;
            tokenName="<unknown>";
            if ( mte.expecting== org.antlr.runtime.Token.EOF ) {
                tokenName = "EOF";
            } else {
                tokenName = tokenNames[mte.expecting];
            }
            msg = "missing "+tokenName+" at "+this.getTokenErrorDisplay(e.token);
        }
        else if ( e instanceof org.antlr.runtime.MismatchedTokenException ) {
            mte = e;
            tokenName="<unknown>";
            if ( mte.expecting== org.antlr.runtime.Token.EOF ) {
                tokenName = "EOF";
            }
            else {
                tokenName = tokenNames[mte.expecting];
            }
            msg = "mismatched input "+this.getTokenErrorDisplay(e.token)+
                " expecting "+tokenName;
        }
        else if ( e instanceof org.antlr.runtime.NoViableAltException ) {
            msg = "no viable alternative at input "+this.getTokenErrorDisplay(e.token);
        }
        else if ( e instanceof org.antlr.runtime.EarlyExitException ) {
            msg = "required (...)+ loop did not match anything at input "+
                this.getTokenErrorDisplay(e.token);
        }
        else if ( e instanceof org.antlr.runtime.MismatchedSetException ) {
            msg = "mismatched input "+this.getTokenErrorDisplay(e.token)+
                " expecting set "+e.expecting;
        }
        else if ( e instanceof org.antlr.runtime.MismatchedNotSetException ) {
            msg = "mismatched input "+this.getTokenErrorDisplay(e.token)+
                " expecting set "+e.expecting;
        }
        else if ( e instanceof org.antlr.runtime.FailedPredicateException ) {
            msg = "rule "+e.ruleName+" failed predicate: {"+
                e.predicateText+"}?";
        }
        return msg;
    },

    /** <p>Get number of recognition errors (lexer, parser, tree parser).  Each
     *  recognizer tracks its own number.  So parser and lexer each have
     *  separate count.  Does not count the spurious errors found between
     *  an error and next valid token match.</p>
     *
     *  <p>See also {@link #reportError}()
     *  @returns {Number} number of syntax errors encountered
     */
    getNumberOfSyntaxErrors: function() {
        return this.state.syntaxErrors;
    },

    /** How should a token be displayed in an error message? The default
     *  is to display just the text, but during development you might
     *  want to have a lot of information spit out.  Override in that case
     *  to use t.toString() (which, for CommonToken, dumps everything about
     *  the token).
     * @param {org.antlr.runtime.Token} t token that will be displayed in an error message
     * @return {String} the string representation of the token
     */
    getTokenErrorDisplay: function(t) {
        var s = t.getText();
        if ( !org.antlr.lang.isValue(s) ) {
            if ( t.getType()==org.antlr.runtime.Token.EOF ) {
                s = "<EOF>";
            }
            else {
                s = "<"+t.getType()+">";
            }
        }
        s = s.replace(/\n/g,"\\n");
        s = s.replace(/\r/g,"\\r");
        s = s.replace(/\t/g,"\\t");
        return "'"+s+"'";
    },

    /** Recover from an error found on the input stream.  This is
     *  for NoViableAlt and mismatched symbol exceptions.  If you enable
     *  single token insertion and deletion, this will usually not
     *  handle mismatched symbol exceptions but there could be a mismatched
     *  token that the match() routine could not recover from.
     *  @param {org.antlr.runtime.IntStream} input the intput stream
     *  @param {org.antlr.runtime.RecogntionException} the error found on the input stream
     */
    recover: function(input, re) {
        if ( this.state.lastErrorIndex==input.index() ) {
            // uh oh, another error at same token index; must be a case
            // where LT(1) is in the recovery token set so nothing is
            // consumed; consume a single token so at least to prevent
            // an infinite loop; this is a failsafe.
            input.consume();
        }
        this.state.lastErrorIndex = input.index();
        var followSet = this.computeErrorRecoverySet();
        this.beginResync();
        this.consumeUntil(input, followSet);
        this.endResync();
    },

    /** A hook to listen in on the token consumption during error recovery.
     */
    beginResync: function() {
    },

    /** A hook to listen in on the token consumption during error recovery.
     */
    endResync: function() {
    },

    /** Compute the error recovery set for the current rule.
     *  <p>During rule invocation, the parser pushes the set of tokens that can
     *  follow that rule reference on the stack; this amounts to
     *  computing FIRST of what follows the rule reference in the
     *  enclosing rule. This local follow set only includes tokens
     *  from within the rule; i.e., the FIRST computation done by
     *  ANTLR stops at the end of a rule.</p>
     *
     *  <p>EXAMPLE</p>
     *
     *  <p>When you find a "no viable alt exception", the input is not
     *  consistent with any of the alternatives for rule r.  The best
     *  thing to do is to consume tokens until you see something that
     *  can legally follow a call to r *or* any rule that called r.
     *  You don't want the exact set of viable next tokens because the
     *  input might just be missing a token--you might consume the
     *  rest of the input looking for one of the missing tokens.</p>
     *
     *  <p>Consider grammar:</p>
     *  <code><pre>
     *  a : '[' b ']'
     *    | '(' b ')'
     *    ;
     *  b : c '^' INT ;
     *  c : ID
     *    | INT
     *    ;
     *  </pre></code>
     *
     *  <p>At each rule invocation, the set of tokens that could follow
     *  that rule is pushed on a stack.  Here are the various "local"
     *  follow sets:</p>
     *
     *  <code><pre>
     *  FOLLOW(b1_in_a) = FIRST(']') = ']'
     *  FOLLOW(b2_in_a) = FIRST(')') = ')'
     *  FOLLOW(c_in_b) = FIRST('^') = '^'
     *  </pre></code>
     *
     *  <p>Upon erroneous input "[]", the call chain is</p>
     *
     *  <code>a -> b -> c</code>
     *
     *  <p>and, hence, the follow context stack is:</p>
     *
     *  <code><pre>
     *  depth  local follow set     after call to rule
     *    0         <EOF>                    a (from main())
     *    1          ']'                     b
     *    3          '^'                     c
     *  </pre></code>
     *
     *  <p>Notice that ')' is not included, because b would have to have
     *  been called from a different context in rule a for ')' to be
     *  included.</p>
     *
     *  <p>For error recovery, we cannot consider FOLLOW(c)
     *  (context-sensitive or otherwise).  We need the combined set of
     *  all context-sensitive FOLLOW sets--the set of all tokens that
     *  could follow any reference in the call chain.  We need to
     *  resync to one of those tokens.  Note that FOLLOW(c)='^' and if
     *  we resync'd to that token, we'd consume until EOF.  We need to
     *  sync to context-sensitive FOLLOWs for a, b, and c: {']','^'}.
     *  In this case, for input "[]", LA(1) is in this set so we would
     *  not consume anything and after printing an error rule c would
     *  return normally.  It would not find the required '^' though.
     *  At this point, it gets a mismatched token error and throws an
     *  exception (since LA(1) is not in the viable following token
     *  set).  The rule exception handler tries to recover, but finds
     *  the same recovery set and doesn't consume anything.  Rule b
     *  exits normally returning to rule a.  Now it finds the ']' (and
     *  with the successful match exits errorRecovery mode).</p>
     *
     *  <p>So, you cna see that the parser walks up call chain looking
     *  for the token that was a member of the recovery set.</p>
     *
     *  <p>Errors are not generated in errorRecovery mode.</p>
     *
     *  <p>ANTLR's error recovery mechanism is based upon original ideas:</p>
     *
     *  <p>"Algorithms + Data Structures = Programs" by Niklaus Wirth</p>
     *
     *  <p>and</p>
     *
     *  <p>"A note on error recovery in recursive descent parsers":
     *  http://portal.acm.org/citation.cfm?id=947902.947905</p>
     *
     *  <p>Later, Josef Grosch had some good ideas:</p>
     *
     *  <p>"Efficient and Comfortable Error Recovery in Recursive Descent
     *  Parsers":
     *  ftp://www.cocolab.com/products/cocktail/doca4.ps/ell.ps.zip</p>
     *
     *  <p>Like Grosch I implemented local FOLLOW sets that are combined
     *  at run-time upon error to avoid overhead during parsing.</p>
     *  @returns {org.antlr.runtime.BitSet}
     */
    computeErrorRecoverySet: function() {
        return this.combineFollows(false);
    },


    /** Compute the context-sensitive FOLLOW set for current rule.
     *  <p>This is set of token types that can follow a specific rule
     *  reference given a specific call chain.  You get the set of
     *  viable tokens that can possibly come next (lookahead depth 1)
     *  given the current call chain.  Contrast this with the
     *  definition of plain FOLLOW for rule r:</p>
     *
     *   <code>FOLLOW(r)={x | S=>*alpha r beta in G and x in FIRST(beta)}</code>
     *
     *  <p>where x in T* and alpha, beta in V*; T is set of terminals and
     *  V is the set of terminals and nonterminals.  In other words,
     *  FOLLOW(r) is the set of all tokens that can possibly follow
     *  references to r in *any* sentential form (context).  At
     *  runtime, however, we know precisely which context applies as
     *  we have the call chain.  We may compute the exact (rather
     *  than covering superset) set of following tokens.</p>
     *
     *  <p>For example, consider grammar:</p>
     *
     *  <code><pre>
     *  stat : ID '=' expr ';'      // FOLLOW(stat)=={EOF}
     *       | "return" expr '.'
     *       ;
     *  expr : atom ('+' atom)* ;   // FOLLOW(expr)=={';','.',')'}
     *  atom : INT                  // FOLLOW(atom)=={'+',')',';','.'}
     *       | '(' expr ')'
     *       ;
     *  </pre></code>
     *
     *  <p>The FOLLOW sets are all inclusive whereas context-sensitive
     *  FOLLOW sets are precisely what could follow a rule reference.
     *  For input input "i=(3);", here is the derivation:</p>
     *
     *  <code><pre>
     *  stat => ID '=' expr ';'
     *       => ID '=' atom ('+' atom)* ';'
     *       => ID '=' '(' expr ')' ('+' atom)* ';'
     *       => ID '=' '(' atom ')' ('+' atom)* ';'
     *       => ID '=' '(' INT ')' ('+' atom)* ';'
     *       => ID '=' '(' INT ')' ';'
     *  </pre></code>
     *
     *  <p>At the "3" token, you'd have a call chain of</p>
     *
     *  <code>  stat -> expr -> atom -> expr -> atom</code>
     *
     *  <p>What can follow that specific nested ref to atom?  Exactly ')'
     *  as you can see by looking at the derivation of this specific
     *  input.  Contrast this with the FOLLOW(atom)={'+',')',';','.'}.</p>
     *
     *  <p>You want the exact viable token set when recovering from a
     *  token mismatch.  Upon token mismatch, if LA(1) is member of
     *  the viable next token set, then you know there is most likely
     *  a missing token in the input stream.  "Insert" one by just not
     *  throwing an exception.</p>
     *  @returns {org.antlr.runtime.BitSet}
     */
    computeContextSensitiveRuleFOLLOW: function() {
        return this.combineFollows(true);
    },

    /**
     * Helper method for {@link #computeErrorRecoverySet} and
     * {@link computeContextSensitiveRuleFOLLO}.
     * @param {Boolean} exact
     * @returns {org.antlr.runtime.BitSet}
     */
    combineFollows: function(exact) {
        var top = this.state._fsp,
            i,
            localFollowSet,
            followSet = new org.antlr.runtime.BitSet();
        for (i=top; i>=0; i--) {
            localFollowSet = this.state.following[i];
            followSet.orInPlace(localFollowSet);
            if ( exact ) {
                // can we see end of rule?
                if ( localFollowSet.member(org.antlr.runtime.Token.EOR_TOKEN_TYPE) )
                {
                    // Only leave EOR in set if at top (start rule); this lets
                    // us know if have to include follow(start rule); i.e., EOF
                    if ( i>0 ) {
                        followSet.remove(org.antlr.runtime.Token.EOR_TOKEN_TYPE);
                    }
                }
                else { // can't see end of rule, quit
                    break;
                }
            }
        }
        return followSet;
    },

    /** Attempt to recover from a single missing or extra token.
     *
     *  <p>EXTRA TOKEN</p>
     *
     *  <p>LA(1) is not what we are looking for.  If LA(2) has the right token,
     *  however, then assume LA(1) is some extra spurious token.  Delete it
     *  and LA(2) as if we were doing a normal match(), which advances the
     *  input.</p>
     *
     *  <p>MISSING TOKEN</p>
     *
     *  <p>If current token is consistent with what could come after
     *  ttype then it is ok to "insert" the missing token, else throw
     *  exception For example, Input "i=(3;" is clearly missing the
     *  ')'.  When the parser returns from the nested call to expr, it
     *  will have call chain:</p>
     *
     *  <pre><code>  stat -> expr -> atom</code></pre>
     *
     *  <p>and it will be trying to match the ')' at this point in the
     *  derivation:</p>
     *
     *  <pre><code>     => ID '=' '(' INT ')' ('+' atom)* ';'</code></pre>
     *                          ^
     *  <p>match() will see that ';' doesn't match ')' and report a
     *  mismatched token error.  To recover, it sees that LA(1)==';'
     *  is in the set of tokens that can follow the ')' token
     *  reference in rule atom.  It can assume that you forgot the ')'.</p>
     *
     *  @param {org.antlr.runtime.IntStream} input
     *  @param {Number} ttype
     *  @param {org.antlr.runtime.BitSet} follow
     *  @returns {Object}
     */
    recoverFromMismatchedToken: function(input,
                                         ttype,
                                         follow)
    {
        var e = null;
        // if next token is what we are looking for then "delete" this token
        if ( this.mismatchIsUnwantedToken(input, ttype) ) {
            e = new org.antlr.runtime.UnwantedTokenException(ttype, input);
            this.beginResync();
            input.consume(); // simply delete extra token
            this.endResync();
            this.reportError(e);  // report after consuming so AW sees the token in the exception
            // we want to return the token we're actually matching
            var matchedSymbol = this.getCurrentInputSymbol(input);
            input.consume(); // move past ttype token as if all were ok
            return matchedSymbol;
        }
        // can't recover with single token deletion, try insertion
        if ( this.mismatchIsMissingToken(input, follow) ) {
            var inserted = this.getMissingSymbol(input, e, ttype, follow);
            e = new org.antlr.runtime.MissingTokenException(ttype, input, inserted);
            this.reportError(e);  // report after inserting so AW sees the token in the exception
            return inserted;
        }
        // even that didn't work; must throw the exception
        e = new org.antlr.runtime.MismatchedTokenException(ttype, input);
        throw e;
    },

    /**
     * Recover from a mismatched set exception.
     * @param {org.antlr.runtime.IntStream} input
     * @param {org.antlr.runtime.RecognitionException} e
     * @param {org.antlr.runtime.BitSet} follow
     * @returns {Object}
     */
    recoverFromMismatchedSet: function(input,
                                       e,
                                       follow)
    {
        if ( this.mismatchIsMissingToken(input, follow) ) {
            // System.out.println("missing token");
            this.reportError(e);
            // we don't know how to conjure up a token for sets yet
            return this.getMissingSymbol(input, e, org.antlr.runtime.Token.INVALID_TOKEN_TYPE, follow);
        }
        throw e;
    },

    /** Match needs to return the current input symbol, which gets put
     *  into the label for the associated token ref; e.g., x=ID.  Token
     *  and tree parsers need to return different objects. Rather than test
     *  for input stream type or change the IntStream interface, I use
     *  a simple method to ask the recognizer to tell me what the current
     *  input symbol is.
     * 
     *  <p>This is ignored for lexers.</p>
     *  @param {org.antlr.runtime.IntStream} input
     *  @returns {Object}
     */
    getCurrentInputSymbol: function(input) { return null; },

    /** Conjure up a missing token during error recovery.
     *
     *  <p>The recognizer attempts to recover from single missing
     *  symbols. But, actions might refer to that missing symbol.
     *  For example, x=ID {f($x);}. The action clearly assumes
     *  that there has been an identifier matched previously and that
     *  $x points at that token. If that token is missing, but
     *  the next token in the stream is what we want we assume that
     *  this token is missing and we keep going. Because we
     *  have to return some token to replace the missing token,
     *  we have to conjure one up. This method gives the user control
     *  over the tokens returned for missing tokens. Mostly,
     *  you will want to create something special for identifier
     *  tokens. For literals such as '{' and ',', the default
     *  action in the parser or tree parser works. It simply creates
     *  a CommonToken of the appropriate type. The text will be the token.
     *  If you change what tokens must be created by the lexer,
     *  override this method to create the appropriate tokens.</p>
     *
     *  @param {org.antlr.runtime.IntStream} input
     *  @param {org.antlr.runtime.RecognitionException} e
     *  @param {Number} expectedTokenType
     *  @param {org.antlr.runtime.BitSet} follow
     *  @returns {Object}
     */
    getMissingSymbol: function(input,
                               e,
                               expectedTokenType,
                               follow)
    {
        return null;
    },


    /**
     * Consume tokens until one matches the given token or token set
     * @param {org.antlr.runtime.IntStream} input
     * @param {Number|org.antlr.runtime.BitSet} set
     */
    consumeUntil: function(input, set) {
        var ttype = input.LA(1);
        while (ttype != org.antlr.runtime.Token.EOF && !set.member(ttype) ) {
            input.consume();
            ttype = input.LA(1);
        }
    },

    /**
     * Push a rule's follow set using our own hardcoded stack.
     * @param {org.antlr.runtime.BitSet} fset
     */
    pushFollow: function(fset) {
        if ( (this.state._fsp +1)>=this.state.following.length ) {
            var f = [];
            var i;
            for (i=this.state.following.length-1; i>=0; i--) {
                f[i] = this.state.following[i];
            }
            this.state.following = f;
        }
        this.state._fsp++;
        this.state.following[this.state._fsp] = fset;
    },

    /**
     * Sadly JavaScript doesn't provide a robust mechanism for runtime stack reflection.
     * This makes implementing this function impossible without maintaining an auxillary
     * stack data structure, which would be crazy expensive, especially in Lexers.  As such,
     * this method remains unimplemented.
     * @deprecated
     */
    getRuleInvocationStack: function(e, recognizerClassName)
    {
        throw new Error("Not implemented.");
    },

    /**
     * Get this recognizer's backtracking level.
     * @returns {Number} backtracking level
     */
    getBacktrackingLevel: function() {
        return this.state.backtracking;
    },

    /** Used to print out token names like ID during debugging and
     *  error reporting.  The generated parsers implement a method
     *  that overrides this to point to their String[] tokenNames.
     *  @returns {Array} String array of token names.
     */
    getTokenNames: function() {
        return null;
    },

    /** For debugging and other purposes, might want the grammar name.
     *  Have ANTLR generate an implementation for this method.
     *  @returns {String} the grammar name.
     */
    getGrammarFileName: function() {
        return null;
    },

    /** A convenience method for use most often with template rewrites.
     *  Convert an array of Tokens to an array of Strings.
     *  @param {Array} array of org.antlr.runtime.Token objects.
     *  @returns {Array} array of string representations of the argument.
     */
    toStrings: function(tokens) {
        if ( !tokens ) {
            return null;
        }
        var strings = [];
        var i;
        for (i=0; i<tokens.length; i++) {
            strings.push(tokens[i].getText());
        }
        return strings;
    },

    /** Given a rule number and a start token index number, return
     *  MEMO_RULE_UNKNOWN if the rule has not parsed input starting from
     *  start index.  If this rule has parsed input starting from the
     *  start index before, then return where the rule stopped parsing.
     *  It returns the index of the last token matched by the rule.
     *
     *  <p>For now we use a hashtable and just the slow Object-based one.
     *  Later, we can make a special one for ints and also one that
     *  tosses out data after we commit past input position i.</p>
     *  @param {Number} ruleIndex
     *  @param {Number} ruleStartIndex
     *  @returns {Number}
     */
    getRuleMemoization: function(ruleIndex, ruleStartIndex) {
        if ( !this.state.ruleMemo[ruleIndex] ) {
            this.state.ruleMemo[ruleIndex] = {};
        }
        var stopIndexI =
            this.state.ruleMemo[ruleIndex][ruleStartIndex];
        if ( !org.antlr.lang.isNumber(stopIndexI) ) {
            return org.antlr.runtime.BaseRecognizer.MEMO_RULE_UNKNOWN;
        }
        return stopIndexI;
    },

    /** Has this rule already parsed input at the current index in the
     *  input stream?  Return the stop token index or MEMO_RULE_UNKNOWN.
     *  If we attempted but failed to parse properly before, return
     *  MEMO_RULE_FAILED.
     *
     *  <p>This method has a side-effect: if we have seen this input for
     *  this rule and successfully parsed before, then seek ahead to
     *  1 past the stop token matched for this rule last time.</p>
     *  @param {org.antlr.runtime.IntStream} input
     *  @param {Number} ruleIndex
     *  @returns {Boolean}
     */
    alreadyParsedRule: function(input, ruleIndex) {
        var stopIndex = this.getRuleMemoization(ruleIndex, input.index());
        if ( stopIndex==org.antlr.runtime.BaseRecognizer.MEMO_RULE_UNKNOWN ) {
            return false;
        }
        if ( stopIndex==org.antlr.runtime.BaseRecognizer.MEMO_RULE_FAILED ) {
            //System.out.println("rule "+ruleIndex+" will never succeed");
            this.state.failed=true;
        }
        else {
            input.seek(stopIndex+1); // jump to one past stop token
        }
        return true;
    },

    /** Record whether or not this rule parsed the input at this position
     *  successfully.  Use a standard java hashtable for now.
     *  @param {org.antlr.runtime.IntStream} input
     *  @param {Number} ruleIndex
     *  @param {Number} ruleStartIndex
     */
    memoize: function(input,
                      ruleIndex,
                      ruleStartIndex)
    {
        var stopTokenIndex = this.state.failed ? 
            org.antlr.runtime.BaseRecognizer.MEMO_RULE_FAILED : input.index()-1;
        if ( !org.antlr.lang.isValue(this.state.ruleMemo) ) {
            throw new Error("!!!!!!!!! memo array is null for "+ this.getGrammarFileName());
        }
        if ( ruleIndex >= this.state.ruleMemo.length ) {
            throw new Error("!!!!!!!!! memo size is "+this.state.ruleMemo.length+", but rule index is "+ruleIndex);
        }
        if ( org.antlr.lang.isValue(this.state.ruleMemo[ruleIndex]) ) {
            this.state.ruleMemo[ruleIndex][ruleStartIndex] = stopTokenIndex;
        }
    },

    /** return how many rule/input-index pairs there are in total.
     *  TODO: this includes synpreds.
     *  @returns {Number}
     */
    getRuleMemoizationCacheSize: function() {
        var n = 0, i;
        for (i = 0; this.state.ruleMemo && i < this.state.ruleMemo.length; i++) {
            var ruleMap = this.state.ruleMemo[i];
            if ( ruleMap ) {
                // @todo need to get size of rulemap?
                n += ruleMap.length; // how many input indexes are recorded?
            }
        }
        return n;
    },

    /**
     * When a grammar is compiled with the tracing flag enabled, this method is invoked
     * at the start of each rule.
     * @param {String} ruleName the current ruleName
     * @param {Number} ruleIndex
     * @param {Object} inputSymbol
     */
    traceIn: function(ruleName, ruleIndex, inputSymbol)  {
        this.emitErrorMessage("enter "+ruleName+" "+inputSymbol);
        if ( this.state.failed ) {
            this.emitErrorMessage(" failed="+this.failed);
        }
        if ( this.state.backtracking>0 ) {
            this.emitErrorMessage(" backtracking="+this.state.backtracking);
        }
        // System.out.println();
    },

    /**
     * When a grammar is compiled with the tracing flag enabled, this method is invoked
     * at the end of each rule.
     * @param {String} ruleName the current ruleName
     * @param {Number} ruleIndex
     * @param {Object} inputSymbol
     */
    traceOut: function(ruleName, ruleIndex, inputSymbol) {
        this.emitErrorMessage("exit "+ruleName+" "+inputSymbol);
        if ( this.state.failed ) {
            this.emitErrorMessage(" failed="+this.state.failed);
        }
        if ( this.state.backtracking>0 ) {
            this.emitErrorMessage(" backtracking="+this.state.backtracking);
        }
    }
};


/** A lexer is recognizer that draws input symbols from a character stream.
 *  lexer grammars result in a subclass of this object. A Lexer object
 *  uses simplified match() and error recovery mechanisms in the interest
 *  of speed.
 */
org.antlr.runtime.Lexer = function(input, state) {
    if (state) {
        org.antlr.runtime.Lexer.superclass.constructor.call(this, state);
    }
    if (input) {
        this.input = input;
    }
};

org.antlr.lang.extend(org.antlr.runtime.Lexer, org.antlr.runtime.BaseRecognizer, {
    reset: function() {
        // reset all recognizer state variables
        org.antlr.runtime.Lexer.superclass.reset.call(this);
        if ( org.antlr.lang.isValue(this.input) ) {
            this.input.seek(0); // rewind the input
        }
        if ( !org.antlr.lang.isValue(this.state) ) {
            return; // no shared state work to do
        }
        this.state.token = null;
        this.state.type = org.antlr.runtime.Token.INVALID_TOKEN_TYPE;
        this.state.channel = org.antlr.runtime.Token.DEFAULT_CHANNEL;
        this.state.tokenStartCharIndex = -1;
        this.state.tokenStartCharPositionInLine = -1;
        this.state.tokenStartLine = -1;
        this.state.text = null;
    },

    /** Return a token from this source; i.e., match a token on the char
     *  stream.
     */
    nextToken: function() {
        while (true) {
            this.state.token = null;
            this.state.channel = org.antlr.runtime.Token.DEFAULT_CHANNEL;
            this.state.tokenStartCharIndex = this.input.index();
            this.state.tokenStartCharPositionInLine = this.input.getCharPositionInLine();
            this.state.tokenStartLine = this.input.getLine();
            this.state.text = null;
            if ( this.input.LA(1)===org.antlr.runtime.CharStream.EOF ) {
                return org.antlr.runtime.Token.EOF_TOKEN;
            }
            try {
                this.mTokens();
                if ( !org.antlr.lang.isValue(this.state.token) ) {
                    this.emit();
                }
                else if ( this.state.token==org.antlr.runtime.Token.SKIP_TOKEN ) {
                    continue;
                }
                return this.state.token;
            }
            catch (re) {
                if (re instanceof org.antlr.runtime.NoViableAltException) {
                    this.reportError(re);
                    this.recover(re);
                } else if ( re instanceof org.antlr.runtime.RecognitionException ) {
                    this.reportError(re);
                } else {
                    throw re;
                }
            }
        }
    },

    /** Instruct the lexer to skip creating a token for current lexer rule
     *  and look for another token.  nextToken() knows to keep looking when
     *  a lexer rule finishes with token set to SKIP_TOKEN.  Recall that
     *  if token==null at end of any token rule, it creates one for you
     *  and emits it.
     */
    skip: function() {
        this.state.token = org.antlr.runtime.Token.SKIP_TOKEN;
    },

    /** Set the char stream and reset the lexer */
    setCharStream: function(input) {
        this.input = null;
        this.reset();
        this.input = input;
    },

    getCharStream: function() {
        return this.input;
    },

    getSourceName: function() {
        return this.input.getSourceName();
    },

    /** Currently does not support multiple emits per nextToken invocation
     *  for efficiency reasons.  Subclass and override this method and
     *  nextToken (to push tokens into a list and pull from that list rather
     *  than a single variable as this implementation does).
     *
     *  The standard method called to automatically emit a token at the
     *  outermost lexical rule.  The token object should point into the
     *  char buffer start..stop.  If there is a text override in 'text',
     *  use that to set the token's text.  Override this method to emit
     *  custom Token objects.
     *
     *  If you are building trees, then you should also override
     *  Parser or TreeParser.getMissingSymbol().
     */
    emit: function() {
        if (arguments.length===0) {
            var t = new org.antlr.runtime.CommonToken(this.input, this.state.type, this.state.channel, this.state.tokenStartCharIndex, this.getCharIndex()-1);
            t.setLine(this.state.tokenStartLine);
            t.setText(this.state.text);
            t.setCharPositionInLine(this.state.tokenStartCharPositionInLine);
            this.state.token = t;
            return t;
        } else {
            this.state.token = arguments[0];
        }
    },

    match: function(s) {
        var i = 0,
            mte;

        if (org.antlr.lang.isString(s)) {
            while ( i<s.length ) {
                if ( this.input.LA(1)!=s.charAt(i) ) {
                    if ( this.state.backtracking>0 ) {
                        this.state.failed = true;
                        return;
                    }
                    mte = new org.antlr.runtime.MismatchedTokenException(s.charAt(i), this.input);
                    this.recover(mte);
                    throw mte;
                }
                i++;
                this.input.consume();
                this.state.failed = false;
            }
        } else if (org.antlr.lang.isNumber(s)) {
            if ( this.input.LA(1)!=s ) {
                if ( this.state.backtracking>0 ) {
                    this.state.failed = true;
                    return;
                }
                mte = new org.antlr.runtime.MismatchedTokenException(s, this.input);
                this.recover(mte);
                throw mte;
            }
            this.input.consume();
            this.state.failed = false;
        }
    },

    matchAny: function() {
        this.input.consume();
    },

    matchRange: function(a, b) {
        if ( this.input.LA(1)<a || this.input.LA(1)>b ) {
            if ( this.state.backtracking>0 ) {
                this.state.failed = true;
                return;
            }
            var mre = new org.antlr.runtime.MismatchedRangeException(a,b,this.input);
            this.recover(mre);
            throw mre;
        }
        this.input.consume();
        this.state.failed = false;
    },

    getLine: function() {
        return this.input.getLine();
    },

    getCharPositionInLine: function() {
        return this.input.getCharPositionInLine();
    },

    /** What is the index of the current character of lookahead? */
    getCharIndex: function() {
        return this.input.index();
    },

    /** Return the text matched so far for the current token or any
     *  text override.
     */
    getText: function() {
        if ( org.antlr.lang.isString(this.state.text) ) {
            return this.state.text;
        }
        return this.input.substring(this.state.tokenStartCharIndex,this.getCharIndex()-1);
    },

    /** Set the complete text of this token; it wipes any previous
     *  changes to the text.
     */
    setText: function(text) {
        this.state.text = text;
    },

    reportError: function(e) {
        /** TODO: not thought about recovery in lexer yet.
         *
        // if we've already reported an error and have not matched a token
        // yet successfully, don't report any errors.
        if ( errorRecovery ) {
            //System.err.print("[SPURIOUS] ");
            return;
        }
        errorRecovery = true;
         */

        this.displayRecognitionError(this.getTokenNames(), e);
    },

    getErrorMessage: function(e, tokenNames) {
        var msg = null;
        if ( e instanceof org.antlr.runtime.MismatchedTokenException ) {
            msg = "mismatched character "+this.getCharErrorDisplay(e.c)+" expecting "+this.getCharErrorDisplay(e.expecting);
        }
        else if ( e instanceof org.antlr.runtime.NoViableAltException ) {
            msg = "no viable alternative at character "+this.getCharErrorDisplay(e.c);
        }
        else if ( e instanceof org.antlr.runtime.EarlyExitException ) {
            msg = "required (...)+ loop did not match anything at character "+this.getCharErrorDisplay(e.c);
        }
        else if ( e instanceof org.antlr.runtime.MismatchedNotSetException ) {
            msg = "mismatched character "+this.getCharErrorDisplay(e.c)+" expecting set "+e.expecting;
        }
        else if ( e instanceof org.antlr.runtime.MismatchedSetException ) {
            msg = "mismatched character "+this.getCharErrorDisplay(e.c)+" expecting set "+e.expecting;
        }
        else if ( e instanceof org.antlr.runtime.MismatchedRangeException ) {
            msg = "mismatched character "+this.getCharErrorDisplay(e.c)+" expecting set "+
                this.getCharErrorDisplay(e.a)+".."+this.getCharErrorDisplay(e.b);
        }
        else {
            msg = org.antlr.runtime.Lexer.superclass.getErrorMessage.call(this, e, tokenNames);
        }
        return msg;
    },

    getCharErrorDisplay: function(c) {
        var s = c; //String.fromCharCode(c);
        switch ( s ) {
            case org.antlr.runtime.Token.EOF :
                s = "<EOF>";
                break;
            case "\n" :
                s = "\\n";
                break;
            case "\t" :
                s = "\\t";
                break;
            case "\r" :
                s = "\\r";
                break;
        }
        return "'"+s+"'";
    },

    /** Lexers can normally match any char in it's vocabulary after matching
     *  a token, so do the easy thing and just kill a character and hope
     *  it all works out.  You can instead use the rule invocation stack
     *  to do sophisticated error recovery if you are in a fragment rule.
     */
    recover: function(re) {
        this.input.consume();
    },

    traceIn: function(ruleName, ruleIndex)  {
        var inputSymbol = String.fromCharCode(this.input.LT(1))+" line="+this.getLine()+":"+this.getCharPositionInLine();
        org.antlr.runtime.Lexer.superclass.traceIn.call(this, ruleName, ruleIndex, inputSymbol);
    },

    traceOut: function(ruleName, ruleIndex)  {
		var inputSymbol = String.fromCharCode(this.input.LT(1))+" line="+this.getLine()+":"+this.getCharPositionInLine();
		org.antlr.runtime.Lexer.superclass.traceOut.call(this, ruleName, ruleIndex, inputSymbol);
	}
});


/** A DFA implemented as a set of transition tables.
 *
 *  Any state that has a semantic predicate edge is special; those states
 *  are generated with if-then-else structures in a specialStateTransition()
 *  which is generated by cyclicDFA template.
 *
 *  There are at most 32767 states (16-bit signed short).
 *  Could get away with byte sometimes but would have to generate different
 *  types and the simulation code too.  For a point of reference, the Java
 *  lexer's Tokens rule DFA has 326 states roughly.
 */
org.antlr.runtime.DFA = function() {};

org.antlr.runtime.DFA.prototype = {
    /** From the input stream, predict what alternative will succeed
     *  using this DFA (representing the covering regular approximation
     *  to the underlying CFL).  Return an alternative number 1..n.  Throw
     *  an exception upon error.
     */
    predict: function(input) {
        var mark = input.mark(), // remember where decision started in input
            s = 0, // we always start at s0
            specialState,
            c,
            snext;

        try {
            while ( true ) {
                specialState = this.special[s];
                if ( specialState>=0 ) {
                    s = this.specialStateTransition(specialState,input);
                    if (s===-1) {
                        this.noViableAlt(s, input);
                        return 0;
                    }
                    input.consume();
                    continue;
                }
                if ( this.accept[s] >= 1 ) {
                    return this.accept[s];
                }
                // look for a normal char transition
                c = input.LA(1); // -1 == \uFFFF, all tokens fit in 65000 space

                if (c===org.antlr.runtime.Token.EOF) {
                    c = -1;
                } else if (org.antlr.lang.isString(c)) {
                    c = c.charCodeAt(0);
                }

                if (c>=this.min[s] && c<=this.max[s]) {
                    snext = this.transition[s][c-this.min[s]]; // move to next state
                    if ( snext < 0 ) {
                        // was in range but not a normal transition
                        // must check EOT, which is like the else clause.
                        // eot[s]>=0 indicates that an EOT edge goes to another
                        // state.
                        if ( this.eot[s]>=0 ) {  // EOT Transition to accept state?
                            s = this.eot[s];
                            input.consume();
                            // TODO: I had this as return accept[eot[s]]
                            // which assumed here that the EOT edge always
                            // went to an accept...faster to do this, but
                            // what about predicated edges coming from EOT
                            // target?
                            continue;
                        }
                        this.noViableAlt(s,input);
                        return 0;
                    }
                    s = snext;
                    input.consume();
                    continue;
                }
                if ( this.eot[s]>=0 ) {  // EOT Transition?
                    s = this.eot[s];
                    input.consume();
                    continue;
                }
                if ( c==org.antlr.runtime.Token.EOF && this.eof[s]>=0 ) {  // EOF Transition to accept state?
                    return this.accept[this.eof[s]];
                }
                // not in range and not EOF/EOT, must be invalid symbol
                this.noViableAlt(s,input);
                return 0;
            }
        }
        finally {
            input.rewind(mark);
        }
    },

    noViableAlt: function(s, input) {
        if (this.recognizer.state.backtracking>0) {
            this.recognizer.state.failed=true;
            return;
        }
        var nvae =
            new org.antlr.runtime.NoViableAltException(this.getDescription(),
                                     this.decisionNumber,
                                     s,
                                     input);
        this.error(nvae);
        throw nvae;
    },

    /** A hook for debugging interface */
    error: function(nvae) { },

    specialStateTransition: function(s, input) {
        return -1;
    },

    getDescription: function() {
        return "n/a";
    }
};

org.antlr.lang.augmentObject(org.antlr.runtime.DFA, {
    /** Given a String that has a run-length-encoding of some unsigned shorts
     *  like "\1\2\3\9", convert to short[] {2,9,9,9}.
     */
    unpackEncodedString: function(encodedString) {
        // walk first to find how big it is.
        var i,
            data = [],
            di = 0,
            n,
            v,
            j;
        for (i=0; i<encodedString.length; i+=2) {
            n = encodedString.charCodeAt(i);
            v = encodedString.charCodeAt(i+1);
            if (v===0xffff) {
                v = -1; // overflow at 16 bits
            }
            // add v n times to data
            for (j=1; j<=n; j++) {
                data[di++] = v;
            }
        }
        return data;
    },

    // alias
    unpackEncodedStringToUnsignedChars: function(encodedString) {
        return org.antlr.runtime.DFA.unpackEncodedString(encodedString);
    }
});


/** A parser for TokenStreams.  "parser grammars" result in a subclass
 *  of this.
 */
org.antlr.runtime.Parser = function(input, state) {
    org.antlr.runtime.Parser.superclass.constructor.call(this, state);
    this.setTokenStream(input);
};

org.antlr.lang.extend(org.antlr.runtime.Parser, org.antlr.runtime.BaseRecognizer, {
    reset: function() {
        // reset all recognizer state variables
		org.antlr.runtime.Parser.superclass.reset.call(this);
		if ( org.antlr.lang.isValue(this.input) ) {
			this.input.seek(0); // rewind the input
		}
	},

    getCurrentInputSymbol: function(input) {
        return input.LT(1);
    },

    getMissingSymbol: function(input,
                               e,
                               expectedTokenType,
                               follow)
    {
        var tokenText =
            "<missing "+this.getTokenNames()[expectedTokenType]+">";
        var t = new org.antlr.runtime.CommonToken(expectedTokenType, tokenText);
        var current = input.LT(1);
        var old_current;
        if ( current.getType() === org.antlr.runtime.Token.EOF ) {
            old_current = current;
            current = input.LT(-1);
            // handle edge case where there are no good tokens in the stream
            if (!current) {
                current = old_current;
            }
        }
        t.line = current.getLine();
        t.charPositionInLine = current.getCharPositionInLine();
        t.channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
        return t;
    },


	/** Set the token stream and reset the parser */
    setTokenStream: function(input) {
		this.input = null;
		this.reset();
		this.input = input;
	},

    getTokenStream: function() {
		return this.input;
	},

    getSourceName: function() {
        return this.input.getSourceName();
    },

    traceIn: function(ruleName, ruleIndex)  {
		org.antlr.runtime.Parser.superclass.traceIn.call(
                this, ruleName, ruleIndex, this.input.LT(1));
	},

    traceOut: function(ruleName, ruleIndex)  {
		org.antlr.runtime.Parser.superclass.traceOut.call(
                this, ruleName, ruleIndex, this.input.LT(1));
	}
});


/**
 * A BitSet similar to java.util.BitSet.
 *
 * <p>JavaScript Note: There is no good way to implement something like this in 
 * JavaScript.  JS has no true int type, arrays are usually implemented as
 * hashes, etc.  This class should probably be nixed for something that is
 * similarly (in)efficient, but more clear.</p>
 *
 * @class
 * @param {Number|Array} [bits] a 32 bit number or array of 32 bit numbers
 *                              representing the bitset.  These are typically
 *                              generated by the ANTLR Tool.
 */
org.antlr.runtime.BitSet = function(bits) {
    if (!bits) {
        bits = org.antlr.runtime.BitSet.BITS;
    }

    if (org.antlr.lang.isArray(bits)) {
        /**
         * An array of Numbers representing the BitSet.
         * @type Array
         */
        this.bits = bits;
    } else if(org.antlr.lang.isNumber(bits)) {
        this.bits = [];
    }
};

org.antlr.lang.augmentObject(org.antlr.runtime.BitSet, {
    /**
     * Number of bits in each number.
     * @constant
     * @memberOf org.antlr.runtime.BitSet
     */
    BITS: 32,

    /**
     * Log (base 2) of the number of bits in each number.
     * @constant
     * @memberOf org.antlr.runtime.BitSet
     */
    LOG_BITS: 5,  // 2^5 == 32 

    /**
     * We will often need to do a mod operator (i mod nbits).  Its
     * turns out that, for powers of two, this mod operation is
     * same as (i & (nbits-1)).  Since mod is slow, we use a
     * precomputed mod mask to do the mod instead.
     * @constant
     * @memberOf org.antlr.runtime.BitSet
     */
    MOD_MASK: 31, // BITS - 1

    /**
     * Create mask for bit modded to fit in a single word.
     * @example
     * bitmask(35) => 00000000000000000000000000000100
     * bitmask(3)  => 00000000000000000000000000000100
     * @param {Number} bitNumber the bit to create a mask for.
     * @returns {Number} the bitmask.
     * @memberOf org.antlr.runtime.BitSet
     * @private
     */
    bitMask: function(bitNumber) {
        var bitPosition = bitNumber & org.antlr.runtime.BitSet.MOD_MASK;
        return 1 << bitPosition;
    },

    /**
     * Calculate the minimum number of bits needed to represent el.
     * @param {Number} el a number to be included in the BitSet.
     * @returns {Number} the number of bits need to create a BitSet with member
     *                   el.
     * @memberOf org.antlr.runtime.BitSet
     * @private
     */
    numWordsToHold: function(el) {
        return (el >> org.antlr.runtime.BitSet.LOG_BITS) + 1;
    },

    /**
     * @param {Number} bit a number to be included in the BitSet
     * @returns {Number} the index of the word in the field bits that would
     *                   hold bit.
     * @memberOf org.antlr.runtime.BitSet
     * @private
     */
    wordNumber: function(bit) {
        return bit >> org.antlr.runtime.BitSet.LOG_BITS; // bit / BITS
    },

    /**
     * BitSet factory method.
     * 
     * <p>Operates in a number of modes:
     * <ul>
     * <li>If el is a number create the BitSet containing that number.</li>
     * <li>If el is an array create the BitSet containing each number in the
     * array.</li>
     * <li>If el is a BitSet return el.</li>
     * <li>If el is an Object create the BitSet containing each numeric value
     * in el.</li>
     * <li>If el is a number and el2 is a number return a BitSet containing
     * the numbers between el and el2 (inclusive).</li>
     * </ul>
     * </p>
     * @param {Number|Array|org.antlr.runtime.BitSet|Object} el
     * @param {Number} el2
     * @returns {org.antlr.runtime.BitSet}
     * @memberOf org.antlr.runtime.BitSet
     */
    of: function(el, el2) {
        var i, n, s, keys;

        if (org.antlr.lang.isNumber(el)) {
            if (org.antlr.lang.isNumber(el2)) {
                s = new org.antlr.runtime.BitSet(el2 + 1);
                for (i = el; i <= el2; i++) {
                    n = org.antlr.runtime.BitSet.wordNumber(i);
                    s.bits[n] |= org.antlr.runtime.BitSet.bitMask(i);
                }
                return s;
            } else {
                s = new org.antlr.runtime.BitSet(el + 1);
                s.add(el);
                return s;
            }
        } else if(org.antlr.lang.isArray(el)) {
            s = new org.antlr.runtime.BitSet();
            for (i=el.length-1; i>=0; i--) {
                s.add(el[i]);
            }
            return s;
        } else if (el instanceof org.antlr.runtime.BitSet) {
            if (!el) {
                return null;
            }
            return el;
        } else if (el instanceof org.antlr.runtime.IntervalSet) {
            if (!el) {
                return null;
            }
            s = new org.antlr.runtime.BitSet();
            s.addAll(el);
            return s;
        } else if (org.antlr.lang.isObject(el)) {
            keys = [];
            for (i in el) {
                if (org.antlr.lang.isNumber(i)) {
                    keys.push(i);
                }
            }
            return org.antlr.runtime.BitSet.of(keys);
        }
    }
});



org.antlr.runtime.BitSet.prototype = {
    /**
     * Add el into this set.
     * @param {Number} el the number to add to the set.
     */
    add: function(el) {
        var n = org.antlr.runtime.BitSet.wordNumber(el);
        if (n >= this.bits.length) {
            this.growToInclude(el);
        }
        this.bits[n] |= org.antlr.runtime.BitSet.bitMask(el);
    },

    /**
     * Add multiple elements into this set.
     * @param {Array|org.antlr.runtime.BitSet} elements the elements to be added to
     *                                           this set.
     */
    addAll: function(elements) {
        var other,
            i,
            e;

        if ( elements instanceof org.antlr.runtime.BitSet ) {
            this.orInPlace(elements);
        }
		else if ( elements instanceof org.antlr.runtime.IntervalSet ) {
			other = elements;
			// walk set and add each interval
            /* @todo after implementing intervalset
			for (Iterator iter = other.intervals.iterator(); iter.hasNext();) {
				Interval I = (Interval) iter.next();
				this.orInPlace(BitSet.range(I.a,I.b));
			}*/
		} else if (org.antlr.lang.isArray(elements)) {
    		for (i = 0; i < elements.length; i++) {
	    		e = elements[i];
		    	this.add(e);
    		}
        } else {
            return;
        }
	},

    /**
     * Clone this BitSet and then {@link #andInPlace} with a.
     * @param {org.antlr.runtime.BitSet} a a bit set.
     * @returns {org.antlr.runtime.BitSet}
     */
    and: function(a) {
        var s = this.clone();
        s.andInPlace(a);
        return s;
    },

    /**
     * Perform a logical AND of this target BitSet with the argument BitSet.
     *
     * This bit set is modified so that each bit in it has the value true if 
     * and only if it both initially had the value true and the corresponding 
     * bit in the bit set argument also had the value true. 
     * @param {org.antlr.runtime.BitSet} a a bit set.
     * @returns {org.antlr.runtime.BitSet}
     */
    andInPlace: function(a) {
        var min = Math.min(this.bits.length, a.bits.length),
            i;
        for (i = min - 1; i >= 0; i--) {
            this.bits[i] &= a.bits[i];
        }
        // clear all bits in this not present in a (if this bigger than a).
        for (i = min; i < this.bits.length; i++) {
            this.bits[i] = 0;
        }
    },

    /**
     * Clear all bits or a specific bit.
     *
     * If no arguments given, sets all of the bits in this BitSet to false.
     * If one argument given, sets the bit specified by the index to false.
     * @param {Number} [el] the index of the bit to be cleared.
     */
    clear: function(el) {
        if (arguments.length===0) {
            var i;
            for (i = this.bits.length - 1; i >= 0; i--) {
                this.bits[i] = 0;
            }
            return;
        }

        var n = org.antlr.runtime.BitSet.wordNumber(el);
        if (n >= this.bits.length) {	// grow as necessary to accommodate
            this.growToInclude(el);
        }
        this.bits[n] &= ~org.antlr.runtime.BitSet.bitMask(el);
    },

    /**
     * Cloning this BitSet produces a new BitSet  that is equal to it. 
     *
     * The clone of the bit set is another bit set that has exactly the same
     * bit set to true as this bit set. 
     * @returns {org.antlr.runtime.BitSet} a clone of this BitSet.
     */
    clone: function() {
        var i, len, b=[];
        for (i=0, len=this.bits.length; i<len; i++) {
            b[i] = this.bits[i];
        }
        return new org.antlr.runtime.BitSet(b);
    },

    /**
     * Returns the number of bits of space actually in use by this BitSet to 
     * represent bit values.
     *
     * The maximum element in the set is the size - 1st element. 
     * @returns {Number} the number of bits currently in this bit set.
     */
    size: function() {
        var deg = 0, i, word, bit;
        for (i = this.bits.length - 1; i >= 0; i--) {
            word = this.bits[i];
            if (word !== 0) {
                for (bit = org.antlr.runtime.BitSet.BITS - 1; bit >= 0; bit--) {
                    if ((word & (1 << bit)) !== 0) {
                        deg++;
                    }
                }
            }
        }
        return deg;
    },

    /**
     * Compares this object against the specified object.
     *
     * The result is true if and only if the argument is not null and is a
     * BitSet object that has exactly the same set of bits set to true as
     * this bit set. That is, for every nonnegative int index k,
     * <pre><code>
     * ((BitSet)obj).get(k) == this.get(k)
     * </code></pre>
     * must be true. The current sizes of the two bit sets are not compared.
     * @param {Object} other the object to compare with.
     * @returns {Boolean} if the objects are the same; false otherwise.
     */
    equals: function(other) {
        if ( !other || !(other instanceof org.antlr.runtime.BitSet) ) {
            return false;
        }

        var otherSet = other,
            i,
            n = Math.min(this.bits.length, otherSet.bits.length);

        // for any bits in common, compare
        for (i=0; i<n; i++) {
            if (this.bits[i] != otherSet.bits[i]) {
                return false;
            }
        }

        // make sure any extra bits are off

        if (this.bits.length > n) {
            for (i = n+1; i<this.bits.length; i++) {
                if (this.bits[i] !== 0) {
                    return false;
                }
            }
        }
        else if (otherSet.bits.length > n) {
            for (i = n+1; i<otherSet.bits.length; i++) {
                if (otherSet.bits[i] !== 0) {
                    return false;
                }
            }
        }

        return true;
    },

    /**
     * Grows the set to a larger number of bits.
     * @param {Number} bit element that must fit in set
     * @private
     */
    growToInclude: function(bit) {
        var newSize = Math.max(this.bits.length << 1, org.antlr.runtime.BitSet.numWordsToHold(bit)),
            newbits = [], //new Array(newSize),
            i,
            len;
        for (i=0, len=this.bits.length; i<len; i++) {
            newbits[i] = this.bits[i];
        }
        this.bits = newbits;
    },

    /**
     * Returns the value of the bit with the specified index.
     *
     * The value is true if the bit with the index el is currently set 
     * in this BitSet; otherwise, the result is false.
     * @param {Number} el the bit index.
     * @returns {Boolean} the value of the bit with the specified index.
     */
    member: function(el) {
        var n = org.antlr.runtime.BitSet.wordNumber(el);
        if (n >= this.bits.length) { return false; }
        return (this.bits[n] & org.antlr.runtime.BitSet.bitMask(el)) !== 0;
    },

    /**
     * Returns the index of the first bit that is set to true.
     * If no such bit exists then -1 is returned.
     * @returns {Number} the index of the next set bit.
     */
    getSingleElement: function() {
        var i;
        for (i = 0; i < (this.bits.length << org.antlr.runtime.BitSet.LOG_BITS); i++) {
            if (this.member(i)) {
                return i;
            }
        }
        return -1; //Label.INVALID;
    },

    /**
     * Returns true if this BitSet contains no bits that are set to true.
     * @returns {Boolean} boolean indicating whether this BitSet is empty.
     */
    isNil: function() {
        var i;
        for (i = this.bits.length - 1; i >= 0; i--) {
            if (this.bits[i] !== 0) {
                return false;
            }
        }
        return true;
    },

    /**
     * If a bit set argument is passed performs a {@link #subtract} of this bit
     * set with the argument bit set.  If no argument is passed, clone this bit
     * set and {@link #notInPlace}.
     * @param {org.antlr.runtime.BitSet} [set]
     * @returns {org.antlr.runtime.BitSet}
     */
    complement: function(set) {
        if (set) {
            return set.subtract(this);
        } else {
            var s = this.clone();
            s.notInPlace();
            return s;
        }
    },

    /**
     * If no arguments are passed sets all bits to the complement of their
     * current values.  If one argument is passed sets each bit from the
     * beginning of the bit set to index1 (inclusive) to the complement of its
     * current value.  If two arguments are passed sets each bit from the
     * specified index1 (inclusive) to the sepcified index2 (inclusive) to the
     * complement of its current value.
     * @param {Number} index1
     * @param {Number} index2
     */
    notInPlace: function() {
        var minBit, maxBit, i, n;
        if (arguments.length===0) {
            for (i = this.bits.length - 1; i >= 0; i--) {
                this.bits[i] = ~this.bits[i];
            }
        } else {
            if (arguments.length===1) {
                minBit = 0;
                maxBit = arguments[0];
            } else {
                minBit = arguments[0];
                maxBit = arguments[1];
            }
            // make sure that we have room for maxBit
            this.growToInclude(maxBit);
            for (i = minBit; i <= maxBit; i++) {
                n = org.antlr.runtime.BitSet.wordNumber(i);
                this.bits[n] ^= org.antlr.runtime.BitSet.bitMask(i);
            }
        }

    },

    /**
     * Performs a logical OR of this bit set with the bit set argument.
     * If no argument is passed, return this bit set.  Otherwise a clone of
     * this bit set is modified so that a bit in it has the value true if and
     * only if it either already had the value true or the corresponding bit
     * in the bit set argument has the value true.
     * @param {org.antlr.runtime.BitSet} [a] a bit set.
     * @returns {org.antlr.runtime.BitSet}
     */
    or: function(a) {
		if ( !a ) {
			return this;
		}
        var s = this.clone();
        s.orInPlace(a);
        return s;
    },

    /**
     * Performs a logical {@link #or} in place.
     * @param {org.antlr.runtime.BitSet} [a]
     * @returns {org.antlr.runtime.BitSet}
     */
    orInPlace: function(a) {
		if ( !a ) {
			return;
		}
        // If this is smaller than a, grow this first
        if (a.bits.length > this.bits.length) {
            this.setSize(a.bits.length);
        }
        var min = Math.min(this.bits.length, a.bits.length),
            i;
        for (i = min - 1; i >= 0; i--) {
            this.bits[i] |= a.bits[i];
        }
    },

    /**
     * Sets the bit specified by the index to false.
     * @param {Number} bitIndex the index of the bit to be cleared.
     */
    remove: function(el) {
        var n = org.antlr.runtime.BitSet.wordNumber(el);
        if (n >= this.bits.length) {
            this.growToInclude(el);
        }
        this.bits[n] &= ~org.antlr.runtime.BitSet.bitMask(el);
    },

    /**
     * Grows the internal bits array to include at least nwords numbers.
     * @param {Number} nwords how many words the new set should be
     * @private
     */
    setSize: function(nwords) {
        var n = nwords - this.bits.length;
        while (n>=0) {
            this.bits.push(0);
            n--;
        }
    },

    /**
     * Returns the number of bits capable of being represented by this bit set
     * given its current size.
     * @returns {Number} the maximum number of bits that can be represented at
     *                   the moment.
     * @private
     */
    numBits: function() {
        return this.bits.length << org.antlr.runtime.BitSet.LOG_BITS; // num words * bits per word
    },

    /**
     * Return how much space is being used by the bits array not
     * how many actually have member bits on.
     * @returns {Number} the length of the internal bits array.
     * @private
     */
    lengthInLongWords: function() {
        return this.bits.length;
    },

    /**
     * Is this bit set contained within a?
     * @param {org.antlr.runtime.BitSet} a bit set
     * @returns {Boolean} true if and only if a is a subset of this bit set.
     */
    subset: function(a) {
        if (!a) { return false; }
        return this.and(a).equals(this);
    },

    /**
     * Subtract the elements of the argument bit set from this bit set in place.
     * That is, for each set bit in the argument bit set, set the corresponding
     * bit in this bit set to false.
     * @param {org.antlr.runtime.BitSet} a bit set.
     */
    subtractInPlace: function(a) {
        if (!a) { return; }
        // for all words of 'a', turn off corresponding bits of 'this'
        var i;
        for (i = 0; i < this.bits.length && i < a.bits.length; i++) {
            this.bits[i] &= ~a.bits[i];
        }
    },

    /**
     * Perform a {@link #subtractInPlace} on a clone of this bit set.
     * @param {org.antlr.runtime.BitSet} a bit set.
     * @returns {org.antlr.runtime.BitSet} the new bit set.
     */
    subtract: function(a) {
        if (!a || !(a instanceof org.antlr.runtime.BitSet)) { return null; }

        var s = this.clone();
        s.subtractInPlace(a);
        return s;
    },

    /* antlr-java needs this to make its class hierarchy happy . . .
    toList: function() {
		throw new Error("BitSet.toList() unimplemented");
	},
    */

    /**
     * Creates an array of the indexes of each bit set in this bit set.
     * @returns {Array}
     */
    toArray: function() {
        var elems = [], //new Array(this.size()),
            i,
            en = 0;
        for (i = 0; i < (this.bits.length << org.antlr.runtime.BitSet.LOG_BITS); i++) {
            if (this.member(i)) {
                elems[en++] = i;
            }
        }
        return elems;
    },

    /**
     * Returns the internal representation of this bit set.
     * This representation is an array of numbers, each representing 32 bits.
     * @returns {Array}
     */
    toPackedArray: function() {
        return this.bits;
    },

    /**
     * Returns a string representation of this bit set.
     * <p>For every index for which this BitSet contains a bit in the set state,
     * the decimal representation of that index is included in the result.
     * Such indices are listed in order from lowest to highest, separated by
     * ", " (a comma and a space) and surrounded by braces, resulting in the
     * usual mathematical notation for a set of integers.</p>
     * 
     * <p>If a grammar g is passed, print g.getTokenDisplayName(i) for each set
     * index instead of the numerical index.</p>
     *
     * <>If two arguments are passed, the first will be used as a custom
     * separator string.  The second argument is an array whose i-th element
     * will be added if the corresponding bit is set.</p>
     *
     * @param {Object|String} [arg1] an Object with function property
     *      getTokenDispalyName or a String that will be used as a list
     *      separator.
     * @param {Array} [vocabulary] array from which the i-th value will be
     *      drawn if the corresponding bit is set.  Must pass a string as the
     *      first argument if using this option.
     * @return A commma-separated list of values
     */
    toString: function() {
        if (arguments.length===0) {
            return this.toString1(null);
        } else {
            if (org.antlr.lang.isString(arguments[0])) {
                if (!org.antlr.lang.isValue(arguments[1])) {
                    return this.toString1(null);
                } else {
                    return this.toString2(arguments[0], arguments[1]);
                }
            } else {
                return this.toString1(arguments[0]);
            }
        }
    },

    /**
     * Transform a bit set into a string by formatting each element as an
     * integer separator The string to put in between elements
     * @private
     * @return A commma-separated list of values
     */
    toString1: function(g) {
        var buf = "{",
            separator = ",",
            i,
		    havePrintedAnElement = false;

        for (i = 0; i < (this.bits.length << org.antlr.runtime.BitSet.LOG_BITS); i++) {
            if (this.member(i)) {
                if (i > 0 && havePrintedAnElement ) {
                    buf += separator;
                }
                if ( g ) {
                    buf += g.getTokenDisplayName(i);
                }
                else {
                    buf += i.toString();
                }
				havePrintedAnElement = true;
            }
        }
        return buf + "}";
    },

    /**
     * Create a string representation where instead of integer elements, the
     * ith element of vocabulary is displayed instead.  Vocabulary is a Vector
     * of Strings.
     * separator The string to put in between elements
     * @private
     * @return A commma-separated list of character constants.
     */
    toString2: function(separator, vocabulary) {
        var str = "",
            i;
        for (i = 0; i < (this.bits.length << org.antlr.runtime.BitSet.LOG_BITS); i++) {
            if (this.member(i)) {
                if (str.length > 0) {
                    str += separator;
                }
                if (i >= vocabulary.size()) {
                    str += "'" + i + "'";
                }
                else if (!org.antlr.lang.isValue(vocabulary.get(i))) {
                    str += "'" + i + "'";
                }
                else {
                    str += vocabulary.get(i);
                }
            }
        }
        return str;
    }
};


/** Rules that return more than a single value must return an object
 *  containing all the values.  Besides the properties defined in
 *  RuleLabelScope.predefinedRulePropertiesScope there may be user-defined
 *  return values.  This class simply defines the minimum properties that
 *  are always defined and methods to access the others that might be
 *  available depending on output option such as template and tree.
 *
 *  Note text is not an actual property of the return value, it is computed
 *  from start and stop using the input stream's toString() method.  I
 *  could add a ctor to this so that we can pass in and store the input
 *  stream, but I'm not sure we want to do that.  It would seem to be undefined
 *  to get the .text property anyway if the rule matches tokens from multiple
 *  input streams.
 *
 *  I do not use getters for fields of objects that are used simply to
 *  group values such as this aggregate.  The getters/setters are there to
 *  satisfy the superclass interface.
 */
org.antlr.runtime.ParserRuleReturnScope = function() {};
org.antlr.runtime.RuleReturnScope = function() {};

org.antlr.lang.extend(org.antlr.runtime.ParserRuleReturnScope,
                      org.antlr.runtime.RuleReturnScope,
{
    getStart: function() { return this.start; },
    getStop: function() { return this.stop; }
});


/** The set of fields needed by an abstract recognizer to recognize input
 *  and recover from errors etc...  As a separate state object, it can be
 *  shared among multiple grammars; e.g., when one grammar imports another.
 *
 *  These fields are publically visible but the actual state pointer per
 *  parser is protected.
 */
org.antlr.runtime.RecognizerSharedState = function() {
    /** Track the set of token types that can follow any rule invocation.
     *  Stack grows upwards.  When it hits the max, it grows 2x in size
     *  and keeps going.
     */
    this.following = [];

    this._fsp = -1;

    /** This is true when we see an error and before having successfully
     *  matched a token.  Prevents generation of more than one error message
     *  per error.
     */
    this.errorRecovery = false;

    /** The index into the input stream where the last error occurred.
     *  This is used to prevent infinite loops where an error is found
     *  but no token is consumed during recovery...another error is found,
     *  ad naseum.  This is a failsafe mechanism to guarantee that at least
     *  one token/tree node is consumed for two errors.
     */
    this.lastErrorIndex = -1;

    /** In lieu of a return value, this indicates that a rule or token
     *  has failed to match.  Reset to false upon valid token match.
     */
    this.failed = false;

    /** Did the recognizer encounter a syntax error?  Track how many. */
    this.syntaxErrors = 0;

    /** If 0, no backtracking is going on.  Safe to exec actions etc...
     *  If >0 then it's the level of backtracking.
     */
    this.backtracking = 0;

    /** An array[size num rules] of Map<Integer,Integer> that tracks
     *  the stop token index for each rule.  ruleMemo[ruleIndex] is
     *  the memoization table for ruleIndex.  For key ruleStartIndex, you
     *  get back the stop token for associated rule or MEMO_RULE_FAILED.
     *
     *  This is only used if rule memoization is on (which it is by default).
     */
    this.ruleMemo = null;


    // LEXER FIELDS (must be in same state object to avoid casting
    //               constantly in generated code and Lexer object) :(


    /** The goal of all lexer rules/methods is to create a token object.
     *  This is an instance variable as multiple rules may collaborate to
     *  create a single token.  nextToken will return this object after
     *  matching lexer rule(s).  If you subclass to allow multiple token
     *  emissions, then set this to the last token to be matched or
     *  something nonnull so that the auto token emit mechanism will not
     *  emit another token.
     */
    this.token = null;

    /** What character index in the stream did the current token start at?
     *  Needed, for example, to get the text for current token.  Set at
     *  the start of nextToken.
     */
    this.tokenStartCharIndex = -1;

    /** The line on which the first character of the token resides */
    // this.tokenStartLine;

    /** The character position of first character within the line */
    // this.tokenStartCharPositionInLine;

    /** The channel number for the current token */
    // this.channel;

    /** The token type for the current token */
    // this.type;

    /** You can set the text for the current token to override what is in
     *  the input char buffer.  Use setText() or can set this instance var.
     */
    this.text = null;
};


org.antlr.runtime.tree = {}

/** What does a tree look like?  ANTLR has a number of support classes
 *  such as CommonTreeNodeStream that work on these kinds of trees.  You
 *  don't have to make your trees implement this interface, but if you do,
 *  you'll be able to use more support code.
 *
 *  NOTE: When constructing trees, ANTLR can build any kind of tree; it can
 *  even use Token objects as trees if you add a child list to your tokens.
 *
 *  This is a tree node without any payload; just navigation and factory stuff.
 */
org.antlr.runtime.tree.Tree = function(){};


/** A generic tree implementation with no payload.  You must subclass to
 *  actually have any user data.  ANTLR v3 uses a list of children approach
 *  instead of the child-sibling approach in v2.  A flat tree (a list) is
 *  an empty node whose children represent the list.  An empty, but
 *  non-null node is called "nil".
 */
org.antlr.runtime.tree.BaseTree = function() {};

org.antlr.lang.extend(org.antlr.runtime.tree.BaseTree,
                      org.antlr.runtime.tree.Tree,
{
    getChild: function(i) {
        if ( !this.children || i>=this.children.length ) {
            return null;
        }
        return this.children[i];
    },

    /** Get the children internal List; note that if you directly mess with
     *  the list, do so at your own risk.
     */
    getChildren: function() {
        return this.children;
    },

    getFirstChildWithType: function(type) {
        var i, t;
        for (i = 0; this.children && i < this.children.length; i++) {
            t = this.children[i];
            if ( t.getType()===type ) {
                return t;
            }
        }    
        return null;
    },

    getChildCount: function() {
        if ( !this.children ) {
            return 0;
        }
        return this.children.length;
    },

    /** Add t as child of this node.
     *
     *  Warning: if t has no children, but child does
     *  and child isNil then this routine moves children to t via
     *  t.children = child.children; i.e., without copying the array.
     */
    addChild: function(t) {
        if ( !org.antlr.lang.isValue(t) ) {
            return; // do nothing upon addChild(null)
        }
        var childTree = t, n, i, c;
        if ( childTree.isNil() ) { // t is an empty node possibly with children
            if ( this.children && this.children == childTree.children ) {
                throw new Error("attempt to add child list to itself");
            }
            // just add all of childTree's children to this
            if ( childTree.children ) {
                if ( this.children ) { // must copy, this has children already
                    n = childTree.children.length;
                    for (i = 0; i < n; i++) {
                        c = childTree.children[i];
                        this.children.push(c);
                        // handle double-link stuff for each child of nil root
                        c.setParent(this);
                        c.setChildIndex(this.children.length-1);
                    }
                }
                else {
                    // no children for this but t has children; just set pointer
                    // call general freshener routine
                    this.children = childTree.children;
                    this.freshenParentAndChildIndexes();
                }
            }
        }
        else { // child is not nil (don't care about children)
            if ( !this.children ) {
                this.children = this.createChildrenList(); // create children list on demand
            }
            this.children.push(t);
            childTree.setParent(this);
            childTree.setChildIndex(this.children.length-1);
        }
    },

    /** Add all elements of kids list as children of this node */
    addChildren: function(kids) {
        var i, t;
        for (i = 0; i < kids.length; i++) {
            t = kids[i];
            this.addChild(t);
        }
    },

    setChild: function(i, t) {
        if ( !t ) {
            return;
        }
        if ( t.isNil() ) {
            throw new Error("Can't set single child to a list");
        }
        if ( !this.children ) {
            this.children = this.createChildrenList();
        }
        this.children[i] = t;
        t.setParent(this);
        t.setChildIndex(i);
    },

    deleteChild: function(i) {
        if ( !this.children ) {
            return null;
        }
        if (i<0 || i>=this.children.length) {
            throw new Error("Index out of bounds.");
        }
        var killed = this.children.splice(i, 1)[0];
        // walk rest and decrement their child indexes
        this.freshenParentAndChildIndexes(i);
        return killed;
    },

    /** Delete children from start to stop and replace with t even if t is
     *  a list (nil-root tree).  num of children can increase or decrease.
     *  For huge child lists, inserting children can force walking rest of
     *  children to set their childindex; could be slow.
     */
    replaceChildren: function(startChildIndex, stopChildIndex, t) {
        if ( !this.children ) {
            throw new Error("indexes invalid; no children in list");
        }
        var replacingHowMany = stopChildIndex - startChildIndex + 1;
        var replacingWithHowMany;
        var newTree = t;
        var newChildren = null;
        // normalize to a list of children to add: newChildren
        if ( newTree.isNil() ) {
            newChildren = newTree.children;
        }
        else {
            newChildren = [];
            newChildren.push(newTree);
        }
        replacingWithHowMany = newChildren.length;
        var numNewChildren = newChildren.length;
        var delta = replacingHowMany - replacingWithHowMany;
        var j, i, child, indexToDelete, c, killed, numToInsert;
        // if same number of nodes, do direct replace
        if ( delta === 0 ) {
            j = 0; // index into new children
            for (i=startChildIndex; i<=stopChildIndex; i++) {
                child = newChildren[j];
                this.children[i] = child;
                child.setParent(this);
                child.setChildIndex(i);
                j++;
            }
        }
        else if ( delta > 0 ) { // fewer new nodes than there were
            // set children and then delete extra
            for (j=0; j<numNewChildren; j++) {
                this.children[startChildIndex+j] = newChildren[j];
            }
            indexToDelete = startChildIndex+numNewChildren;
            for (c=indexToDelete; c<=stopChildIndex; c++) {
                // delete same index, shifting everybody down each time
                killed = this.children.splice(indexToDelete, 1)[0];
            }
            this.freshenParentAndChildIndexes(startChildIndex);
        }
        else { // more new nodes than were there before
            // fill in as many children as we can (replacingHowMany) w/o moving data
            for (j=0; j<replacingHowMany; j++) {
                this.children[startChildIndex+j] = newChildren[j];
            }
            numToInsert = replacingWithHowMany-replacingHowMany;
            for (j=replacingHowMany; j<replacingWithHowMany; j++) {
                this.children.splice(startChildIndex+j, 0, newChildren[j]);
            }
            this.freshenParentAndChildIndexes(startChildIndex);
        }
    },

    /** Override in a subclass to change the impl of children list */
    createChildrenList: function() {
        return [];
    },

    isNil: function() {
        return false;
    },

    freshenParentAndChildIndexes: function(offset) {
        if (!org.antlr.lang.isNumber(offset)) {
            offset = 0;
        }
        var n = this.getChildCount(),
            c,
            child;
        for (c = offset; c < n; c++) {
            child = this.getChild(c);
            child.setChildIndex(c);
            child.setParent(this);
        }
    },

    sanityCheckParentAndChildIndexes: function(parent, i) {
        if (arguments.length===0) {
            parent = null;
            i = -1;
        }

        if ( parent!==this.getParent() ) {
            throw new Error("parents don't match; expected "+parent+" found "+this.getParent());
        }
        if ( i!==this.getChildIndex() ) {
            throw new Error("child indexes don't match; expected "+i+" found "+this.getChildIndex());
        }
        var n = this.getChildCount(),
            c,
            child;
        for (c = 0; c < n; c++) {
            child = this.getChild(c);
            child.sanityCheckParentAndChildIndexes(this, c);
        }
    },

    /** BaseTree doesn't track child indexes. */
    getChildIndex: function() {
        return 0;
    },
    setChildIndex: function(index) {
    },

    /** BaseTree doesn't track parent pointers. */
    getParent: function() {
        return null;
    },
    setParent: function(t) {
    },

    getTree: function() {
        return this;
    },

    /** Print out a whole tree not just a node */
    toStringTree: function() {
        if ( !this.children || this.children.length===0 ) {
            return this.toString();
        }
        var buf = "",
            i,
            t;
        if ( !this.isNil() ) {
            buf += "(";
            buf += this.toString();
            buf += ' ';
        }
        for (i = 0; this.children && i < this.children.length; i++) {
            t = this.children[i];
            if ( i>0 ) {
                buf += ' ';
            }
            buf += t.toStringTree();
        }
        if ( !this.isNil() ) {
            buf += ")";
        }
        return buf;
    },

    getLine: function() {
        return 0;
    },

    getCharPositionInLine: function() {
        return 0;
    }
});


/** A tree node that is wrapper for a Token object.  After 3.0 release
 *  while building tree rewrite stuff, it became clear that computing
 *  parent and child index is very difficult and cumbersome.  Better to
 *  spend the space in every tree node.  If you don't want these extra
 *  fields, it's easy to cut them out in your own BaseTree subclass.
 */
org.antlr.runtime.tree.CommonTree = function(node) {
    /** What token indexes bracket all tokens associated with this node
     *  and below?
     */
    this.startIndex = -1;
    this.stopIndex = -1;

    /** What index is this node in the child list? Range: 0..n-1 */
    this.childIndex = -1;

    /** Who is the parent node of this node; if null, implies node is root */
    this.parent = null;

    /** A single token is the payload */
    this.token = null;

    if (node instanceof org.antlr.runtime.tree.CommonTree) {
        org.antlr.runtime.tree.CommonTree.superclass.constructor.call(this, node);
        this.token = node.token;
        this.startIndex = node.startIndex;
        this.stopIndex = node.stopIndex;
    } else if (node instanceof org.antlr.runtime.CommonToken) {
        this.token = node;
    }
};

/** A tree node that is wrapper for a Token object. */
org.antlr.lang.extend(org.antlr.runtime.tree.CommonTree, org.antlr.runtime.tree.BaseTree, {
    getToken: function() {
        return this.token;
    },

    dupNode: function() {
        return new org.antlr.runtime.tree.CommonTree(this);
    },

    isNil: function() {
        return !this.token;
    },

    getType: function() {
        if ( !this.token ) {
            return org.antlr.runtime.Token.INVALID_TOKEN_TYPE;
        }
        return this.token.getType();
    },

    getText: function() {
        if ( !this.token ) {
            return null;
        }
        return this.token.getText();
    },

    getLine: function() {
        if ( !this.token || this.token.getLine()===0 ) {
            if ( this.getChildCount()>0 ) {
                return this.getChild(0).getLine();
            }
            return 0;
        }
        return this.token.getLine();
    },

    getCharPositionInLine: function() {
        if ( !this.token || this.token.getCharPositionInLine()===-1 ) {
            if ( this.getChildCount()>0 ) {
                return this.getChild(0).getCharPositionInLine();
            }
            return 0;
        }
        return this.token.getCharPositionInLine();
    },

    getTokenStartIndex: function() {
        if ( this.token ) {
            return this.token.getTokenIndex();
        }
        return this.startIndex;
    },

    setTokenStartIndex: function(index) {
        this.startIndex = index;
    },

    getTokenStopIndex: function() {
        if ( this.token ) {
            return this.token.getTokenIndex();
        }
        return this.stopIndex;
    },

    setTokenStopIndex: function(index) {
        this.stopIndex = index;
    },

    getChildIndex: function() {
        return this.childIndex;
    },

    getParent: function() {
        return this.parent;
    },

    setParent: function(t) {
        this.parent = t;
    },

    setChildIndex: function(index) {
        this.childIndex = index;
    },

    toString: function() {
        if ( this.isNil() ) {
            return "nil";
        }
        if ( this.getType()===org.antlr.runtime.Token.INVALID_TOKEN_TYPE ) {
            return "<errornode>";
        }
        if ( !this.token ) {
            return null;
        }
        return this.token.getText();
    }
});

/* Monkey patch Tree static property with CommonToken value. */
org.antlr.runtime.tree.Tree.INVALID_NODE =
  new org.antlr.runtime.tree.CommonTree(org.antlr.runtime.Token.INVALID_TOKEN);


/** A generic list of elements tracked in an alternative to be used in
 *  a -> rewrite rule.  We need to subclass to fill in the next() method,
 *  which returns either an AST node wrapped around a token payload or
 *  an existing subtree.
 *
 *  Once you start next()ing, do not try to add more elements.  It will
 *  break the cursor tracking I believe.
 *
 *  @see org.antlr.runtime.tree.RewriteRuleSubtreeStream
 *  @see org.antlr.runtime.tree.RewriteRuleTokenStream
 *
 *  TODO: add mechanism to detect/puke on modification after reading from stream
 */
org.antlr.runtime.tree.RewriteRuleElementStream = function(adaptor, elementDescription, el) {
    /** Cursor 0..n-1.  If singleElement!=null, cursor is 0 until you next(),
     *  which bumps it to 1 meaning no more elements.
     */
    this.cursor = 0;

    /** Once a node / subtree has been used in a stream, it must be dup'd
     *  from then on.  Streams are reset after subrules so that the streams
     *  can be reused in future subrules.  So, reset must set a dirty bit.
     *  If dirty, then next() always returns a dup.
     *
     *  I wanted to use "naughty bit" here, but couldn't think of a way
     *  to use "naughty".
     */
    this.dirty = false;

    this.elementDescription = elementDescription;
    this.adaptor = adaptor;
    if (el) {
        if (org.antlr.lang.isArray(el)) {
            this.singleElement = null;
            this.elements = el;
        } else {
            this.add(el);
        }
    }
};

org.antlr.runtime.tree.RewriteRuleElementStream.prototype = {
    /** Reset the condition of this stream so that it appears we have
     *  not consumed any of its elements.  Elements themselves are untouched.
     *  Once we reset the stream, any future use will need duplicates.  Set
     *  the dirty bit.
     */
    reset: function() {
        this.cursor = 0;
        this.dirty = true;
    },

    add: function(el) {
        if ( !org.antlr.lang.isValue(el) ) {
            return;
        }
        if ( this.elements ) { // if in list, just add
            this.elements.push(el);
            return;
        }
        if ( !org.antlr.lang.isValue(this.singleElement) ) { // no elements yet, track w/o list
            this.singleElement = el;
            return;
        }
        // adding 2nd element, move to list
        this.elements = [];
        this.elements.push(this.singleElement);
        this.singleElement = null;
        this.elements.push(el);
    },

    /** Return the next element in the stream.  If out of elements, throw
     *  an exception unless size()==1.  If size is 1, then return elements[0].
     *  Return a duplicate node/subtree if stream is out of elements and
     *  size==1.  If we've already used the element, dup (dirty bit set).
     */
    nextTree: function() {
        var n = this.size(),
            el;
        if ( this.dirty || (this.cursor>=n && n==1) ) {
            // if out of elements and size is 1, dup
            el = this._next();
            return this.dup(el);
        }
        // test size above then fetch
        el = this._next();
        return el;
    },

    /** do the work of getting the next element, making sure that it's
     *  a tree node or subtree.  Deal with the optimization of single-
     *  element list versus list of size > 1.  Throw an exception
     *  if the stream is empty or we're out of elements and size>1.
     *  protected so you can override in a subclass if necessary.
     */
    _next: function() {
        var n = this.size();
        if (n===0) {
            throw new org.antlr.runtime.tree.RewriteEmptyStreamException(this.elementDescription);
        }
        if ( this.cursor>= n) { // out of elements?
            if ( n===1 ) {  // if size is 1, it's ok; return and we'll dup
                return this.toTree(this.singleElement);
            }
            // out of elements and size was not 1, so we can't dup
            throw new org.antlr.runtime.tree.RewriteCardinalityException(this.elementDescription);
        }
        // we have elements
        if ( org.antlr.lang.isValue(this.singleElement) ) {
            this.cursor++; // move cursor even for single element list
            return this.toTree(this.singleElement);
        }
        // must have more than one in list, pull from elements
        var o = this.toTree(this.elements[this.cursor]);
        this.cursor++;
        return o;
    },

    /** Ensure stream emits trees; tokens must be converted to AST nodes.
     *  AST nodes can be passed through unmolested.
     */
    toTree: function(el) {
        if (el && el.getTree) {
            return el.getTree();
        }
        return el;
    },

    hasNext: function() {
         return (org.antlr.lang.isValue(this.singleElement) && this.cursor < 1) ||
               (this.elements && this.cursor < this.elements.length);
    },

    size: function() {
        var n = 0;
        if ( org.antlr.lang.isValue(this.singleElement) ) {
            n = 1;
        }
        if ( this.elements ) {
            return this.elements.length;
        }
        return n;
    },

    getDescription: function() {
        return this.elementDescription;
    }
};


org.antlr.runtime.tree.RewriteRuleSubtreeStream = function() {
    var sup = org.antlr.runtime.tree.RewriteRuleSubtreeStream.superclass;
    sup.constructor.apply(this, arguments);
};

org.antlr.lang.extend(org.antlr.runtime.tree.RewriteRuleSubtreeStream,
                  org.antlr.runtime.tree.RewriteRuleElementStream, {
	/** Treat next element as a single node even if it's a subtree.
	 *  This is used instead of next() when the result has to be a
	 *  tree root node.  Also prevents us from duplicating recently-added
	 *  children; e.g., ^(type ID)+ adds ID to type and then 2nd iteration
	 *  must dup the type node, but ID has been added.
	 *
	 *  Referencing a rule result twice is ok; dup entire tree as
	 *  we can't be adding trees as root; e.g., expr expr.
	 *
	 *  Hideous code duplication here with super.next().  Can't think of
	 *  a proper way to refactor.  This needs to always call dup node
	 *  and super.next() doesn't know which to call: dup node or dup tree.
	 */
    nextNode: function() {
		var n = this.size(),
            el;
		if ( this.dirty || (this.cursor>=n && n===1) ) {
			// if out of elements and size is 1, dup (at most a single node
			// since this is for making root nodes).
			el = this._next();
			return this.adaptor.dupNode(el);
		}
		// test size above then fetch
		el = this._next();
		return el;
	},

    dup: function(el) {
		return this.adaptor.dupTree(el);
	}
});

org.antlr.runtime.tree.RewriteRuleTokenStream = function(adaptor, elementDescription, el) {
    var sup = org.antlr.runtime.tree.RewriteRuleTokenStream.superclass;
    sup.constructor.apply(this, arguments);
};

org.antlr.lang.extend(org.antlr.runtime.tree.RewriteRuleTokenStream,
                  org.antlr.runtime.tree.RewriteRuleElementStream, {
    /** Get next token from stream and make a node for it */
    nextNode: function() {
        var t = this._next();
        return this.adaptor.create(t);
    },

    nextToken: function() {
        return this._next();
    },

    /** Don't convert to a tree unless they explicitly call nextTree.
     *  This way we can do hetero tree nodes in rewrite.
     */
    toTree: function(el) {
        return el;
    },

    dup: function(el) {
        throw new Error("dup can't be called for a token stream.");
    }
});


/** A TreeAdaptor that works with any Tree implementation. */
org.antlr.runtime.tree.BaseTreeAdaptor = function() {
    this.uniqueNodeID = 1;
};
org.antlr.runtime.tree.TreeAdaptor = function() {};

org.antlr.lang.extend(org.antlr.runtime.tree.BaseTreeAdaptor,
                      org.antlr.runtime.tree.TreeAdaptor,
{
    nil: function() {
        return this.create(null);
    },

    /** create tree node that holds the start and stop tokens associated
     *  with an error.
     *
     *  If you specify your own kind of tree nodes, you will likely have to
     *  override this method. CommonTree returns Token.INVALID_TOKEN_TYPE
     *  if no token payload but you might have to set token type for diff
     *  node type.
     */
    errorNode: function(input, start, stop, e) {
        var t = new org.antlr.runtime.tree.CommonErrorNode(input, start, stop, e);
        return t;
    },

    isNil: function(tree) {
        return tree.isNil();
    },

    /** This is generic in the sense that it will work with any kind of
     *  tree (not just Tree interface).  It invokes the adaptor routines
     *  not the tree node routines to do the construction.  
     */
    dupTree: function(t, parent) {
        if (arguments.length===1) {
            parent = null;
        }
        if ( !t ) {
            return null;
        }
        var newTree = this.dupNode(t);
        // ensure new subtree root has parent/child index set
        this.setChildIndex(newTree, this.getChildIndex(t)); // same index in new tree
        this.setParent(newTree, parent);
        var n = this.getChildCount(t),
            i, child, newSubTree;
        for (i = 0; i < n; i++) {
            child = this.getChild(t, i);
            newSubTree = this.dupTree(child, t);
            this.addChild(newTree, newSubTree);
        }
        return newTree;
    },

    /** Add a child to the tree t.  If child is a flat tree (a list), make all
     *  in list children of t.  Warning: if t has no children, but child does
     *  and child isNil then you can decide it is ok to move children to t via
     *  t.children = child.children; i.e., without copying the array.  Just
     *  make sure that this is consistent with have the user will build
     *  ASTs.
     */
    addChild: function(t, child) {
        if ( t && org.antlr.lang.isValue(child) ) {
            t.addChild(child);
        }
    },

    /** If oldRoot is a nil root, just copy or move the children to newRoot.
     *  If not a nil root, make oldRoot a child of newRoot.
     *
     *    old=^(nil a b c), new=r yields ^(r a b c)
     *    old=^(a b c), new=r yields ^(r ^(a b c))
     *
     *  If newRoot is a nil-rooted single child tree, use the single
     *  child as the new root node.
     *
     *    old=^(nil a b c), new=^(nil r) yields ^(r a b c)
     *    old=^(a b c), new=^(nil r) yields ^(r ^(a b c))
     *
     *  If oldRoot was null, it's ok, just return newRoot (even if isNil).
     *
     *    old=null, new=r yields r
     *    old=null, new=^(nil r) yields ^(nil r)
     *
     *  Return newRoot.  Throw an exception if newRoot is not a
     *  simple node or nil root with a single child node--it must be a root
     *  node.  If newRoot is ^(nil x) return x as newRoot.
     *
     *  Be advised that it's ok for newRoot to point at oldRoot's
     *  children; i.e., you don't have to copy the list.  We are
     *  constructing these nodes so we should have this control for
     *  efficiency.
     */
    becomeRoot: function(newRoot, oldRoot) {
        if (newRoot instanceof org.antlr.runtime.Token || !newRoot) {
            newRoot = this.create(newRoot);
        }

        var newRootTree = newRoot,
            oldRootTree = oldRoot;
        if ( !oldRoot ) {
            return newRoot;
        }
        // handle ^(nil real-node)
        if ( newRootTree.isNil() ) {
            var nc = newRootTree.getChildCount();
            if (nc===1) {
                newRootTree = newRootTree.getChild(0);
            } else if ( nc>1 ) {
                // TODO: make tree run time exceptions hierarchy
                throw new Error("more than one node as root (TODO: make exception hierarchy)");
            }
        }
        // add oldRoot to newRoot; addChild takes care of case where oldRoot
        // is a flat list (i.e., nil-rooted tree).  All children of oldRoot
        // are added to newRoot.
        newRootTree.addChild(oldRootTree);
        return newRootTree;
    },

    /** Transform ^(nil x) to x */
    rulePostProcessing: function(root) {
        var r = root;
        if ( r && r.isNil() ) {
            if ( r.getChildCount()===0 ) {
                r = null;
            }
            else if ( r.getChildCount()===1 ) {
                r = r.getChild(0);
                // whoever invokes rule will set parent and child index
                r.setParent(null);
                r.setChildIndex(-1);
            }
        }
        return r;
    },

    create: function(tokenType, fromToken) {
        var text, t;
        if (arguments.length===2) {
            if (org.antlr.lang.isString(arguments[1])) {
                text = arguments[1];
                fromToken = this.createToken(tokenType, text);
                t = this.create(fromToken);
                return t;
            } else {
                fromToken = this.createToken(fromToken);
                fromToken.setType(tokenType);
                t = this.create(fromToken);
                return t;
            }
        } else if (arguments.length===3) {
            text = arguments[2];
            fromToken = this.createToken(fromToken);
            fromToken.setType(tokenType);
            fromToken.setText(text);
            t = this.create(fromToken);
            return t;
        }
    },

    getType: function(t) {
        t.getType();
        return 0;
    },

    setType: function(t, type) {
        throw new Error("don't know enough about Tree node");
    },

    getText: function(t) {
        return t.getText();
    },

    setText: function(t, text) {
        throw new Error("don't know enough about Tree node");
    },

    getChild: function(t, i) {
        return t.getChild(i);
    },

    setChild: function(t, i, child) {
        t.setChild(i, child);
    },

    deleteChild: function(t, i) {
        return t.deleteChild(i);
    },

    getChildCount: function(t) {
        return t.getChildCount();
    },

    getUniqueID: function(node) {
        if ( !this.treeToUniqueIDMap ) {
             this.treeToUniqueIDMap = {};
        }
        var prevID = this.treeToUniqueIDMap[node];
        if ( org.antlr.lang.isValue(prevID) ) {
            return prevID;
        }
        var ID = this.uniqueNodeID;
        this.treeToUniqueIDMap[node] = ID;
        this.uniqueNodeID++;
        return ID;
        // GC makes these nonunique:
        // return System.identityHashCode(node);
    }
});


/** A TreeAdaptor that works with any Tree implementation.  It provides
 *  really just factory methods; all the work is done by BaseTreeAdaptor.
 *  If you would like to have different tokens created than ClassicToken
 *  objects, you need to override this and then set the parser tree adaptor to
 *  use your subclass.
 *
 *  To get your parser to build nodes of a different type, override
 *  create(Token).
 */
org.antlr.runtime.tree.CommonTreeAdaptor = function() {};

org.antlr.lang.extend(org.antlr.runtime.tree.CommonTreeAdaptor,
                  org.antlr.runtime.tree.BaseTreeAdaptor, {
    /** Duplicate a node.  This is part of the factory;
     *    override if you want another kind of node to be built.
     *
     *  I could use reflection to prevent having to override this
     *  but reflection is slow.
     */
    dupNode: function(t) {
        if ( !org.antlr.lang.isValue(t) ) {
            return null;
        }
        return t.dupNode();
    },

    create: function(payload) {
        if (arguments.length>1) {
            return org.antlr.runtime.tree.CommonTreeAdaptor.superclass.create.apply(this, arguments);
        }
        return new org.antlr.runtime.tree.CommonTree(payload);
    },

    /** Tell me how to create a token for use with imaginary token nodes.
     *  For example, there is probably no input symbol associated with imaginary
     *  token DECL, but you need to create it as a payload or whatever for
     *  the DECL node as in ^(DECL type ID).
     *
     *  If you care what the token payload objects' type is, you should
     *  override this method and any other createToken variant.
     *
     * Tell me how to create a token for use with imaginary token nodes.
     *  For example, there is probably no input symbol associated with imaginary
     *  token DECL, but you need to create it as a payload or whatever for
     *  the DECL node as in ^(DECL type ID).
     *
     *  This is a variant of createToken where the new token is derived from
     *  an actual real input token.  Typically this is for converting '{'
     *  tokens to BLOCK etc...  You'll see
     *
     *    r : lc='{' ID+ '}' -> ^(BLOCK[$lc] ID+) ;
     *
     *  If you care what the token payload objects' type is, you should
     *  override this method and any other createToken variant.
     */
    createToken: function(fromToken) {
        if (arguments.length===2) {
            return new org.antlr.runtime.CommonToken(arguments[0], arguments[1]);
        } else {
            return new org.antlr.runtime.CommonToken(arguments[0]);
        }
    },

    /** Track start/stop token for subtree root created for a rule.
     *  Only works with Tree nodes.  For rules that match nothing,
     *  seems like this will yield start=i and stop=i-1 in a nil node.
     *  Might be useful info so I'll not force to be i..i.
     */
    setTokenBoundaries: function(t, startToken, stopToken) {
        if ( !org.antlr.lang.isValue(t) ) {
            return;
        }
        var start = 0,
            stop = 0;
        if ( org.antlr.lang.isValue(startToken) ) {
            if (startToken.getTokenIndex) {
                start = startToken.getTokenIndex();
            } else if (startToken.getStartIndex) {
                start = startToken.getStartIndex();
            } else {
                start = startToken.getTokenStartIndex();
            }
        }
        if ( org.antlr.lang.isValue(stopToken) ) {
            if (stop.getTokenIndex) {
                stop = stopToken.getTokenIndex();
            } else if (stopToken.getStopIndex) {
                stop = stopToken.getStopIndex();
            } else {
                stop = stopToken.getTokenStopIndex();
            }
        }
        t.setTokenStartIndex(start);
        t.setTokenStopIndex(stop);
    },

    getTokenStartIndex: function(t) {
        if (!t) {
            return -1;
        }
        return t.getTokenStartIndex();
    },

    getTokenStopIndex: function(t) {
        if (!t) {
            return -1;
        }
        return t.getTokenStopIndex();
    },

    getText: function(t) {
        if (!t) {
            return null;
        }
        return t.getText();
    },

    getType: function(t) {
        if (!t) {
            return org.antlr.runtime.Token.INVALID_TOKEN_TYPE;
        }
        return t.getType();
    },

    /** What is the Token associated with this node?  If
     *  you are not using CommonTree, then you must
     *  override this in your own adaptor.
     */
    getToken: function(t) {
        if ( t instanceof org.antlr.runtime.tree.CommonTree ) {
            return t.getToken();
        }
        return null; // no idea what to do
    },

    getChild: function(t, i) {
        if (!t) {
            return null;
        }
        return t.getChild(i);
    },

    getChildCount: function(t) {
        if (!t) {
            return 0;
        }
        return t.getChildCount();
    },

    getParent: function(t) {
        return t.getParent();
    },

    setParent: function(t, parent) {
        t.setParent(parent);
    },

    getChildIndex: function(t) {
        return t.getChildIndex();
    },

    setChildIndex: function(t, index) {
        t.setChildIndex(index);
    },

    replaceChildren: function(parent, startChildIndex, stopChildIndex, t) {
        if ( parent ) {
            parent.replaceChildren(startChildIndex, stopChildIndex, t);
        }
    }
});


// $ANTLR 3.3 Nov 30, 2010 12:45:30 /Library/WebServer/Documents/calc/Formula.g 2013-09-12 12:24:51

var FormulaLexer = function(input, state) {
// alternate constructor @todo
// public FormulaLexer(CharStream input)
// public FormulaLexer(CharStream input, RecognizerSharedState state) {
    if (!state) {
        state = new org.antlr.runtime.RecognizerSharedState();
    }

    (function(){
    }).call(this);

    this.dfa30 = new FormulaLexer.DFA30(this);
    FormulaLexer.superclass.constructor.call(this, input, state);


};

org.antlr.lang.augmentObject(FormulaLexer, {
    EOF: -1,
    T__113: 113,
    T__114: 114,
    T__115: 115,
    T__116: 116,
    NEGATE: 4,
    ASSIGN: 5,
    FUNCALL: 6,
    MATERIAL: 7,
    UNIT: 8,
    POWER: 9,
    DEFAULTS: 10,
    PARAMS: 11,
    UNITCLUMP: 12,
    ARRAY: 13,
    LINES: 14,
    WHILE: 15,
    IFTHENELSE: 16,
    ELSE: 17,
    FOR: 18,
    FORIN: 19,
    FUNCTION: 20,
    ANONFUNCTION: 21,
    NUMBER: 22,
    LABEL: 23,
    RANGE: 24,
    INNER: 25,
    ASSIGNED: 26,
    SELECTOR: 27,
    DOTSELECTOR: 28,
    NEW: 29,
    TRYCATCH: 30,
    THROW: 31,
    NEWLINE: 32,
    W: 33,
    H: 34,
    I: 35,
    L: 36,
    E: 37,
    WHILESTATEMENT: 38,
    F: 39,
    O: 40,
    R: 41,
    FORSTATEMENT: 42,
    M: 43,
    FROMSTATEMENT: 44,
    N: 45,
    INSTATEMENT: 46,
    T: 47,
    TOSTATEMENT: 48,
    B: 49,
    Y: 50,
    BYSTATEMENT: 51,
    P: 52,
    LOOPSTATEMENT: 53,
    IFSTATEMENT: 54,
    THENSTATEMENT: 55,
    S: 56,
    ELSESTATEMENT: 57,
    U: 58,
    C: 59,
    FUNCTIONSTATEMENT: 60,
    D: 61,
    ENDBLOCK: 62,
    RETURNSTATEMENT: 63,
    NEWSTATEMENT: 64,
    TRYSTATEMENT: 65,
    A: 66,
    CATCHSTATEMENT: 67,
    THROWSTATEMENT: 68,
    IDENT: 69,
    EQUALS: 70,
    PRIMITIVE: 71,
    OR: 72,
    XOR: 73,
    X: 74,
    AND: 75,
    NOTEQUALS: 76,
    LT: 77,
    LTEQ: 78,
    GT: 79,
    GTEQ: 80,
    PLUS: 81,
    MINUS: 82,
    MULT: 83,
    DIV: 84,
    MOD: 85,
    COLON: 86,
    POW: 87,
    NOT: 88,
    LARR: 89,
    RARR: 90,
    LCURL: 91,
    RCURL: 92,
    COMMA: 93,
    STRING: 94,
    INTEGER: 95,
    FLOAT: 96,
    TRUE: 97,
    FALSE: 98,
    PER: 99,
    CUBED: 100,
    SQUARED: 101,
    Q: 102,
    LBRACKET: 103,
    RBRACKET: 104,
    COMMENT: 105,
    LINE_COMMENT: 106,
    WS: 107,
    G: 108,
    J: 109,
    K: 110,
    V: 111,
    Z: 112
});

(function(){
var HIDDEN = org.antlr.runtime.Token.HIDDEN_CHANNEL,
    EOF = org.antlr.runtime.Token.EOF;
org.antlr.lang.extend(FormulaLexer, org.antlr.runtime.Lexer, {
    EOF : -1,
    T__113 : 113,
    T__114 : 114,
    T__115 : 115,
    T__116 : 116,
    NEGATE : 4,
    ASSIGN : 5,
    FUNCALL : 6,
    MATERIAL : 7,
    UNIT : 8,
    POWER : 9,
    DEFAULTS : 10,
    PARAMS : 11,
    UNITCLUMP : 12,
    ARRAY : 13,
    LINES : 14,
    WHILE : 15,
    IFTHENELSE : 16,
    ELSE : 17,
    FOR : 18,
    FORIN : 19,
    FUNCTION : 20,
    ANONFUNCTION : 21,
    NUMBER : 22,
    LABEL : 23,
    RANGE : 24,
    INNER : 25,
    ASSIGNED : 26,
    SELECTOR : 27,
    DOTSELECTOR : 28,
    NEW : 29,
    TRYCATCH : 30,
    THROW : 31,
    NEWLINE : 32,
    W : 33,
    H : 34,
    I : 35,
    L : 36,
    E : 37,
    WHILESTATEMENT : 38,
    F : 39,
    O : 40,
    R : 41,
    FORSTATEMENT : 42,
    M : 43,
    FROMSTATEMENT : 44,
    N : 45,
    INSTATEMENT : 46,
    T : 47,
    TOSTATEMENT : 48,
    B : 49,
    Y : 50,
    BYSTATEMENT : 51,
    P : 52,
    LOOPSTATEMENT : 53,
    IFSTATEMENT : 54,
    THENSTATEMENT : 55,
    S : 56,
    ELSESTATEMENT : 57,
    U : 58,
    C : 59,
    FUNCTIONSTATEMENT : 60,
    D : 61,
    ENDBLOCK : 62,
    RETURNSTATEMENT : 63,
    NEWSTATEMENT : 64,
    TRYSTATEMENT : 65,
    A : 66,
    CATCHSTATEMENT : 67,
    THROWSTATEMENT : 68,
    IDENT : 69,
    EQUALS : 70,
    PRIMITIVE : 71,
    OR : 72,
    XOR : 73,
    X : 74,
    AND : 75,
    NOTEQUALS : 76,
    LT : 77,
    LTEQ : 78,
    GT : 79,
    GTEQ : 80,
    PLUS : 81,
    MINUS : 82,
    MULT : 83,
    DIV : 84,
    MOD : 85,
    COLON : 86,
    POW : 87,
    NOT : 88,
    LARR : 89,
    RARR : 90,
    LCURL : 91,
    RCURL : 92,
    COMMA : 93,
    STRING : 94,
    INTEGER : 95,
    FLOAT : 96,
    TRUE : 97,
    FALSE : 98,
    PER : 99,
    CUBED : 100,
    SQUARED : 101,
    Q : 102,
    LBRACKET : 103,
    RBRACKET : 104,
    COMMENT : 105,
    LINE_COMMENT : 106,
    WS : 107,
    G : 108,
    J : 109,
    K : 110,
    V : 111,
    Z : 112,
    getGrammarFileName: function() { return "/Library/WebServer/Documents/calc/Formula.g"; }
});
org.antlr.lang.augmentObject(FormulaLexer.prototype, {
    // $ANTLR start T__113
    mT__113: function()  {
        try {
            var _type = this.T__113;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:7:8: ( '(' )
            // /Library/WebServer/Documents/calc/Formula.g:7:10: '('
            this.match('('); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "T__113",

    // $ANTLR start T__114
    mT__114: function()  {
        try {
            var _type = this.T__114;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:8:8: ( ')' )
            // /Library/WebServer/Documents/calc/Formula.g:8:10: ')'
            this.match(')'); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "T__114",

    // $ANTLR start T__115
    mT__115: function()  {
        try {
            var _type = this.T__115;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:9:8: ( '<-' )
            // /Library/WebServer/Documents/calc/Formula.g:9:10: '<-'
            this.match("<-"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "T__115",

    // $ANTLR start T__116
    mT__116: function()  {
        try {
            var _type = this.T__116;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:10:8: ( '.' )
            // /Library/WebServer/Documents/calc/Formula.g:10:10: '.'
            this.match('.'); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "T__116",

    // $ANTLR start NEWLINE
    mNEWLINE: function()  {
        try {
            var _type = this.NEWLINE;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:48:2: ( ( ( '\\r' )? '\\n' ) )
            // /Library/WebServer/Documents/calc/Formula.g:48:4: ( ( '\\r' )? '\\n' )
            // /Library/WebServer/Documents/calc/Formula.g:48:4: ( ( '\\r' )? '\\n' )
            // /Library/WebServer/Documents/calc/Formula.g:48:5: ( '\\r' )? '\\n'
            // /Library/WebServer/Documents/calc/Formula.g:48:5: ( '\\r' )?
            var alt1=2;
            var LA1_0 = this.input.LA(1);

            if ( (LA1_0=='\r') ) {
                alt1=1;
            }
            switch (alt1) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:48:5: '\\r'
                    this.match('\r'); 


                    break;

            }

            this.match('\n'); 






            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "NEWLINE",

    // $ANTLR start WHILESTATEMENT
    mWHILESTATEMENT: function()  {
        try {
            var _type = this.WHILESTATEMENT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:52:2: ( W H I L E )
            // /Library/WebServer/Documents/calc/Formula.g:52:4: W H I L E
            this.mW(); 
            this.mH(); 
            this.mI(); 
            this.mL(); 
            this.mE(); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "WHILESTATEMENT",

    // $ANTLR start FORSTATEMENT
    mFORSTATEMENT: function()  {
        try {
            var _type = this.FORSTATEMENT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:56:2: ( F O R )
            // /Library/WebServer/Documents/calc/Formula.g:56:4: F O R
            this.mF(); 
            this.mO(); 
            this.mR(); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "FORSTATEMENT",

    // $ANTLR start FROMSTATEMENT
    mFROMSTATEMENT: function()  {
        try {
            var _type = this.FROMSTATEMENT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:60:2: ( F R O M )
            // /Library/WebServer/Documents/calc/Formula.g:60:4: F R O M
            this.mF(); 
            this.mR(); 
            this.mO(); 
            this.mM(); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "FROMSTATEMENT",

    // $ANTLR start INSTATEMENT
    mINSTATEMENT: function()  {
        try {
            var _type = this.INSTATEMENT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:64:2: ( I N )
            // /Library/WebServer/Documents/calc/Formula.g:64:4: I N
            this.mI(); 
            this.mN(); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "INSTATEMENT",

    // $ANTLR start TOSTATEMENT
    mTOSTATEMENT: function()  {
        try {
            var _type = this.TOSTATEMENT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:68:2: ( T O )
            // /Library/WebServer/Documents/calc/Formula.g:68:4: T O
            this.mT(); 
            this.mO(); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "TOSTATEMENT",

    // $ANTLR start BYSTATEMENT
    mBYSTATEMENT: function()  {
        try {
            var _type = this.BYSTATEMENT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:72:2: ( B Y )
            // /Library/WebServer/Documents/calc/Formula.g:72:4: B Y
            this.mB(); 
            this.mY(); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "BYSTATEMENT",

    // $ANTLR start LOOPSTATEMENT
    mLOOPSTATEMENT: function()  {
        try {
            var _type = this.LOOPSTATEMENT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:76:2: ( L O O P )
            // /Library/WebServer/Documents/calc/Formula.g:76:4: L O O P
            this.mL(); 
            this.mO(); 
            this.mO(); 
            this.mP(); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "LOOPSTATEMENT",

    // $ANTLR start IFSTATEMENT
    mIFSTATEMENT: function()  {
        try {
            var _type = this.IFSTATEMENT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:80:2: ( I F )
            // /Library/WebServer/Documents/calc/Formula.g:80:4: I F
            this.mI(); 
            this.mF(); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "IFSTATEMENT",

    // $ANTLR start THENSTATEMENT
    mTHENSTATEMENT: function()  {
        try {
            var _type = this.THENSTATEMENT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:84:2: ( T H E N )
            // /Library/WebServer/Documents/calc/Formula.g:84:4: T H E N
            this.mT(); 
            this.mH(); 
            this.mE(); 
            this.mN(); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "THENSTATEMENT",

    // $ANTLR start ELSESTATEMENT
    mELSESTATEMENT: function()  {
        try {
            var _type = this.ELSESTATEMENT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:88:2: ( E L S E )
            // /Library/WebServer/Documents/calc/Formula.g:88:4: E L S E
            this.mE(); 
            this.mL(); 
            this.mS(); 
            this.mE(); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "ELSESTATEMENT",

    // $ANTLR start FUNCTIONSTATEMENT
    mFUNCTIONSTATEMENT: function()  {
        try {
            var _type = this.FUNCTIONSTATEMENT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:92:2: ( F U N C T I O N )
            // /Library/WebServer/Documents/calc/Formula.g:92:4: F U N C T I O N
            this.mF(); 
            this.mU(); 
            this.mN(); 
            this.mC(); 
            this.mT(); 
            this.mI(); 
            this.mO(); 
            this.mN(); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "FUNCTIONSTATEMENT",

    // $ANTLR start ENDBLOCK
    mENDBLOCK: function()  {
        try {
            var _type = this.ENDBLOCK;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:96:2: ( E N D )
            // /Library/WebServer/Documents/calc/Formula.g:96:4: E N D
            this.mE(); 
            this.mN(); 
            this.mD(); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "ENDBLOCK",

    // $ANTLR start RETURNSTATEMENT
    mRETURNSTATEMENT: function()  {
        try {
            var _type = this.RETURNSTATEMENT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:100:2: ( R E T U R N )
            // /Library/WebServer/Documents/calc/Formula.g:100:4: R E T U R N
            this.mR(); 
            this.mE(); 
            this.mT(); 
            this.mU(); 
            this.mR(); 
            this.mN(); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "RETURNSTATEMENT",

    // $ANTLR start NEWSTATEMENT
    mNEWSTATEMENT: function()  {
        try {
            var _type = this.NEWSTATEMENT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:104:2: ( N E W )
            // /Library/WebServer/Documents/calc/Formula.g:104:4: N E W
            this.mN(); 
            this.mE(); 
            this.mW(); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "NEWSTATEMENT",

    // $ANTLR start TRYSTATEMENT
    mTRYSTATEMENT: function()  {
        try {
            var _type = this.TRYSTATEMENT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:108:2: ( T R Y )
            // /Library/WebServer/Documents/calc/Formula.g:108:4: T R Y
            this.mT(); 
            this.mR(); 
            this.mY(); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "TRYSTATEMENT",

    // $ANTLR start CATCHSTATEMENT
    mCATCHSTATEMENT: function()  {
        try {
            var _type = this.CATCHSTATEMENT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:112:2: ( C A T C H )
            // /Library/WebServer/Documents/calc/Formula.g:112:4: C A T C H
            this.mC(); 
            this.mA(); 
            this.mT(); 
            this.mC(); 
            this.mH(); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "CATCHSTATEMENT",

    // $ANTLR start THROWSTATEMENT
    mTHROWSTATEMENT: function()  {
        try {
            var _type = this.THROWSTATEMENT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:116:2: ( T H R O W )
            // /Library/WebServer/Documents/calc/Formula.g:116:4: T H R O W
            this.mT(); 
            this.mH(); 
            this.mR(); 
            this.mO(); 
            this.mW(); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "THROWSTATEMENT",

    // $ANTLR start OR
    mOR: function()  {
        try {
            var _type = this.OR;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:190:5: ( '||' | O R )
            var alt2=2;
            var LA2_0 = this.input.LA(1);

            if ( (LA2_0=='|') ) {
                alt2=1;
            }
            else if ( (LA2_0=='O'||LA2_0=='o') ) {
                alt2=2;
            }
            else {
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 2, 0, this.input);

                throw nvae;
            }
            switch (alt2) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:190:8: '||'
                    this.match("||"); 



                    break;
                case 2 :
                    // /Library/WebServer/Documents/calc/Formula.g:190:15: O R
                    this.mO(); 
                    this.mR(); 


                    break;

            }
            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "OR",

    // $ANTLR start XOR
    mXOR: function()  {
        try {
            var _type = this.XOR;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:196:6: ( X O R )
            // /Library/WebServer/Documents/calc/Formula.g:196:9: X O R
            this.mX(); 
            this.mO(); 
            this.mR(); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "XOR",

    // $ANTLR start AND
    mAND: function()  {
        try {
            var _type = this.AND;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:202:5: ( '&&' | A N D )
            var alt3=2;
            var LA3_0 = this.input.LA(1);

            if ( (LA3_0=='&') ) {
                alt3=1;
            }
            else if ( (LA3_0=='A'||LA3_0=='a') ) {
                alt3=2;
            }
            else {
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 3, 0, this.input);

                throw nvae;
            }
            switch (alt3) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:202:8: '&&'
                    this.match("&&"); 



                    break;
                case 2 :
                    // /Library/WebServer/Documents/calc/Formula.g:202:15: A N D
                    this.mA(); 
                    this.mN(); 
                    this.mD(); 


                    break;

            }
            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "AND",

    // $ANTLR start EQUALS
    mEQUALS: function()  {
        try {
            var _type = this.EQUALS;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:209:2: ( '=' | '==' )
            var alt4=2;
            var LA4_0 = this.input.LA(1);

            if ( (LA4_0=='=') ) {
                var LA4_1 = this.input.LA(2);

                if ( (LA4_1=='=') ) {
                    alt4=2;
                }
                else {
                    alt4=1;}
            }
            else {
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 4, 0, this.input);

                throw nvae;
            }
            switch (alt4) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:209:4: '='
                    this.match('='); 


                    break;
                case 2 :
                    // /Library/WebServer/Documents/calc/Formula.g:209:10: '=='
                    this.match("=="); 



                    break;

            }
            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "EQUALS",

    // $ANTLR start NOTEQUALS
    mNOTEQUALS: function()  {
        try {
            var _type = this.NOTEQUALS;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:212:2: ( '!=' | '<>' )
            var alt5=2;
            var LA5_0 = this.input.LA(1);

            if ( (LA5_0=='!') ) {
                alt5=1;
            }
            else if ( (LA5_0=='<') ) {
                alt5=2;
            }
            else {
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 5, 0, this.input);

                throw nvae;
            }
            switch (alt5) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:212:4: '!='
                    this.match("!="); 



                    break;
                case 2 :
                    // /Library/WebServer/Documents/calc/Formula.g:212:11: '<>'
                    this.match("<>"); 



                    break;

            }
            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "NOTEQUALS",

    // $ANTLR start LT
    mLT: function()  {
        try {
            var _type = this.LT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:219:4: ( '<' )
            // /Library/WebServer/Documents/calc/Formula.g:219:6: '<'
            this.match('<'); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "LT",

    // $ANTLR start LTEQ
    mLTEQ: function()  {
        try {
            var _type = this.LTEQ;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:220:6: ( '<=' )
            // /Library/WebServer/Documents/calc/Formula.g:220:8: '<='
            this.match("<="); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "LTEQ",

    // $ANTLR start GT
    mGT: function()  {
        try {
            var _type = this.GT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:221:4: ( '>' )
            // /Library/WebServer/Documents/calc/Formula.g:221:6: '>'
            this.match('>'); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "GT",

    // $ANTLR start GTEQ
    mGTEQ: function()  {
        try {
            var _type = this.GTEQ;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:222:6: ( '>=' )
            // /Library/WebServer/Documents/calc/Formula.g:222:8: '>='
            this.match(">="); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "GTEQ",

    // $ANTLR start PLUS
    mPLUS: function()  {
        try {
            var _type = this.PLUS;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:228:6: ( '+' )
            // /Library/WebServer/Documents/calc/Formula.g:228:8: '+'
            this.match('+'); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "PLUS",

    // $ANTLR start MINUS
    mMINUS: function()  {
        try {
            var _type = this.MINUS;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:229:7: ( '-' )
            // /Library/WebServer/Documents/calc/Formula.g:229:9: '-'
            this.match('-'); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "MINUS",

    // $ANTLR start MULT
    mMULT: function()  {
        try {
            var _type = this.MULT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:235:6: ( '*' )
            // /Library/WebServer/Documents/calc/Formula.g:235:8: '*'
            this.match('*'); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "MULT",

    // $ANTLR start DIV
    mDIV: function()  {
        try {
            var _type = this.DIV;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:236:5: ( '/' )
            // /Library/WebServer/Documents/calc/Formula.g:236:7: '/'
            this.match('/'); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "DIV",

    // $ANTLR start MOD
    mMOD: function()  {
        try {
            var _type = this.MOD;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:237:5: ( '%' | M O D )
            var alt6=2;
            var LA6_0 = this.input.LA(1);

            if ( (LA6_0=='%') ) {
                alt6=1;
            }
            else if ( (LA6_0=='M'||LA6_0=='m') ) {
                alt6=2;
            }
            else {
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 6, 0, this.input);

                throw nvae;
            }
            switch (alt6) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:237:7: '%'
                    this.match('%'); 


                    break;
                case 2 :
                    // /Library/WebServer/Documents/calc/Formula.g:237:13: M O D
                    this.mM(); 
                    this.mO(); 
                    this.mD(); 


                    break;

            }
            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "MOD",

    // $ANTLR start POW
    mPOW: function()  {
        try {
            var _type = this.POW;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:257:5: ( '^' )
            // /Library/WebServer/Documents/calc/Formula.g:257:7: '^'
            this.match('^'); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "POW",

    // $ANTLR start NOT
    mNOT: function()  {
        try {
            var _type = this.NOT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:264:5: ( '!' | N O T )
            var alt7=2;
            var LA7_0 = this.input.LA(1);

            if ( (LA7_0=='!') ) {
                alt7=1;
            }
            else if ( (LA7_0=='N'||LA7_0=='n') ) {
                alt7=2;
            }
            else {
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 7, 0, this.input);

                throw nvae;
            }
            switch (alt7) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:264:7: '!'
                    this.match('!'); 


                    break;
                case 2 :
                    // /Library/WebServer/Documents/calc/Formula.g:264:13: N O T
                    this.mN(); 
                    this.mO(); 
                    this.mT(); 


                    break;

            }
            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "NOT",

    // $ANTLR start LARR
    mLARR: function()  {
        try {
            var _type = this.LARR;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:336:6: ( '\\u00AB' | '<<' )
            var alt8=2;
            var LA8_0 = this.input.LA(1);

            if ( (LA8_0=='\u00AB') ) {
                alt8=1;
            }
            else if ( (LA8_0=='<') ) {
                alt8=2;
            }
            else {
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 8, 0, this.input);

                throw nvae;
            }
            switch (alt8) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:336:8: '\\u00AB'
                    this.match('\u00AB'); 


                    break;
                case 2 :
                    // /Library/WebServer/Documents/calc/Formula.g:336:19: '<<'
                    this.match("<<"); 



                    break;

            }
            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "LARR",

    // $ANTLR start RARR
    mRARR: function()  {
        try {
            var _type = this.RARR;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:337:6: ( '\\u00BB' | '>>' )
            var alt9=2;
            var LA9_0 = this.input.LA(1);

            if ( (LA9_0=='\u00BB') ) {
                alt9=1;
            }
            else if ( (LA9_0=='>') ) {
                alt9=2;
            }
            else {
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 9, 0, this.input);

                throw nvae;
            }
            switch (alt9) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:337:8: '\\u00BB'
                    this.match('\u00BB'); 


                    break;
                case 2 :
                    // /Library/WebServer/Documents/calc/Formula.g:337:19: '>>'
                    this.match(">>"); 



                    break;

            }
            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "RARR",

    // $ANTLR start LCURL
    mLCURL: function()  {
        try {
            var _type = this.LCURL;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:339:8: ( '{' )
            // /Library/WebServer/Documents/calc/Formula.g:339:10: '{'
            this.match('{'); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "LCURL",

    // $ANTLR start RCURL
    mRCURL: function()  {
        try {
            var _type = this.RCURL;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:340:7: ( '}' )
            // /Library/WebServer/Documents/calc/Formula.g:340:9: '}'
            this.match('}'); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "RCURL",

    // $ANTLR start INTEGER
    mINTEGER: function()  {
        try {
            var _type = this.INTEGER;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:347:2: ( ( '0' .. '9' )+ ( 'e' ( '+' | '-' )? ( '0' .. '9' )* )? )
            // /Library/WebServer/Documents/calc/Formula.g:347:5: ( '0' .. '9' )+ ( 'e' ( '+' | '-' )? ( '0' .. '9' )* )?
            // /Library/WebServer/Documents/calc/Formula.g:347:5: ( '0' .. '9' )+
            var cnt10=0;
            loop10:
            do {
                var alt10=2;
                var LA10_0 = this.input.LA(1);

                if ( ((LA10_0>='0' && LA10_0<='9')) ) {
                    alt10=1;
                }


                switch (alt10) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:347:6: '0' .. '9'
                    this.matchRange('0','9'); 


                    break;

                default :
                    if ( cnt10 >= 1 ) {
                        break loop10;
                    }
                        var eee = new org.antlr.runtime.EarlyExitException(10, this.input);
                        throw eee;
                }
                cnt10++;
            } while (true);

            // /Library/WebServer/Documents/calc/Formula.g:347:17: ( 'e' ( '+' | '-' )? ( '0' .. '9' )* )?
            var alt13=2;
            var LA13_0 = this.input.LA(1);

            if ( (LA13_0=='e') ) {
                alt13=1;
            }
            switch (alt13) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:347:18: 'e' ( '+' | '-' )? ( '0' .. '9' )*
                    this.match('e'); 
                    // /Library/WebServer/Documents/calc/Formula.g:347:22: ( '+' | '-' )?
                    var alt11=2;
                    var LA11_0 = this.input.LA(1);

                    if ( (LA11_0=='+'||LA11_0=='-') ) {
                        alt11=1;
                    }
                    switch (alt11) {
                        case 1 :
                            // /Library/WebServer/Documents/calc/Formula.g:
                            if ( this.input.LA(1)=='+'||this.input.LA(1)=='-' ) {
                                this.input.consume();

                            }
                            else {
                                var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                                this.recover(mse);
                                throw mse;}



                            break;

                    }

                    // /Library/WebServer/Documents/calc/Formula.g:347:33: ( '0' .. '9' )*
                    loop12:
                    do {
                        var alt12=2;
                        var LA12_0 = this.input.LA(1);

                        if ( ((LA12_0>='0' && LA12_0<='9')) ) {
                            alt12=1;
                        }


                        switch (alt12) {
                        case 1 :
                            // /Library/WebServer/Documents/calc/Formula.g:347:34: '0' .. '9'
                            this.matchRange('0','9'); 


                            break;

                        default :
                            break loop12;
                        }
                    } while (true);



                    break;

            }




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "INTEGER",

    // $ANTLR start FLOAT
    mFLOAT: function()  {
        try {
            var _type = this.FLOAT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:351:2: ( ( '0' .. '9' )* '.' ( '0' .. '9' )+ ( 'e' ( '+' | '-' )? ( '0' .. '9' )* )? )
            // /Library/WebServer/Documents/calc/Formula.g:351:5: ( '0' .. '9' )* '.' ( '0' .. '9' )+ ( 'e' ( '+' | '-' )? ( '0' .. '9' )* )?
            // /Library/WebServer/Documents/calc/Formula.g:351:5: ( '0' .. '9' )*
            loop14:
            do {
                var alt14=2;
                var LA14_0 = this.input.LA(1);

                if ( ((LA14_0>='0' && LA14_0<='9')) ) {
                    alt14=1;
                }


                switch (alt14) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:351:6: '0' .. '9'
                    this.matchRange('0','9'); 


                    break;

                default :
                    break loop14;
                }
            } while (true);

            this.match('.'); 
            // /Library/WebServer/Documents/calc/Formula.g:351:21: ( '0' .. '9' )+
            var cnt15=0;
            loop15:
            do {
                var alt15=2;
                var LA15_0 = this.input.LA(1);

                if ( ((LA15_0>='0' && LA15_0<='9')) ) {
                    alt15=1;
                }


                switch (alt15) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:351:22: '0' .. '9'
                    this.matchRange('0','9'); 


                    break;

                default :
                    if ( cnt15 >= 1 ) {
                        break loop15;
                    }
                        var eee = new org.antlr.runtime.EarlyExitException(15, this.input);
                        throw eee;
                }
                cnt15++;
            } while (true);

            // /Library/WebServer/Documents/calc/Formula.g:351:33: ( 'e' ( '+' | '-' )? ( '0' .. '9' )* )?
            var alt18=2;
            var LA18_0 = this.input.LA(1);

            if ( (LA18_0=='e') ) {
                alt18=1;
            }
            switch (alt18) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:351:34: 'e' ( '+' | '-' )? ( '0' .. '9' )*
                    this.match('e'); 
                    // /Library/WebServer/Documents/calc/Formula.g:351:38: ( '+' | '-' )?
                    var alt16=2;
                    var LA16_0 = this.input.LA(1);

                    if ( (LA16_0=='+'||LA16_0=='-') ) {
                        alt16=1;
                    }
                    switch (alt16) {
                        case 1 :
                            // /Library/WebServer/Documents/calc/Formula.g:
                            if ( this.input.LA(1)=='+'||this.input.LA(1)=='-' ) {
                                this.input.consume();

                            }
                            else {
                                var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                                this.recover(mse);
                                throw mse;}



                            break;

                    }

                    // /Library/WebServer/Documents/calc/Formula.g:351:49: ( '0' .. '9' )*
                    loop17:
                    do {
                        var alt17=2;
                        var LA17_0 = this.input.LA(1);

                        if ( ((LA17_0>='0' && LA17_0<='9')) ) {
                            alt17=1;
                        }


                        switch (alt17) {
                        case 1 :
                            // /Library/WebServer/Documents/calc/Formula.g:351:50: '0' .. '9'
                            this.matchRange('0','9'); 


                            break;

                        default :
                            break loop17;
                        }
                    } while (true);



                    break;

            }




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "FLOAT",

    // $ANTLR start TRUE
    mTRUE: function()  {
        try {
            var _type = this.TRUE;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:360:2: ( T R U E )
            // /Library/WebServer/Documents/calc/Formula.g:360:4: T R U E
            this.mT(); 
            this.mR(); 
            this.mU(); 
            this.mE(); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "TRUE",

    // $ANTLR start FALSE
    mFALSE: function()  {
        try {
            var _type = this.FALSE;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:364:2: ( F A L S E )
            // /Library/WebServer/Documents/calc/Formula.g:364:5: F A L S E
            this.mF(); 
            this.mA(); 
            this.mL(); 
            this.mS(); 
            this.mE(); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "FALSE",

    // $ANTLR start PER
    mPER: function()  {
        try {
            var _type = this.PER;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:371:2: ( P E R )
            // /Library/WebServer/Documents/calc/Formula.g:371:4: P E R
            this.mP(); 
            this.mE(); 
            this.mR(); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "PER",

    // $ANTLR start SQUARED
    mSQUARED: function()  {
        try {
            var _type = this.SQUARED;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:386:9: ( S Q U A R E D )
            // /Library/WebServer/Documents/calc/Formula.g:386:12: S Q U A R E D
            this.mS(); 
            this.mQ(); 
            this.mU(); 
            this.mA(); 
            this.mR(); 
            this.mE(); 
            this.mD(); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "SQUARED",

    // $ANTLR start CUBED
    mCUBED: function()  {
        try {
            var _type = this.CUBED;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:387:7: ( C U B E D )
            // /Library/WebServer/Documents/calc/Formula.g:387:9: C U B E D
            this.mC(); 
            this.mU(); 
            this.mB(); 
            this.mE(); 
            this.mD(); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "CUBED",

    // $ANTLR start IDENT
    mIDENT: function()  {
        try {
            var _type = this.IDENT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:403:2: ( ( 'a' .. 'z' | 'A' .. 'Z' ) ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )* )
            // /Library/WebServer/Documents/calc/Formula.g:403:4: ( 'a' .. 'z' | 'A' .. 'Z' ) ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
            if ( (this.input.LA(1)>='A' && this.input.LA(1)<='Z')||(this.input.LA(1)>='a' && this.input.LA(1)<='z') ) {
                this.input.consume();

            }
            else {
                var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                this.recover(mse);
                throw mse;}

            // /Library/WebServer/Documents/calc/Formula.g:403:26: ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
            loop19:
            do {
                var alt19=2;
                var LA19_0 = this.input.LA(1);

                if ( ((LA19_0>='0' && LA19_0<='9')||(LA19_0>='A' && LA19_0<='Z')||LA19_0=='_'||(LA19_0>='a' && LA19_0<='z')) ) {
                    alt19=1;
                }


                switch (alt19) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:
                    if ( (this.input.LA(1)>='0' && this.input.LA(1)<='9')||(this.input.LA(1)>='A' && this.input.LA(1)<='Z')||this.input.LA(1)=='_'||(this.input.LA(1)>='a' && this.input.LA(1)<='z') ) {
                        this.input.consume();

                    }
                    else {
                        var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                        this.recover(mse);
                        throw mse;}



                    break;

                default :
                    break loop19;
                }
            } while (true);




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "IDENT",

    // $ANTLR start PRIMITIVE
    mPRIMITIVE: function()  {
        try {
            var _type = this.PRIMITIVE;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:411:2: ( LBRACKET (~ '[' ) ( . )* RBRACKET | LBRACKET LBRACKET ( . )* RBRACKET RBRACKET )
            var alt22=2;
            var LA22_0 = this.input.LA(1);

            if ( (LA22_0=='[') ) {
                var LA22_1 = this.input.LA(2);

                if ( ((LA22_1>='\u0000' && LA22_1<='Z')||(LA22_1>='\\' && LA22_1<='\uFFFF')) ) {
                    alt22=1;
                }
                else if ( (LA22_1=='[') ) {
                    alt22=2;
                }
                else {
                    var nvae =
                        new org.antlr.runtime.NoViableAltException("", 22, 1, this.input);

                    throw nvae;
                }
            }
            else {
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 22, 0, this.input);

                throw nvae;
            }
            switch (alt22) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:411:4: LBRACKET (~ '[' ) ( . )* RBRACKET
                    this.mLBRACKET(); 
                    // /Library/WebServer/Documents/calc/Formula.g:411:13: (~ '[' )
                    // /Library/WebServer/Documents/calc/Formula.g:411:14: ~ '['
                    if ( (this.input.LA(1)>='\u0000' && this.input.LA(1)<='Z')||(this.input.LA(1)>='\\' && this.input.LA(1)<='\uFFFF') ) {
                        this.input.consume();

                    }
                    else {
                        var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                        this.recover(mse);
                        throw mse;}




                    // /Library/WebServer/Documents/calc/Formula.g:411:20: ( . )*
                    loop20:
                    do {
                        var alt20=2;
                        var LA20_0 = this.input.LA(1);

                        if ( (LA20_0==']') ) {
                            alt20=2;
                        }
                        else if ( ((LA20_0>='\u0000' && LA20_0<='\\')||(LA20_0>='^' && LA20_0<='\uFFFF')) ) {
                            alt20=1;
                        }


                        switch (alt20) {
                        case 1 :
                            // /Library/WebServer/Documents/calc/Formula.g:411:20: .
                            this.matchAny(); 


                            break;

                        default :
                            break loop20;
                        }
                    } while (true);

                    this.mRBRACKET(); 


                    break;
                case 2 :
                    // /Library/WebServer/Documents/calc/Formula.g:412:5: LBRACKET LBRACKET ( . )* RBRACKET RBRACKET
                    this.mLBRACKET(); 
                    this.mLBRACKET(); 
                    // /Library/WebServer/Documents/calc/Formula.g:412:24: ( . )*
                    loop21:
                    do {
                        var alt21=2;
                        var LA21_0 = this.input.LA(1);

                        if ( (LA21_0==']') ) {
                            alt21=2;
                        }
                        else if ( ((LA21_0>='\u0000' && LA21_0<='\\')||(LA21_0>='^' && LA21_0<='\uFFFF')) ) {
                            alt21=1;
                        }


                        switch (alt21) {
                        case 1 :
                            // /Library/WebServer/Documents/calc/Formula.g:412:24: .
                            this.matchAny(); 


                            break;

                        default :
                            break loop21;
                        }
                    } while (true);

                    this.mRBRACKET(); 
                    this.mRBRACKET(); 


                    break;

            }
            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "PRIMITIVE",

    // $ANTLR start LBRACKET
    mLBRACKET: function()  {
        try {
            var _type = this.LBRACKET;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:416:2: ( '[' )
            // /Library/WebServer/Documents/calc/Formula.g:416:5: '['
            this.match('['); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "LBRACKET",

    // $ANTLR start RBRACKET
    mRBRACKET: function()  {
        try {
            var _type = this.RBRACKET;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:419:2: ( ']' )
            // /Library/WebServer/Documents/calc/Formula.g:419:4: ']'
            this.match(']'); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "RBRACKET",

    // $ANTLR start COMMENT
    mCOMMENT: function()  {
        try {
            var _type = this.COMMENT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:422:5: ( '/*' ( options {greedy=false; } : . )* '*/' )
            // /Library/WebServer/Documents/calc/Formula.g:422:9: '/*' ( options {greedy=false; } : . )* '*/'
            this.match("/*"); 

            // /Library/WebServer/Documents/calc/Formula.g:422:14: ( options {greedy=false; } : . )*
            loop23:
            do {
                var alt23=2;
                var LA23_0 = this.input.LA(1);

                if ( (LA23_0=='*') ) {
                    var LA23_1 = this.input.LA(2);

                    if ( (LA23_1=='/') ) {
                        alt23=2;
                    }
                    else if ( ((LA23_1>='\u0000' && LA23_1<='.')||(LA23_1>='0' && LA23_1<='\uFFFF')) ) {
                        alt23=1;
                    }


                }
                else if ( ((LA23_0>='\u0000' && LA23_0<=')')||(LA23_0>='+' && LA23_0<='\uFFFF')) ) {
                    alt23=1;
                }


                switch (alt23) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:422:42: .
                    this.matchAny(); 


                    break;

                default :
                    break loop23;
                }
            } while (true);

            this.match("*/"); 

            _channel=HIDDEN;



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "COMMENT",

    // $ANTLR start LINE_COMMENT
    mLINE_COMMENT: function()  {
        try {
            var _type = this.LINE_COMMENT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:426:5: ( ( '//' | '#' ) (~ ( '\\n' | '\\r' ) )* )
            // /Library/WebServer/Documents/calc/Formula.g:426:7: ( '//' | '#' ) (~ ( '\\n' | '\\r' ) )*
            // /Library/WebServer/Documents/calc/Formula.g:426:7: ( '//' | '#' )
            var alt24=2;
            var LA24_0 = this.input.LA(1);

            if ( (LA24_0=='/') ) {
                alt24=1;
            }
            else if ( (LA24_0=='#') ) {
                alt24=2;
            }
            else {
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 24, 0, this.input);

                throw nvae;
            }
            switch (alt24) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:426:8: '//'
                    this.match("//"); 



                    break;
                case 2 :
                    // /Library/WebServer/Documents/calc/Formula.g:426:13: '#'
                    this.match('#'); 


                    break;

            }

            // /Library/WebServer/Documents/calc/Formula.g:426:18: (~ ( '\\n' | '\\r' ) )*
            loop25:
            do {
                var alt25=2;
                var LA25_0 = this.input.LA(1);

                if ( ((LA25_0>='\u0000' && LA25_0<='\t')||(LA25_0>='\u000B' && LA25_0<='\f')||(LA25_0>='\u000E' && LA25_0<='\uFFFF')) ) {
                    alt25=1;
                }


                switch (alt25) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:426:19: ~ ( '\\n' | '\\r' )
                    if ( (this.input.LA(1)>='\u0000' && this.input.LA(1)<='\t')||(this.input.LA(1)>='\u000B' && this.input.LA(1)<='\f')||(this.input.LA(1)>='\u000E' && this.input.LA(1)<='\uFFFF') ) {
                        this.input.consume();

                    }
                    else {
                        var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                        this.recover(mse);
                        throw mse;}



                    break;

                default :
                    break loop25;
                }
            } while (true);

            _channel=HIDDEN;



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "LINE_COMMENT",

    // $ANTLR start COLON
    mCOLON: function()  {
        try {
            var _type = this.COLON;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:429:2: ( ':' )
            // /Library/WebServer/Documents/calc/Formula.g:429:4: ':'
            this.match(':'); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "COLON",

    // $ANTLR start WS
    mWS: function()  {
        try {
            var _type = this.WS;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:435:2: ( ( ' ' | '\\t' | '\\u000C' )+ )
            // /Library/WebServer/Documents/calc/Formula.g:435:5: ( ' ' | '\\t' | '\\u000C' )+
            // /Library/WebServer/Documents/calc/Formula.g:435:5: ( ' ' | '\\t' | '\\u000C' )+
            var cnt26=0;
            loop26:
            do {
                var alt26=2;
                var LA26_0 = this.input.LA(1);

                if ( (LA26_0=='\t'||LA26_0=='\f'||LA26_0==' ') ) {
                    alt26=1;
                }


                switch (alt26) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:
                    if ( this.input.LA(1)=='\t'||this.input.LA(1)=='\f'||this.input.LA(1)==' ' ) {
                        this.input.consume();

                    }
                    else {
                        var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                        this.recover(mse);
                        throw mse;}



                    break;

                default :
                    if ( cnt26 >= 1 ) {
                        break loop26;
                    }
                        var eee = new org.antlr.runtime.EarlyExitException(26, this.input);
                        throw eee;
                }
                cnt26++;
            } while (true);

            _channel=HIDDEN;



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "WS",

    // $ANTLR start A
    mA: function()  {
        try {
            // /Library/WebServer/Documents/calc/Formula.g:439:11: ( ( 'a' | 'A' ) )
            // /Library/WebServer/Documents/calc/Formula.g:439:12: ( 'a' | 'A' )
            if ( this.input.LA(1)=='A'||this.input.LA(1)=='a' ) {
                this.input.consume();

            }
            else {
                var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                this.recover(mse);
                throw mse;}




        }
        finally {
        }
    },
    // $ANTLR end "A",

    // $ANTLR start B
    mB: function()  {
        try {
            // /Library/WebServer/Documents/calc/Formula.g:440:11: ( ( 'b' | 'B' ) )
            // /Library/WebServer/Documents/calc/Formula.g:440:12: ( 'b' | 'B' )
            if ( this.input.LA(1)=='B'||this.input.LA(1)=='b' ) {
                this.input.consume();

            }
            else {
                var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                this.recover(mse);
                throw mse;}




        }
        finally {
        }
    },
    // $ANTLR end "B",

    // $ANTLR start C
    mC: function()  {
        try {
            // /Library/WebServer/Documents/calc/Formula.g:441:11: ( ( 'c' | 'C' ) )
            // /Library/WebServer/Documents/calc/Formula.g:441:12: ( 'c' | 'C' )
            if ( this.input.LA(1)=='C'||this.input.LA(1)=='c' ) {
                this.input.consume();

            }
            else {
                var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                this.recover(mse);
                throw mse;}




        }
        finally {
        }
    },
    // $ANTLR end "C",

    // $ANTLR start D
    mD: function()  {
        try {
            // /Library/WebServer/Documents/calc/Formula.g:442:11: ( ( 'd' | 'D' ) )
            // /Library/WebServer/Documents/calc/Formula.g:442:12: ( 'd' | 'D' )
            if ( this.input.LA(1)=='D'||this.input.LA(1)=='d' ) {
                this.input.consume();

            }
            else {
                var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                this.recover(mse);
                throw mse;}




        }
        finally {
        }
    },
    // $ANTLR end "D",

    // $ANTLR start E
    mE: function()  {
        try {
            // /Library/WebServer/Documents/calc/Formula.g:443:11: ( ( 'e' | 'E' ) )
            // /Library/WebServer/Documents/calc/Formula.g:443:12: ( 'e' | 'E' )
            if ( this.input.LA(1)=='E'||this.input.LA(1)=='e' ) {
                this.input.consume();

            }
            else {
                var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                this.recover(mse);
                throw mse;}




        }
        finally {
        }
    },
    // $ANTLR end "E",

    // $ANTLR start F
    mF: function()  {
        try {
            // /Library/WebServer/Documents/calc/Formula.g:444:11: ( ( 'f' | 'F' ) )
            // /Library/WebServer/Documents/calc/Formula.g:444:12: ( 'f' | 'F' )
            if ( this.input.LA(1)=='F'||this.input.LA(1)=='f' ) {
                this.input.consume();

            }
            else {
                var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                this.recover(mse);
                throw mse;}




        }
        finally {
        }
    },
    // $ANTLR end "F",

    // $ANTLR start G
    mG: function()  {
        try {
            // /Library/WebServer/Documents/calc/Formula.g:445:11: ( ( 'g' | 'G' ) )
            // /Library/WebServer/Documents/calc/Formula.g:445:12: ( 'g' | 'G' )
            if ( this.input.LA(1)=='G'||this.input.LA(1)=='g' ) {
                this.input.consume();

            }
            else {
                var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                this.recover(mse);
                throw mse;}




        }
        finally {
        }
    },
    // $ANTLR end "G",

    // $ANTLR start H
    mH: function()  {
        try {
            // /Library/WebServer/Documents/calc/Formula.g:446:11: ( ( 'h' | 'H' ) )
            // /Library/WebServer/Documents/calc/Formula.g:446:12: ( 'h' | 'H' )
            if ( this.input.LA(1)=='H'||this.input.LA(1)=='h' ) {
                this.input.consume();

            }
            else {
                var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                this.recover(mse);
                throw mse;}




        }
        finally {
        }
    },
    // $ANTLR end "H",

    // $ANTLR start I
    mI: function()  {
        try {
            // /Library/WebServer/Documents/calc/Formula.g:447:11: ( ( 'i' | 'I' ) )
            // /Library/WebServer/Documents/calc/Formula.g:447:12: ( 'i' | 'I' )
            if ( this.input.LA(1)=='I'||this.input.LA(1)=='i' ) {
                this.input.consume();

            }
            else {
                var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                this.recover(mse);
                throw mse;}




        }
        finally {
        }
    },
    // $ANTLR end "I",

    // $ANTLR start J
    mJ: function()  {
        try {
            // /Library/WebServer/Documents/calc/Formula.g:448:11: ( ( 'j' | 'J' ) )
            // /Library/WebServer/Documents/calc/Formula.g:448:12: ( 'j' | 'J' )
            if ( this.input.LA(1)=='J'||this.input.LA(1)=='j' ) {
                this.input.consume();

            }
            else {
                var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                this.recover(mse);
                throw mse;}




        }
        finally {
        }
    },
    // $ANTLR end "J",

    // $ANTLR start K
    mK: function()  {
        try {
            // /Library/WebServer/Documents/calc/Formula.g:449:11: ( ( 'k' | 'K' ) )
            // /Library/WebServer/Documents/calc/Formula.g:449:12: ( 'k' | 'K' )
            if ( this.input.LA(1)=='K'||this.input.LA(1)=='k' ) {
                this.input.consume();

            }
            else {
                var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                this.recover(mse);
                throw mse;}




        }
        finally {
        }
    },
    // $ANTLR end "K",

    // $ANTLR start L
    mL: function()  {
        try {
            // /Library/WebServer/Documents/calc/Formula.g:450:11: ( ( 'l' | 'L' ) )
            // /Library/WebServer/Documents/calc/Formula.g:450:12: ( 'l' | 'L' )
            if ( this.input.LA(1)=='L'||this.input.LA(1)=='l' ) {
                this.input.consume();

            }
            else {
                var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                this.recover(mse);
                throw mse;}




        }
        finally {
        }
    },
    // $ANTLR end "L",

    // $ANTLR start M
    mM: function()  {
        try {
            // /Library/WebServer/Documents/calc/Formula.g:451:11: ( ( 'm' | 'M' ) )
            // /Library/WebServer/Documents/calc/Formula.g:451:12: ( 'm' | 'M' )
            if ( this.input.LA(1)=='M'||this.input.LA(1)=='m' ) {
                this.input.consume();

            }
            else {
                var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                this.recover(mse);
                throw mse;}




        }
        finally {
        }
    },
    // $ANTLR end "M",

    // $ANTLR start N
    mN: function()  {
        try {
            // /Library/WebServer/Documents/calc/Formula.g:452:11: ( ( 'n' | 'N' ) )
            // /Library/WebServer/Documents/calc/Formula.g:452:12: ( 'n' | 'N' )
            if ( this.input.LA(1)=='N'||this.input.LA(1)=='n' ) {
                this.input.consume();

            }
            else {
                var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                this.recover(mse);
                throw mse;}




        }
        finally {
        }
    },
    // $ANTLR end "N",

    // $ANTLR start O
    mO: function()  {
        try {
            // /Library/WebServer/Documents/calc/Formula.g:453:11: ( ( 'o' | 'O' ) )
            // /Library/WebServer/Documents/calc/Formula.g:453:12: ( 'o' | 'O' )
            if ( this.input.LA(1)=='O'||this.input.LA(1)=='o' ) {
                this.input.consume();

            }
            else {
                var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                this.recover(mse);
                throw mse;}




        }
        finally {
        }
    },
    // $ANTLR end "O",

    // $ANTLR start P
    mP: function()  {
        try {
            // /Library/WebServer/Documents/calc/Formula.g:454:11: ( ( 'p' | 'P' ) )
            // /Library/WebServer/Documents/calc/Formula.g:454:12: ( 'p' | 'P' )
            if ( this.input.LA(1)=='P'||this.input.LA(1)=='p' ) {
                this.input.consume();

            }
            else {
                var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                this.recover(mse);
                throw mse;}




        }
        finally {
        }
    },
    // $ANTLR end "P",

    // $ANTLR start Q
    mQ: function()  {
        try {
            // /Library/WebServer/Documents/calc/Formula.g:455:11: ( ( 'q' | 'Q' ) )
            // /Library/WebServer/Documents/calc/Formula.g:455:12: ( 'q' | 'Q' )
            if ( this.input.LA(1)=='Q'||this.input.LA(1)=='q' ) {
                this.input.consume();

            }
            else {
                var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                this.recover(mse);
                throw mse;}




        }
        finally {
        }
    },
    // $ANTLR end "Q",

    // $ANTLR start R
    mR: function()  {
        try {
            // /Library/WebServer/Documents/calc/Formula.g:456:11: ( ( 'r' | 'R' ) )
            // /Library/WebServer/Documents/calc/Formula.g:456:12: ( 'r' | 'R' )
            if ( this.input.LA(1)=='R'||this.input.LA(1)=='r' ) {
                this.input.consume();

            }
            else {
                var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                this.recover(mse);
                throw mse;}




        }
        finally {
        }
    },
    // $ANTLR end "R",

    // $ANTLR start S
    mS: function()  {
        try {
            // /Library/WebServer/Documents/calc/Formula.g:457:11: ( ( 's' | 'S' ) )
            // /Library/WebServer/Documents/calc/Formula.g:457:12: ( 's' | 'S' )
            if ( this.input.LA(1)=='S'||this.input.LA(1)=='s' ) {
                this.input.consume();

            }
            else {
                var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                this.recover(mse);
                throw mse;}




        }
        finally {
        }
    },
    // $ANTLR end "S",

    // $ANTLR start T
    mT: function()  {
        try {
            // /Library/WebServer/Documents/calc/Formula.g:458:11: ( ( 't' | 'T' ) )
            // /Library/WebServer/Documents/calc/Formula.g:458:12: ( 't' | 'T' )
            if ( this.input.LA(1)=='T'||this.input.LA(1)=='t' ) {
                this.input.consume();

            }
            else {
                var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                this.recover(mse);
                throw mse;}




        }
        finally {
        }
    },
    // $ANTLR end "T",

    // $ANTLR start U
    mU: function()  {
        try {
            // /Library/WebServer/Documents/calc/Formula.g:459:11: ( ( 'u' | 'U' ) )
            // /Library/WebServer/Documents/calc/Formula.g:459:12: ( 'u' | 'U' )
            if ( this.input.LA(1)=='U'||this.input.LA(1)=='u' ) {
                this.input.consume();

            }
            else {
                var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                this.recover(mse);
                throw mse;}




        }
        finally {
        }
    },
    // $ANTLR end "U",

    // $ANTLR start V
    mV: function()  {
        try {
            // /Library/WebServer/Documents/calc/Formula.g:460:11: ( ( 'v' | 'V' ) )
            // /Library/WebServer/Documents/calc/Formula.g:460:12: ( 'v' | 'V' )
            if ( this.input.LA(1)=='V'||this.input.LA(1)=='v' ) {
                this.input.consume();

            }
            else {
                var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                this.recover(mse);
                throw mse;}




        }
        finally {
        }
    },
    // $ANTLR end "V",

    // $ANTLR start W
    mW: function()  {
        try {
            // /Library/WebServer/Documents/calc/Formula.g:461:11: ( ( 'w' | 'W' ) )
            // /Library/WebServer/Documents/calc/Formula.g:461:12: ( 'w' | 'W' )
            if ( this.input.LA(1)=='W'||this.input.LA(1)=='w' ) {
                this.input.consume();

            }
            else {
                var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                this.recover(mse);
                throw mse;}




        }
        finally {
        }
    },
    // $ANTLR end "W",

    // $ANTLR start X
    mX: function()  {
        try {
            // /Library/WebServer/Documents/calc/Formula.g:462:11: ( ( 'x' | 'X' ) )
            // /Library/WebServer/Documents/calc/Formula.g:462:12: ( 'x' | 'X' )
            if ( this.input.LA(1)=='X'||this.input.LA(1)=='x' ) {
                this.input.consume();

            }
            else {
                var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                this.recover(mse);
                throw mse;}




        }
        finally {
        }
    },
    // $ANTLR end "X",

    // $ANTLR start Y
    mY: function()  {
        try {
            // /Library/WebServer/Documents/calc/Formula.g:463:11: ( ( 'y' | 'Y' ) )
            // /Library/WebServer/Documents/calc/Formula.g:463:12: ( 'y' | 'Y' )
            if ( this.input.LA(1)=='Y'||this.input.LA(1)=='y' ) {
                this.input.consume();

            }
            else {
                var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                this.recover(mse);
                throw mse;}




        }
        finally {
        }
    },
    // $ANTLR end "Y",

    // $ANTLR start Z
    mZ: function()  {
        try {
            // /Library/WebServer/Documents/calc/Formula.g:464:11: ( ( 'z' | 'Z' ) )
            // /Library/WebServer/Documents/calc/Formula.g:464:12: ( 'z' | 'Z' )
            if ( this.input.LA(1)=='Z'||this.input.LA(1)=='z' ) {
                this.input.consume();

            }
            else {
                var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                this.recover(mse);
                throw mse;}




        }
        finally {
        }
    },
    // $ANTLR end "Z",

    // $ANTLR start COMMA
    mCOMMA: function()  {
        try {
            var _type = this.COMMA;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:471:1: ( ',' )
            // /Library/WebServer/Documents/calc/Formula.g:471:3: ','
            this.match(','); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "COMMA",

    // $ANTLR start STRING
    mSTRING: function()  {
        try {
            var _type = this.STRING;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // /Library/WebServer/Documents/calc/Formula.g:474:8: ( '\\'' ( . )* '\\'' | '\"' ( '\\\\\\\"' | ~ '\\\"' )* '\"' )
            var alt29=2;
            var LA29_0 = this.input.LA(1);

            if ( (LA29_0=='\'') ) {
                alt29=1;
            }
            else if ( (LA29_0=='\"') ) {
                alt29=2;
            }
            else {
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 29, 0, this.input);

                throw nvae;
            }
            switch (alt29) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:475:1: '\\'' ( . )* '\\''
                    this.match('\''); 
                    // /Library/WebServer/Documents/calc/Formula.g:475:6: ( . )*
                    loop27:
                    do {
                        var alt27=2;
                        var LA27_0 = this.input.LA(1);

                        if ( (LA27_0=='\'') ) {
                            alt27=2;
                        }
                        else if ( ((LA27_0>='\u0000' && LA27_0<='&')||(LA27_0>='(' && LA27_0<='\uFFFF')) ) {
                            alt27=1;
                        }


                        switch (alt27) {
                        case 1 :
                            // /Library/WebServer/Documents/calc/Formula.g:475:6: .
                            this.matchAny(); 


                            break;

                        default :
                            break loop27;
                        }
                    } while (true);

                    this.match('\''); 


                    break;
                case 2 :
                    // /Library/WebServer/Documents/calc/Formula.g:476:6: '\"' ( '\\\\\\\"' | ~ '\\\"' )* '\"'
                    this.match('\"'); 
                    // /Library/WebServer/Documents/calc/Formula.g:476:10: ( '\\\\\\\"' | ~ '\\\"' )*
                    loop28:
                    do {
                        var alt28=3;
                        var LA28_0 = this.input.LA(1);

                        if ( (LA28_0=='\\') ) {
                            var LA28_2 = this.input.LA(2);

                            if ( (LA28_2=='\"') ) {
                                var LA28_4 = this.input.LA(3);

                                if ( ((LA28_4>='\u0000' && LA28_4<='\uFFFF')) ) {
                                    alt28=1;
                                }

                                else {
                                    alt28=2;
                                }

                            }
                            else if ( ((LA28_2>='\u0000' && LA28_2<='!')||(LA28_2>='#' && LA28_2<='\uFFFF')) ) {
                                alt28=2;
                            }


                        }
                        else if ( ((LA28_0>='\u0000' && LA28_0<='!')||(LA28_0>='#' && LA28_0<='[')||(LA28_0>=']' && LA28_0<='\uFFFF')) ) {
                            alt28=2;
                        }


                        switch (alt28) {
                        case 1 :
                            // /Library/WebServer/Documents/calc/Formula.g:476:11: '\\\\\\\"'
                            this.match("\\\""); 



                            break;
                        case 2 :
                            // /Library/WebServer/Documents/calc/Formula.g:476:18: ~ '\\\"'
                            if ( (this.input.LA(1)>='\u0000' && this.input.LA(1)<='!')||(this.input.LA(1)>='#' && this.input.LA(1)<='\uFFFF') ) {
                                this.input.consume();

                            }
                            else {
                                var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                                this.recover(mse);
                                throw mse;}



                            break;

                        default :
                            break loop28;
                        }
                    } while (true);

                    this.match('\"'); 


                    break;

            }
            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "STRING",

    mTokens: function() {
        // /Library/WebServer/Documents/calc/Formula.g:1:8: ( T__113 | T__114 | T__115 | T__116 | NEWLINE | WHILESTATEMENT | FORSTATEMENT | FROMSTATEMENT | INSTATEMENT | TOSTATEMENT | BYSTATEMENT | LOOPSTATEMENT | IFSTATEMENT | THENSTATEMENT | ELSESTATEMENT | FUNCTIONSTATEMENT | ENDBLOCK | RETURNSTATEMENT | NEWSTATEMENT | TRYSTATEMENT | CATCHSTATEMENT | THROWSTATEMENT | OR | XOR | AND | EQUALS | NOTEQUALS | LT | LTEQ | GT | GTEQ | PLUS | MINUS | MULT | DIV | MOD | POW | NOT | LARR | RARR | LCURL | RCURL | INTEGER | FLOAT | TRUE | FALSE | PER | SQUARED | CUBED | IDENT | PRIMITIVE | LBRACKET | RBRACKET | COMMENT | LINE_COMMENT | COLON | WS | COMMA | STRING )
        var alt30=59;
        alt30 = this.dfa30.predict(this.input);
        switch (alt30) {
            case 1 :
                // /Library/WebServer/Documents/calc/Formula.g:1:10: T__113
                this.mT__113(); 


                break;
            case 2 :
                // /Library/WebServer/Documents/calc/Formula.g:1:17: T__114
                this.mT__114(); 


                break;
            case 3 :
                // /Library/WebServer/Documents/calc/Formula.g:1:24: T__115
                this.mT__115(); 


                break;
            case 4 :
                // /Library/WebServer/Documents/calc/Formula.g:1:31: T__116
                this.mT__116(); 


                break;
            case 5 :
                // /Library/WebServer/Documents/calc/Formula.g:1:38: NEWLINE
                this.mNEWLINE(); 


                break;
            case 6 :
                // /Library/WebServer/Documents/calc/Formula.g:1:46: WHILESTATEMENT
                this.mWHILESTATEMENT(); 


                break;
            case 7 :
                // /Library/WebServer/Documents/calc/Formula.g:1:61: FORSTATEMENT
                this.mFORSTATEMENT(); 


                break;
            case 8 :
                // /Library/WebServer/Documents/calc/Formula.g:1:74: FROMSTATEMENT
                this.mFROMSTATEMENT(); 


                break;
            case 9 :
                // /Library/WebServer/Documents/calc/Formula.g:1:88: INSTATEMENT
                this.mINSTATEMENT(); 


                break;
            case 10 :
                // /Library/WebServer/Documents/calc/Formula.g:1:100: TOSTATEMENT
                this.mTOSTATEMENT(); 


                break;
            case 11 :
                // /Library/WebServer/Documents/calc/Formula.g:1:112: BYSTATEMENT
                this.mBYSTATEMENT(); 


                break;
            case 12 :
                // /Library/WebServer/Documents/calc/Formula.g:1:124: LOOPSTATEMENT
                this.mLOOPSTATEMENT(); 


                break;
            case 13 :
                // /Library/WebServer/Documents/calc/Formula.g:1:138: IFSTATEMENT
                this.mIFSTATEMENT(); 


                break;
            case 14 :
                // /Library/WebServer/Documents/calc/Formula.g:1:150: THENSTATEMENT
                this.mTHENSTATEMENT(); 


                break;
            case 15 :
                // /Library/WebServer/Documents/calc/Formula.g:1:164: ELSESTATEMENT
                this.mELSESTATEMENT(); 


                break;
            case 16 :
                // /Library/WebServer/Documents/calc/Formula.g:1:178: FUNCTIONSTATEMENT
                this.mFUNCTIONSTATEMENT(); 


                break;
            case 17 :
                // /Library/WebServer/Documents/calc/Formula.g:1:196: ENDBLOCK
                this.mENDBLOCK(); 


                break;
            case 18 :
                // /Library/WebServer/Documents/calc/Formula.g:1:205: RETURNSTATEMENT
                this.mRETURNSTATEMENT(); 


                break;
            case 19 :
                // /Library/WebServer/Documents/calc/Formula.g:1:221: NEWSTATEMENT
                this.mNEWSTATEMENT(); 


                break;
            case 20 :
                // /Library/WebServer/Documents/calc/Formula.g:1:234: TRYSTATEMENT
                this.mTRYSTATEMENT(); 


                break;
            case 21 :
                // /Library/WebServer/Documents/calc/Formula.g:1:247: CATCHSTATEMENT
                this.mCATCHSTATEMENT(); 


                break;
            case 22 :
                // /Library/WebServer/Documents/calc/Formula.g:1:262: THROWSTATEMENT
                this.mTHROWSTATEMENT(); 


                break;
            case 23 :
                // /Library/WebServer/Documents/calc/Formula.g:1:277: OR
                this.mOR(); 


                break;
            case 24 :
                // /Library/WebServer/Documents/calc/Formula.g:1:280: XOR
                this.mXOR(); 


                break;
            case 25 :
                // /Library/WebServer/Documents/calc/Formula.g:1:284: AND
                this.mAND(); 


                break;
            case 26 :
                // /Library/WebServer/Documents/calc/Formula.g:1:288: EQUALS
                this.mEQUALS(); 


                break;
            case 27 :
                // /Library/WebServer/Documents/calc/Formula.g:1:295: NOTEQUALS
                this.mNOTEQUALS(); 


                break;
            case 28 :
                // /Library/WebServer/Documents/calc/Formula.g:1:305: LT
                this.mLT(); 


                break;
            case 29 :
                // /Library/WebServer/Documents/calc/Formula.g:1:308: LTEQ
                this.mLTEQ(); 


                break;
            case 30 :
                // /Library/WebServer/Documents/calc/Formula.g:1:313: GT
                this.mGT(); 


                break;
            case 31 :
                // /Library/WebServer/Documents/calc/Formula.g:1:316: GTEQ
                this.mGTEQ(); 


                break;
            case 32 :
                // /Library/WebServer/Documents/calc/Formula.g:1:321: PLUS
                this.mPLUS(); 


                break;
            case 33 :
                // /Library/WebServer/Documents/calc/Formula.g:1:326: MINUS
                this.mMINUS(); 


                break;
            case 34 :
                // /Library/WebServer/Documents/calc/Formula.g:1:332: MULT
                this.mMULT(); 


                break;
            case 35 :
                // /Library/WebServer/Documents/calc/Formula.g:1:337: DIV
                this.mDIV(); 


                break;
            case 36 :
                // /Library/WebServer/Documents/calc/Formula.g:1:341: MOD
                this.mMOD(); 


                break;
            case 37 :
                // /Library/WebServer/Documents/calc/Formula.g:1:345: POW
                this.mPOW(); 


                break;
            case 38 :
                // /Library/WebServer/Documents/calc/Formula.g:1:349: NOT
                this.mNOT(); 


                break;
            case 39 :
                // /Library/WebServer/Documents/calc/Formula.g:1:353: LARR
                this.mLARR(); 


                break;
            case 40 :
                // /Library/WebServer/Documents/calc/Formula.g:1:358: RARR
                this.mRARR(); 


                break;
            case 41 :
                // /Library/WebServer/Documents/calc/Formula.g:1:363: LCURL
                this.mLCURL(); 


                break;
            case 42 :
                // /Library/WebServer/Documents/calc/Formula.g:1:369: RCURL
                this.mRCURL(); 


                break;
            case 43 :
                // /Library/WebServer/Documents/calc/Formula.g:1:375: INTEGER
                this.mINTEGER(); 


                break;
            case 44 :
                // /Library/WebServer/Documents/calc/Formula.g:1:383: FLOAT
                this.mFLOAT(); 


                break;
            case 45 :
                // /Library/WebServer/Documents/calc/Formula.g:1:389: TRUE
                this.mTRUE(); 


                break;
            case 46 :
                // /Library/WebServer/Documents/calc/Formula.g:1:394: FALSE
                this.mFALSE(); 


                break;
            case 47 :
                // /Library/WebServer/Documents/calc/Formula.g:1:400: PER
                this.mPER(); 


                break;
            case 48 :
                // /Library/WebServer/Documents/calc/Formula.g:1:404: SQUARED
                this.mSQUARED(); 


                break;
            case 49 :
                // /Library/WebServer/Documents/calc/Formula.g:1:412: CUBED
                this.mCUBED(); 


                break;
            case 50 :
                // /Library/WebServer/Documents/calc/Formula.g:1:418: IDENT
                this.mIDENT(); 


                break;
            case 51 :
                // /Library/WebServer/Documents/calc/Formula.g:1:424: PRIMITIVE
                this.mPRIMITIVE(); 


                break;
            case 52 :
                // /Library/WebServer/Documents/calc/Formula.g:1:434: LBRACKET
                this.mLBRACKET(); 


                break;
            case 53 :
                // /Library/WebServer/Documents/calc/Formula.g:1:443: RBRACKET
                this.mRBRACKET(); 


                break;
            case 54 :
                // /Library/WebServer/Documents/calc/Formula.g:1:452: COMMENT
                this.mCOMMENT(); 


                break;
            case 55 :
                // /Library/WebServer/Documents/calc/Formula.g:1:460: LINE_COMMENT
                this.mLINE_COMMENT(); 


                break;
            case 56 :
                // /Library/WebServer/Documents/calc/Formula.g:1:473: COLON
                this.mCOLON(); 


                break;
            case 57 :
                // /Library/WebServer/Documents/calc/Formula.g:1:479: WS
                this.mWS(); 


                break;
            case 58 :
                // /Library/WebServer/Documents/calc/Formula.g:1:482: COMMA
                this.mCOMMA(); 


                break;
            case 59 :
                // /Library/WebServer/Documents/calc/Formula.g:1:488: STRING
                this.mSTRING(); 


                break;

        }

    }

}, true); // important to pass true to overwrite default implementations

org.antlr.lang.augmentObject(FormulaLexer, {
    DFA30_eotS:
        "\u0003\uffff\u0001\u0031\u0001\u0032\u0001\uffff\u000a\u0026\u0001"+
    "\uffff\u0002\u0026\u0001\uffff\u0001\u0026\u0001\uffff\u0001\u004a\u0001"+
    "\u004c\u0003\uffff\u0001\u004e\u0001\uffff\u0001\u0026\u0005\uffff\u0001"+
    "\u0050\u0002\u0026\u0001\uffff\u0001\u0053\u000c\uffff\u0005\u0026\u0001"+
    "\u005a\u0001\u005b\u0001\u005c\u0002\u0026\u0001\u0061\u0008\u0026\u0001"+
    "\u0010\u0002\u0026\u0005\uffff\u0001\u0026\u0001\uffff\u0002\u0026\u0002"+
    "\uffff\u0001\u0026\u0001\u0070\u0003\u0026\u0003\uffff\u0002\u0026\u0001"+
    "\u0076\u0001\u0026\u0001\uffff\u0002\u0026\u0001\u007a\u0001\u0026\u0001"+
    "\u007c\u0001\u004a\u0002\u0026\u0001\u007f\u0001\u0013\u0001\u001c\u0001"+
    "\u0080\u0002\u0026\u0001\uffff\u0001\u0083\u0002\u0026\u0001\u0086\u0001"+
    "\u0026\u0001\uffff\u0001\u0088\u0001\u0089\u0001\u008a\u0001\uffff\u0001"+
    "\u0026\u0001\uffff\u0002\u0026\u0002\uffff\u0001\u0026\u0001\u008f\u0001"+
    "\uffff\u0001\u0026\u0001\u0091\u0001\uffff\u0001\u0092\u0003\uffff\u0001"+
    "\u0026\u0001\u0094\u0001\u0095\u0001\u0026\u0001\uffff\u0001\u0026\u0002"+
    "\uffff\u0001\u0098\u0002\uffff\u0002\u0026\u0001\uffff\u0001\u009b\u0001"+
    "\u009c\u0002\uffff",
    DFA30_eofS:
        "\u009d\uffff",
    DFA30_minS:
        "\u0001\u0009\u0002\uffff\u0001\u002d\u0001\u0030\u0001\uffff\u0001"+
    "\u0048\u0001\u0041\u0001\u0046\u0001\u0048\u0001\u0059\u0001\u004f\u0001"+
    "\u004c\u0002\u0045\u0001\u0041\u0001\uffff\u0001\u0052\u0001\u004f\u0001"+
    "\uffff\u0001\u004e\u0001\uffff\u0002\u003d\u0003\uffff\u0001\u002a\u0001"+
    "\uffff\u0001\u004f\u0005\uffff\u0001\u002e\u0001\u0045\u0001\u0051\u0001"+
    "\uffff\u0001\u0000\u000c\uffff\u0001\u0049\u0001\u0052\u0001\u004f\u0001"+
    "\u004e\u0001\u004c\u0003\u0030\u0001\u0045\u0001\u0055\u0001\u0030\u0001"+
    "\u004f\u0001\u0053\u0001\u0044\u0001\u0054\u0001\u0057\u0002\u0054\u0001"+
    "\u0042\u0001\u0030\u0001\u0052\u0001\u0044\u0005\uffff\u0001\u0044\u0001"+
    "\uffff\u0001\u0052\u0001\u0055\u0002\uffff\u0001\u004c\u0001\u0030\u0001"+
    "\u004d\u0001\u0043\u0001\u0053\u0003\uffff\u0001\u004e\u0001\u004f\u0001"+
    "\u0030\u0001\u0045\u0001\uffff\u0001\u0050\u0001\u0045\u0001\u0030\u0001"+
    "\u0055\u0002\u0030\u0001\u0043\u0001\u0045\u0004\u0030\u0001\u0041\u0001"+
    "\u0045\u0001\uffff\u0001\u0030\u0001\u0054\u0001\u0045\u0001\u0030\u0001"+
    "\u0057\u0001\uffff\u0003\u0030\u0001\uffff\u0001\u0052\u0001\uffff\u0001"+
    "\u0048\u0001\u0044\u0002\uffff\u0001\u0052\u0001\u0030\u0001\uffff\u0001"+
    "\u0049\u0001\u0030\u0001\uffff\u0001\u0030\u0003\uffff\u0001\u004e\u0002"+
    "\u0030\u0001\u0045\u0001\uffff\u0001\u004f\u0002\uffff\u0001\u0030\u0002"+
    "\uffff\u0001\u0044\u0001\u004e\u0001\uffff\u0002\u0030\u0002\uffff",
    DFA30_maxS:
        "\u0001\u00bb\u0002\uffff\u0001\u003e\u0001\u0039\u0001\uffff\u0001"+
    "\u0068\u0001\u0075\u0001\u006e\u0001\u0072\u0001\u0079\u0001\u006f\u0001"+
    "\u006e\u0001\u0065\u0001\u006f\u0001\u0075\u0001\uffff\u0001\u0072\u0001"+
    "\u006f\u0001\uffff\u0001\u006e\u0001\uffff\u0001\u003d\u0001\u003e\u0003"+
    "\uffff\u0001\u002f\u0001\uffff\u0001\u006f\u0005\uffff\u0001\u0039\u0001"+
    "\u0065\u0001\u0071\u0001\uffff\u0001\uffff\u000c\uffff\u0001\u0069\u0001"+
    "\u0072\u0001\u006f\u0001\u006e\u0001\u006c\u0003\u007a\u0001\u0072\u0001"+
    "\u0079\u0001\u007a\u0001\u006f\u0001\u0073\u0001\u0064\u0001\u0074\u0001"+
    "\u0077\u0002\u0074\u0001\u0062\u0001\u007a\u0001\u0072\u0001\u0064\u0005"+
    "\uffff\u0001\u0064\u0001\uffff\u0001\u0072\u0001\u0075\u0002\uffff\u0001"+
    "\u006c\u0001\u007a\u0001\u006d\u0001\u0063\u0001\u0073\u0003\uffff\u0001"+
    "\u006e\u0001\u006f\u0001\u007a\u0001\u0065\u0001\uffff\u0001\u0070\u0001"+
    "\u0065\u0001\u007a\u0001\u0075\u0002\u007a\u0001\u0063\u0001\u0065\u0004"+
    "\u007a\u0001\u0061\u0001\u0065\u0001\uffff\u0001\u007a\u0001\u0074\u0001"+
    "\u0065\u0001\u007a\u0001\u0077\u0001\uffff\u0003\u007a\u0001\uffff\u0001"+
    "\u0072\u0001\uffff\u0001\u0068\u0001\u0064\u0002\uffff\u0001\u0072\u0001"+
    "\u007a\u0001\uffff\u0001\u0069\u0001\u007a\u0001\uffff\u0001\u007a\u0003"+
    "\uffff\u0001\u006e\u0002\u007a\u0001\u0065\u0001\uffff\u0001\u006f\u0002"+
    "\uffff\u0001\u007a\u0002\uffff\u0001\u0064\u0001\u006e\u0001\uffff\u0002"+
    "\u007a\u0002\uffff",
    DFA30_acceptS:
        "\u0001\uffff\u0001\u0001\u0001\u0002\u0002\uffff\u0001\u0005\u000a"+
    "\uffff\u0001\u0017\u0002\uffff\u0001\u0019\u0001\uffff\u0001\u001a\u0002"+
    "\uffff\u0001\u0020\u0001\u0021\u0001\u0022\u0001\uffff\u0001\u0024\u0001"+
    "\uffff\u0001\u0025\u0001\u0027\u0001\u0028\u0001\u0029\u0001\u002a\u0003"+
    "\uffff\u0001\u0032\u0001\uffff\u0001\u0035\u0001\u0037\u0001\u0038\u0001"+
    "\u0039\u0001\u003a\u0001\u003b\u0001\u0003\u0001\u001b\u0001\u001d\u0001"+
    "\u001c\u0001\u0004\u0001\u002c\u0016\uffff\u0001\u0026\u0001\u001f\u0001"+
    "\u001e\u0001\u0036\u0001\u0023\u0001\uffff\u0001\u002b\u0002\uffff\u0001"+
    "\u0034\u0001\u0033\u0005\uffff\u0001\u0009\u0001\u000d\u0001\u000a\u0004"+
    "\uffff\u0001\u000b\u000e\uffff\u0001\u0007\u0005\uffff\u0001\u0014\u0003"+
    "\uffff\u0001\u0011\u0001\uffff\u0001\u0013\u0002\uffff\u0001\u0018\u0001"+
    "\u002f\u0002\uffff\u0001\u0008\u0002\uffff\u0001\u000e\u0001\uffff\u0001"+
    "\u002d\u0001\u000c\u0001\u000f\u0004\uffff\u0001\u0006\u0001\uffff\u0001"+
    "\u002e\u0001\u0016\u0001\uffff\u0001\u0015\u0001\u0031\u0002\uffff\u0001"+
    "\u0012\u0002\uffff\u0001\u0030\u0001\u0010",
    DFA30_specialS:
        "\u0027\uffff\u0001\u0000\u0075\uffff}>",
    DFA30_transitionS: [
            "\u0001\u002b\u0001\u0005\u0001\uffff\u0001\u002b\u0001\u0005"+
            "\u0012\uffff\u0001\u002b\u0001\u0016\u0001\u002d\u0001\u0029"+
            "\u0001\uffff\u0001\u001c\u0001\u0013\u0001\u002d\u0001\u0001"+
            "\u0001\u0002\u0001\u001a\u0001\u0018\u0001\u002c\u0001\u0019"+
            "\u0001\u0004\u0001\u001b\u000a\u0023\u0001\u002a\u0001\uffff"+
            "\u0001\u0003\u0001\u0015\u0001\u0017\u0002\uffff\u0001\u0014"+
            "\u0001\u000a\u0001\u000f\u0001\u0026\u0001\u000c\u0001\u0007"+
            "\u0002\u0026\u0001\u0008\u0002\u0026\u0001\u000b\u0001\u001d"+
            "\u0001\u000e\u0001\u0011\u0001\u0024\u0001\u0026\u0001\u000d"+
            "\u0001\u0025\u0001\u0009\u0002\u0026\u0001\u0006\u0001\u0012"+
            "\u0002\u0026\u0001\u0027\u0001\uffff\u0001\u0028\u0001\u001e"+
            "\u0002\uffff\u0001\u0014\u0001\u000a\u0001\u000f\u0001\u0026"+
            "\u0001\u000c\u0001\u0007\u0002\u0026\u0001\u0008\u0002\u0026"+
            "\u0001\u000b\u0001\u001d\u0001\u000e\u0001\u0011\u0001\u0024"+
            "\u0001\u0026\u0001\u000d\u0001\u0025\u0001\u0009\u0002\u0026"+
            "\u0001\u0006\u0001\u0012\u0002\u0026\u0001\u0021\u0001\u0010"+
            "\u0001\u0022\u002d\uffff\u0001\u001f\u000f\uffff\u0001\u0020",
            "",
            "",
            "\u0001\u002e\u000e\uffff\u0001\u001f\u0001\u0030\u0001\u002f",
            "\u000a\u0033",
            "",
            "\u0001\u0034\u001f\uffff\u0001\u0034",
            "\u0001\u0038\u000d\uffff\u0001\u0035\u0002\uffff\u0001\u0036"+
            "\u0002\uffff\u0001\u0037\u000b\uffff\u0001\u0038\u000d\uffff"+
            "\u0001\u0035\u0002\uffff\u0001\u0036\u0002\uffff\u0001\u0037",
            "\u0001\u003a\u0007\uffff\u0001\u0039\u0017\uffff\u0001\u003a"+
            "\u0007\uffff\u0001\u0039",
            "\u0001\u003c\u0006\uffff\u0001\u003b\u0002\uffff\u0001\u003d"+
            "\u0015\uffff\u0001\u003c\u0006\uffff\u0001\u003b\u0002\uffff"+
            "\u0001\u003d",
            "\u0001\u003e\u001f\uffff\u0001\u003e",
            "\u0001\u003f\u001f\uffff\u0001\u003f",
            "\u0001\u0040\u0001\uffff\u0001\u0041\u001d\uffff\u0001\u0040"+
            "\u0001\uffff\u0001\u0041",
            "\u0001\u0042\u001f\uffff\u0001\u0042",
            "\u0001\u0043\u0009\uffff\u0001\u0044\u0015\uffff\u0001\u0043"+
            "\u0009\uffff\u0001\u0044",
            "\u0001\u0045\u0013\uffff\u0001\u0046\u000b\uffff\u0001\u0045"+
            "\u0013\uffff\u0001\u0046",
            "",
            "\u0001\u0047\u001f\uffff\u0001\u0047",
            "\u0001\u0048\u001f\uffff\u0001\u0048",
            "",
            "\u0001\u0049\u001f\uffff\u0001\u0049",
            "",
            "\u0001\u002f",
            "\u0001\u004b\u0001\u0020",
            "",
            "",
            "",
            "\u0001\u004d\u0004\uffff\u0001\u0029",
            "",
            "\u0001\u004f\u001f\uffff\u0001\u004f",
            "",
            "",
            "",
            "",
            "",
            "\u0001\u0033\u0001\uffff\u000a\u0023",
            "\u0001\u0051\u001f\uffff\u0001\u0051",
            "\u0001\u0052\u001f\uffff\u0001\u0052",
            "",
            "\u0000\u0054",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "\u0001\u0055\u001f\uffff\u0001\u0055",
            "\u0001\u0056\u001f\uffff\u0001\u0056",
            "\u0001\u0057\u001f\uffff\u0001\u0057",
            "\u0001\u0058\u001f\uffff\u0001\u0058",
            "\u0001\u0059\u001f\uffff\u0001\u0059",
            "\u000a\u0026\u0007\uffff\u001a\u0026\u0004\uffff\u0001\u0026"+
            "\u0001\uffff\u001a\u0026",
            "\u000a\u0026\u0007\uffff\u001a\u0026\u0004\uffff\u0001\u0026"+
            "\u0001\uffff\u001a\u0026",
            "\u000a\u0026\u0007\uffff\u001a\u0026\u0004\uffff\u0001\u0026"+
            "\u0001\uffff\u001a\u0026",
            "\u0001\u005d\u000c\uffff\u0001\u005e\u0012\uffff\u0001\u005d"+
            "\u000c\uffff\u0001\u005e",
            "\u0001\u0060\u0003\uffff\u0001\u005f\u001b\uffff\u0001\u0060"+
            "\u0003\uffff\u0001\u005f",
            "\u000a\u0026\u0007\uffff\u001a\u0026\u0004\uffff\u0001\u0026"+
            "\u0001\uffff\u001a\u0026",
            "\u0001\u0062\u001f\uffff\u0001\u0062",
            "\u0001\u0063\u001f\uffff\u0001\u0063",
            "\u0001\u0064\u001f\uffff\u0001\u0064",
            "\u0001\u0065\u001f\uffff\u0001\u0065",
            "\u0001\u0066\u001f\uffff\u0001\u0066",
            "\u0001\u0067\u001f\uffff\u0001\u0067",
            "\u0001\u0068\u001f\uffff\u0001\u0068",
            "\u0001\u0069\u001f\uffff\u0001\u0069",
            "\u000a\u0026\u0007\uffff\u001a\u0026\u0004\uffff\u0001\u0026"+
            "\u0001\uffff\u001a\u0026",
            "\u0001\u006a\u001f\uffff\u0001\u006a",
            "\u0001\u006b\u001f\uffff\u0001\u006b",
            "",
            "",
            "",
            "",
            "",
            "\u0001\u006c\u001f\uffff\u0001\u006c",
            "",
            "\u0001\u006d\u001f\uffff\u0001\u006d",
            "\u0001\u006e\u001f\uffff\u0001\u006e",
            "",
            "",
            "\u0001\u006f\u001f\uffff\u0001\u006f",
            "\u000a\u0026\u0007\uffff\u001a\u0026\u0004\uffff\u0001\u0026"+
            "\u0001\uffff\u001a\u0026",
            "\u0001\u0071\u001f\uffff\u0001\u0071",
            "\u0001\u0072\u001f\uffff\u0001\u0072",
            "\u0001\u0073\u001f\uffff\u0001\u0073",
            "",
            "",
            "",
            "\u0001\u0074\u001f\uffff\u0001\u0074",
            "\u0001\u0075\u001f\uffff\u0001\u0075",
            "\u000a\u0026\u0007\uffff\u001a\u0026\u0004\uffff\u0001\u0026"+
            "\u0001\uffff\u001a\u0026",
            "\u0001\u0077\u001f\uffff\u0001\u0077",
            "",
            "\u0001\u0078\u001f\uffff\u0001\u0078",
            "\u0001\u0079\u001f\uffff\u0001\u0079",
            "\u000a\u0026\u0007\uffff\u001a\u0026\u0004\uffff\u0001\u0026"+
            "\u0001\uffff\u001a\u0026",
            "\u0001\u007b\u001f\uffff\u0001\u007b",
            "\u000a\u0026\u0007\uffff\u001a\u0026\u0004\uffff\u0001\u0026"+
            "\u0001\uffff\u001a\u0026",
            "\u000a\u0026\u0007\uffff\u001a\u0026\u0004\uffff\u0001\u0026"+
            "\u0001\uffff\u001a\u0026",
            "\u0001\u007d\u001f\uffff\u0001\u007d",
            "\u0001\u007e\u001f\uffff\u0001\u007e",
            "\u000a\u0026\u0007\uffff\u001a\u0026\u0004\uffff\u0001\u0026"+
            "\u0001\uffff\u001a\u0026",
            "\u000a\u0026\u0007\uffff\u001a\u0026\u0004\uffff\u0001\u0026"+
            "\u0001\uffff\u001a\u0026",
            "\u000a\u0026\u0007\uffff\u001a\u0026\u0004\uffff\u0001\u0026"+
            "\u0001\uffff\u001a\u0026",
            "\u000a\u0026\u0007\uffff\u001a\u0026\u0004\uffff\u0001\u0026"+
            "\u0001\uffff\u001a\u0026",
            "\u0001\u0081\u001f\uffff\u0001\u0081",
            "\u0001\u0082\u001f\uffff\u0001\u0082",
            "",
            "\u000a\u0026\u0007\uffff\u001a\u0026\u0004\uffff\u0001\u0026"+
            "\u0001\uffff\u001a\u0026",
            "\u0001\u0084\u001f\uffff\u0001\u0084",
            "\u0001\u0085\u001f\uffff\u0001\u0085",
            "\u000a\u0026\u0007\uffff\u001a\u0026\u0004\uffff\u0001\u0026"+
            "\u0001\uffff\u001a\u0026",
            "\u0001\u0087\u001f\uffff\u0001\u0087",
            "",
            "\u000a\u0026\u0007\uffff\u001a\u0026\u0004\uffff\u0001\u0026"+
            "\u0001\uffff\u001a\u0026",
            "\u000a\u0026\u0007\uffff\u001a\u0026\u0004\uffff\u0001\u0026"+
            "\u0001\uffff\u001a\u0026",
            "\u000a\u0026\u0007\uffff\u001a\u0026\u0004\uffff\u0001\u0026"+
            "\u0001\uffff\u001a\u0026",
            "",
            "\u0001\u008b\u001f\uffff\u0001\u008b",
            "",
            "\u0001\u008c\u001f\uffff\u0001\u008c",
            "\u0001\u008d\u001f\uffff\u0001\u008d",
            "",
            "",
            "\u0001\u008e\u001f\uffff\u0001\u008e",
            "\u000a\u0026\u0007\uffff\u001a\u0026\u0004\uffff\u0001\u0026"+
            "\u0001\uffff\u001a\u0026",
            "",
            "\u0001\u0090\u001f\uffff\u0001\u0090",
            "\u000a\u0026\u0007\uffff\u001a\u0026\u0004\uffff\u0001\u0026"+
            "\u0001\uffff\u001a\u0026",
            "",
            "\u000a\u0026\u0007\uffff\u001a\u0026\u0004\uffff\u0001\u0026"+
            "\u0001\uffff\u001a\u0026",
            "",
            "",
            "",
            "\u0001\u0093\u001f\uffff\u0001\u0093",
            "\u000a\u0026\u0007\uffff\u001a\u0026\u0004\uffff\u0001\u0026"+
            "\u0001\uffff\u001a\u0026",
            "\u000a\u0026\u0007\uffff\u001a\u0026\u0004\uffff\u0001\u0026"+
            "\u0001\uffff\u001a\u0026",
            "\u0001\u0096\u001f\uffff\u0001\u0096",
            "",
            "\u0001\u0097\u001f\uffff\u0001\u0097",
            "",
            "",
            "\u000a\u0026\u0007\uffff\u001a\u0026\u0004\uffff\u0001\u0026"+
            "\u0001\uffff\u001a\u0026",
            "",
            "",
            "\u0001\u0099\u001f\uffff\u0001\u0099",
            "\u0001\u009a\u001f\uffff\u0001\u009a",
            "",
            "\u000a\u0026\u0007\uffff\u001a\u0026\u0004\uffff\u0001\u0026"+
            "\u0001\uffff\u001a\u0026",
            "\u000a\u0026\u0007\uffff\u001a\u0026\u0004\uffff\u0001\u0026"+
            "\u0001\uffff\u001a\u0026",
            "",
            ""
    ]
});

org.antlr.lang.augmentObject(FormulaLexer, {
    DFA30_eot:
        org.antlr.runtime.DFA.unpackEncodedString(FormulaLexer.DFA30_eotS),
    DFA30_eof:
        org.antlr.runtime.DFA.unpackEncodedString(FormulaLexer.DFA30_eofS),
    DFA30_min:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(FormulaLexer.DFA30_minS),
    DFA30_max:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(FormulaLexer.DFA30_maxS),
    DFA30_accept:
        org.antlr.runtime.DFA.unpackEncodedString(FormulaLexer.DFA30_acceptS),
    DFA30_special:
        org.antlr.runtime.DFA.unpackEncodedString(FormulaLexer.DFA30_specialS),
    DFA30_transition: (function() {
        var a = [],
            i,
            numStates = FormulaLexer.DFA30_transitionS.length;
        for (i=0; i<numStates; i++) {
            a.push(org.antlr.runtime.DFA.unpackEncodedString(FormulaLexer.DFA30_transitionS[i]));
        }
        return a;
    })()
});

FormulaLexer.DFA30 = function(recognizer) {
    this.recognizer = recognizer;
    this.decisionNumber = 30;
    this.eot = FormulaLexer.DFA30_eot;
    this.eof = FormulaLexer.DFA30_eof;
    this.min = FormulaLexer.DFA30_min;
    this.max = FormulaLexer.DFA30_max;
    this.accept = FormulaLexer.DFA30_accept;
    this.special = FormulaLexer.DFA30_special;
    this.transition = FormulaLexer.DFA30_transition;
};

org.antlr.lang.extend(FormulaLexer.DFA30, org.antlr.runtime.DFA, {
    getDescription: function() {
        return "1:1: Tokens : ( T__113 | T__114 | T__115 | T__116 | NEWLINE | WHILESTATEMENT | FORSTATEMENT | FROMSTATEMENT | INSTATEMENT | TOSTATEMENT | BYSTATEMENT | LOOPSTATEMENT | IFSTATEMENT | THENSTATEMENT | ELSESTATEMENT | FUNCTIONSTATEMENT | ENDBLOCK | RETURNSTATEMENT | NEWSTATEMENT | TRYSTATEMENT | CATCHSTATEMENT | THROWSTATEMENT | OR | XOR | AND | EQUALS | NOTEQUALS | LT | LTEQ | GT | GTEQ | PLUS | MINUS | MULT | DIV | MOD | POW | NOT | LARR | RARR | LCURL | RCURL | INTEGER | FLOAT | TRUE | FALSE | PER | SQUARED | CUBED | IDENT | PRIMITIVE | LBRACKET | RBRACKET | COMMENT | LINE_COMMENT | COLON | WS | COMMA | STRING );";
    },
    specialStateTransition: function(s, input) {
        var _s = s;
        /* bind to recognizer so semantic predicates can be evaluated */
        var retval = (function(s, input) {
            switch ( s ) {
                        case 0 : 
                            var LA30_39 = input.LA(1);

                            s = -1;
                            if ( ((LA30_39>='\u0000' && LA30_39<='\uFFFF')) ) {s = 84;}

                            else s = 83;

                            if ( s>=0 ) return s;
                            break;
            }
        }).call(this.recognizer, s, input);
        if (!org.antlr.lang.isUndefined(retval)) {
            return retval;
        }
        var nvae =
            new org.antlr.runtime.NoViableAltException(this.getDescription(), 30, _s, input);
        this.error(nvae);
        throw nvae;
    },
    dummy: null
});
 
})();

// $ANTLR 3.3 Nov 30, 2010 12:45:30 /Library/WebServer/Documents/calc/Formula.g 2013-09-12 12:24:51

var FormulaParser = function(input, state) {
    if (!state) {
        state = new org.antlr.runtime.RecognizerSharedState();
    }

    (function(){
    }).call(this);

    FormulaParser.superclass.constructor.call(this, input, state);

    this.dfa5 = new FormulaParser.DFA5(this);
    this.dfa57 = new FormulaParser.DFA57(this);
    this.dfa58 = new FormulaParser.DFA58(this);
    this.dfa65 = new FormulaParser.DFA65(this);
    this.dfa72 = new FormulaParser.DFA72(this);
    this.dfa85 = new FormulaParser.DFA85(this);

         

    /* @todo only create adaptor if output=AST */
    this.adaptor = new org.antlr.runtime.tree.CommonTreeAdaptor();

};

org.antlr.lang.augmentObject(FormulaParser, {
    EOF: -1,
    T__113: 113,
    T__114: 114,
    T__115: 115,
    T__116: 116,
    NEGATE: 4,
    ASSIGN: 5,
    FUNCALL: 6,
    MATERIAL: 7,
    UNIT: 8,
    POWER: 9,
    DEFAULTS: 10,
    PARAMS: 11,
    UNITCLUMP: 12,
    ARRAY: 13,
    LINES: 14,
    WHILE: 15,
    IFTHENELSE: 16,
    ELSE: 17,
    FOR: 18,
    FORIN: 19,
    FUNCTION: 20,
    ANONFUNCTION: 21,
    NUMBER: 22,
    LABEL: 23,
    RANGE: 24,
    INNER: 25,
    ASSIGNED: 26,
    SELECTOR: 27,
    DOTSELECTOR: 28,
    NEW: 29,
    TRYCATCH: 30,
    THROW: 31,
    NEWLINE: 32,
    W: 33,
    H: 34,
    I: 35,
    L: 36,
    E: 37,
    WHILESTATEMENT: 38,
    F: 39,
    O: 40,
    R: 41,
    FORSTATEMENT: 42,
    M: 43,
    FROMSTATEMENT: 44,
    N: 45,
    INSTATEMENT: 46,
    T: 47,
    TOSTATEMENT: 48,
    B: 49,
    Y: 50,
    BYSTATEMENT: 51,
    P: 52,
    LOOPSTATEMENT: 53,
    IFSTATEMENT: 54,
    THENSTATEMENT: 55,
    S: 56,
    ELSESTATEMENT: 57,
    U: 58,
    C: 59,
    FUNCTIONSTATEMENT: 60,
    D: 61,
    ENDBLOCK: 62,
    RETURNSTATEMENT: 63,
    NEWSTATEMENT: 64,
    TRYSTATEMENT: 65,
    A: 66,
    CATCHSTATEMENT: 67,
    THROWSTATEMENT: 68,
    IDENT: 69,
    EQUALS: 70,
    PRIMITIVE: 71,
    OR: 72,
    XOR: 73,
    X: 74,
    AND: 75,
    NOTEQUALS: 76,
    LT: 77,
    LTEQ: 78,
    GT: 79,
    GTEQ: 80,
    PLUS: 81,
    MINUS: 82,
    MULT: 83,
    DIV: 84,
    MOD: 85,
    COLON: 86,
    POW: 87,
    NOT: 88,
    LARR: 89,
    RARR: 90,
    LCURL: 91,
    RCURL: 92,
    COMMA: 93,
    STRING: 94,
    INTEGER: 95,
    FLOAT: 96,
    TRUE: 97,
    FALSE: 98,
    PER: 99,
    CUBED: 100,
    SQUARED: 101,
    Q: 102,
    LBRACKET: 103,
    RBRACKET: 104,
    COMMENT: 105,
    LINE_COMMENT: 106,
    WS: 107,
    G: 108,
    J: 109,
    K: 110,
    V: 111,
    Z: 112
});

(function(){
// public class variables
var EOF= -1,
    T__113= 113,
    T__114= 114,
    T__115= 115,
    T__116= 116,
    NEGATE= 4,
    ASSIGN= 5,
    FUNCALL= 6,
    MATERIAL= 7,
    UNIT= 8,
    POWER= 9,
    DEFAULTS= 10,
    PARAMS= 11,
    UNITCLUMP= 12,
    ARRAY= 13,
    LINES= 14,
    WHILE= 15,
    IFTHENELSE= 16,
    ELSE= 17,
    FOR= 18,
    FORIN= 19,
    FUNCTION= 20,
    ANONFUNCTION= 21,
    NUMBER= 22,
    LABEL= 23,
    RANGE= 24,
    INNER= 25,
    ASSIGNED= 26,
    SELECTOR= 27,
    DOTSELECTOR= 28,
    NEW= 29,
    TRYCATCH= 30,
    THROW= 31,
    NEWLINE= 32,
    W= 33,
    H= 34,
    I= 35,
    L= 36,
    E= 37,
    WHILESTATEMENT= 38,
    F= 39,
    O= 40,
    R= 41,
    FORSTATEMENT= 42,
    M= 43,
    FROMSTATEMENT= 44,
    N= 45,
    INSTATEMENT= 46,
    T= 47,
    TOSTATEMENT= 48,
    B= 49,
    Y= 50,
    BYSTATEMENT= 51,
    P= 52,
    LOOPSTATEMENT= 53,
    IFSTATEMENT= 54,
    THENSTATEMENT= 55,
    S= 56,
    ELSESTATEMENT= 57,
    U= 58,
    C= 59,
    FUNCTIONSTATEMENT= 60,
    D= 61,
    ENDBLOCK= 62,
    RETURNSTATEMENT= 63,
    NEWSTATEMENT= 64,
    TRYSTATEMENT= 65,
    A= 66,
    CATCHSTATEMENT= 67,
    THROWSTATEMENT= 68,
    IDENT= 69,
    EQUALS= 70,
    PRIMITIVE= 71,
    OR= 72,
    XOR= 73,
    X= 74,
    AND= 75,
    NOTEQUALS= 76,
    LT= 77,
    LTEQ= 78,
    GT= 79,
    GTEQ= 80,
    PLUS= 81,
    MINUS= 82,
    MULT= 83,
    DIV= 84,
    MOD= 85,
    COLON= 86,
    POW= 87,
    NOT= 88,
    LARR= 89,
    RARR= 90,
    LCURL= 91,
    RCURL= 92,
    COMMA= 93,
    STRING= 94,
    INTEGER= 95,
    FLOAT= 96,
    TRUE= 97,
    FALSE= 98,
    PER= 99,
    CUBED= 100,
    SQUARED= 101,
    Q= 102,
    LBRACKET= 103,
    RBRACKET= 104,
    COMMENT= 105,
    LINE_COMMENT= 106,
    WS= 107,
    G= 108,
    J= 109,
    K= 110,
    V= 111,
    Z= 112;

// public instance methods/vars
org.antlr.lang.extend(FormulaParser, org.antlr.runtime.Parser, {
        
    setTreeAdaptor: function(adaptor) {
        this.adaptor = adaptor;
    },
    getTreeAdaptor: function() {
        return this.adaptor;
    },

    getTokenNames: function() { return FormulaParser.tokenNames; },
    getGrammarFileName: function() { return "/Library/WebServer/Documents/calc/Formula.g"; }
});
org.antlr.lang.augmentObject(FormulaParser.prototype, {

    // inline static return class
    lines_return: (function() {
        FormulaParser.lines_return = function(){};
        org.antlr.lang.extend(FormulaParser.lines_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // /Library/WebServer/Documents/calc/Formula.g:43:1: lines : ( NEWLINE )* ( expression ( ( NEWLINE )+ | EOF ) )* EOF -> ^( LINES ( expression )* ) ;
    // $ANTLR start "lines"
    lines: function() {
        var retval = new FormulaParser.lines_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var NEWLINE1 = null;
        var NEWLINE3 = null;
        var EOF4 = null;
        var EOF5 = null;
         var expression2 = null;

        var NEWLINE1_tree=null;
        var NEWLINE3_tree=null;
        var EOF4_tree=null;
        var EOF5_tree=null;
        var stream_NEWLINE=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token NEWLINE");
        var stream_EOF=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token EOF");
        var stream_expression=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule expression");
        try {
            // /Library/WebServer/Documents/calc/Formula.g:44:2: ( ( NEWLINE )* ( expression ( ( NEWLINE )+ | EOF ) )* EOF -> ^( LINES ( expression )* ) )
            // /Library/WebServer/Documents/calc/Formula.g:44:4: ( NEWLINE )* ( expression ( ( NEWLINE )+ | EOF ) )* EOF
            // /Library/WebServer/Documents/calc/Formula.g:44:4: ( NEWLINE )*
            loop1:
            do {
                var alt1=2;
                var LA1_0 = this.input.LA(1);

                if ( (LA1_0==NEWLINE) ) {
                    alt1=1;
                }


                switch (alt1) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:0:0: NEWLINE
                    NEWLINE1=this.match(this.input,NEWLINE,FormulaParser.FOLLOW_NEWLINE_in_lines160); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_NEWLINE.add(NEWLINE1);



                    break;

                default :
                    break loop1;
                }
            } while (true);

            // /Library/WebServer/Documents/calc/Formula.g:44:13: ( expression ( ( NEWLINE )+ | EOF ) )*
            loop4:
            do {
                var alt4=2;
                var LA4_0 = this.input.LA(1);

                if ( (LA4_0==WHILESTATEMENT||LA4_0==FORSTATEMENT||LA4_0==IFSTATEMENT||LA4_0==FUNCTIONSTATEMENT||(LA4_0>=RETURNSTATEMENT && LA4_0<=TRYSTATEMENT)||(LA4_0>=THROWSTATEMENT && LA4_0<=IDENT)||LA4_0==PRIMITIVE||LA4_0==MINUS||(LA4_0>=NOT && LA4_0<=LARR)||LA4_0==LCURL||(LA4_0>=STRING && LA4_0<=FALSE)||LA4_0==113) ) {
                    alt4=1;
                }


                switch (alt4) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:44:14: expression ( ( NEWLINE )+ | EOF )
                    this.pushFollow(FormulaParser.FOLLOW_expression_in_lines164);
                    expression2=this.expression();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) stream_expression.add(expression2.getTree());
                    // /Library/WebServer/Documents/calc/Formula.g:44:26: ( ( NEWLINE )+ | EOF )
                    var alt3=2;
                    var LA3_0 = this.input.LA(1);

                    if ( (LA3_0==NEWLINE) ) {
                        alt3=1;
                    }
                    else if ( (LA3_0==EOF) ) {
                        alt3=2;
                    }
                    else {
                        if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        var nvae =
                            new org.antlr.runtime.NoViableAltException("", 3, 0, this.input);

                        throw nvae;
                    }
                    switch (alt3) {
                        case 1 :
                            // /Library/WebServer/Documents/calc/Formula.g:44:27: ( NEWLINE )+
                            // /Library/WebServer/Documents/calc/Formula.g:44:27: ( NEWLINE )+
                            var cnt2=0;
                            loop2:
                            do {
                                var alt2=2;
                                var LA2_0 = this.input.LA(1);

                                if ( (LA2_0==NEWLINE) ) {
                                    alt2=1;
                                }


                                switch (alt2) {
                                case 1 :
                                    // /Library/WebServer/Documents/calc/Formula.g:0:0: NEWLINE
                                    NEWLINE3=this.match(this.input,NEWLINE,FormulaParser.FOLLOW_NEWLINE_in_lines168); if (this.state.failed) return retval; 
                                    if ( this.state.backtracking===0 ) stream_NEWLINE.add(NEWLINE3);



                                    break;

                                default :
                                    if ( cnt2 >= 1 ) {
                                        break loop2;
                                    }
                                    if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                                        var eee = new org.antlr.runtime.EarlyExitException(2, this.input);
                                        throw eee;
                                }
                                cnt2++;
                            } while (true);



                            break;
                        case 2 :
                            // /Library/WebServer/Documents/calc/Formula.g:44:36: EOF
                            EOF4=this.match(this.input,EOF,FormulaParser.FOLLOW_EOF_in_lines171); if (this.state.failed) return retval; 
                            if ( this.state.backtracking===0 ) stream_EOF.add(EOF4);



                            break;

                    }



                    break;

                default :
                    break loop4;
                }
            } while (true);

            EOF5=this.match(this.input,EOF,FormulaParser.FOLLOW_EOF_in_lines176); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_EOF.add(EOF5);



            // AST REWRITE
            // elements: expression
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            if ( this.state.backtracking===0 ) {
            retval.tree = root_0;
            var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

            root_0 = this.adaptor.nil();
            // 44:47: -> ^( LINES ( expression )* )
            {
                // /Library/WebServer/Documents/calc/Formula.g:44:50: ^( LINES ( expression )* )
                {
                var root_1 = this.adaptor.nil();
                root_1 = this.adaptor.becomeRoot(this.adaptor.create(LINES, "LINES"), root_1);

                // /Library/WebServer/Documents/calc/Formula.g:44:58: ( expression )*
                while ( stream_expression.hasNext() ) {
                    this.adaptor.addChild(root_1, stream_expression.nextTree());

                }
                stream_expression.reset();

                this.adaptor.addChild(root_0, root_1);
                }

            }

            retval.tree = root_0;}


            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    expression_return: (function() {
        FormulaParser.expression_return = function(){};
        org.antlr.lang.extend(FormulaParser.expression_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // /Library/WebServer/Documents/calc/Formula.g:120:1: expression : ( assignment | logicalExpression | whileLoop | forLoop | forInLoop | ifThenElse | functionDef | returnExp | tryCatch | throwExp );
    // $ANTLR start "expression"
    expression: function() {
        var retval = new FormulaParser.expression_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var assignment6 = null;
         var logicalExpression7 = null;
         var whileLoop8 = null;
         var forLoop9 = null;
         var forInLoop10 = null;
         var ifThenElse11 = null;
         var functionDef12 = null;
         var returnExp13 = null;
         var tryCatch14 = null;
         var throwExp15 = null;


        try {
            // /Library/WebServer/Documents/calc/Formula.g:121:2: ( assignment | logicalExpression | whileLoop | forLoop | forInLoop | ifThenElse | functionDef | returnExp | tryCatch | throwExp )
            var alt5=10;
            alt5 = this.dfa5.predict(this.input);
            switch (alt5) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:121:5: assignment
                    root_0 = this.adaptor.nil();

                    this.pushFollow(FormulaParser.FOLLOW_assignment_in_expression508);
                    assignment6=this.assignment();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, assignment6.getTree());


                    break;
                case 2 :
                    // /Library/WebServer/Documents/calc/Formula.g:122:5: logicalExpression
                    root_0 = this.adaptor.nil();

                    this.pushFollow(FormulaParser.FOLLOW_logicalExpression_in_expression514);
                    logicalExpression7=this.logicalExpression();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, logicalExpression7.getTree());


                    break;
                case 3 :
                    // /Library/WebServer/Documents/calc/Formula.g:123:5: whileLoop
                    root_0 = this.adaptor.nil();

                    this.pushFollow(FormulaParser.FOLLOW_whileLoop_in_expression520);
                    whileLoop8=this.whileLoop();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, whileLoop8.getTree());


                    break;
                case 4 :
                    // /Library/WebServer/Documents/calc/Formula.g:124:5: forLoop
                    root_0 = this.adaptor.nil();

                    this.pushFollow(FormulaParser.FOLLOW_forLoop_in_expression526);
                    forLoop9=this.forLoop();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, forLoop9.getTree());


                    break;
                case 5 :
                    // /Library/WebServer/Documents/calc/Formula.g:125:5: forInLoop
                    root_0 = this.adaptor.nil();

                    this.pushFollow(FormulaParser.FOLLOW_forInLoop_in_expression532);
                    forInLoop10=this.forInLoop();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, forInLoop10.getTree());


                    break;
                case 6 :
                    // /Library/WebServer/Documents/calc/Formula.g:126:5: ifThenElse
                    root_0 = this.adaptor.nil();

                    this.pushFollow(FormulaParser.FOLLOW_ifThenElse_in_expression538);
                    ifThenElse11=this.ifThenElse();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, ifThenElse11.getTree());


                    break;
                case 7 :
                    // /Library/WebServer/Documents/calc/Formula.g:127:5: functionDef
                    root_0 = this.adaptor.nil();

                    this.pushFollow(FormulaParser.FOLLOW_functionDef_in_expression544);
                    functionDef12=this.functionDef();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, functionDef12.getTree());


                    break;
                case 8 :
                    // /Library/WebServer/Documents/calc/Formula.g:128:5: returnExp
                    root_0 = this.adaptor.nil();

                    this.pushFollow(FormulaParser.FOLLOW_returnExp_in_expression550);
                    returnExp13=this.returnExp();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, returnExp13.getTree());


                    break;
                case 9 :
                    // /Library/WebServer/Documents/calc/Formula.g:129:5: tryCatch
                    root_0 = this.adaptor.nil();

                    this.pushFollow(FormulaParser.FOLLOW_tryCatch_in_expression556);
                    tryCatch14=this.tryCatch();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, tryCatch14.getTree());


                    break;
                case 10 :
                    // /Library/WebServer/Documents/calc/Formula.g:130:5: throwExp
                    root_0 = this.adaptor.nil();

                    this.pushFollow(FormulaParser.FOLLOW_throwExp_in_expression562);
                    throwExp15=this.throwExp();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, throwExp15.getTree());


                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    returnExp_return: (function() {
        FormulaParser.returnExp_return = function(){};
        org.antlr.lang.extend(FormulaParser.returnExp_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // /Library/WebServer/Documents/calc/Formula.g:133:1: returnExp : RETURNSTATEMENT logicalExpression ;
    // $ANTLR start "returnExp"
    returnExp: function() {
        var retval = new FormulaParser.returnExp_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var RETURNSTATEMENT16 = null;
         var logicalExpression17 = null;

        var RETURNSTATEMENT16_tree=null;

        try {
            // /Library/WebServer/Documents/calc/Formula.g:134:2: ( RETURNSTATEMENT logicalExpression )
            // /Library/WebServer/Documents/calc/Formula.g:135:2: RETURNSTATEMENT logicalExpression
            root_0 = this.adaptor.nil();

            RETURNSTATEMENT16=this.match(this.input,RETURNSTATEMENT,FormulaParser.FOLLOW_RETURNSTATEMENT_in_returnExp574); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            RETURNSTATEMENT16_tree = this.adaptor.create(RETURNSTATEMENT16);
            root_0 = this.adaptor.becomeRoot(RETURNSTATEMENT16_tree, root_0);
            }
            this.pushFollow(FormulaParser.FOLLOW_logicalExpression_in_returnExp577);
            logicalExpression17=this.logicalExpression();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, logicalExpression17.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    innerBlock_return: (function() {
        FormulaParser.innerBlock_return = function(){};
        org.antlr.lang.extend(FormulaParser.innerBlock_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // /Library/WebServer/Documents/calc/Formula.g:138:1: innerBlock : ( expression ( ( NEWLINE )+ ) )* -> ^( LINES ( expression )+ ) ;
    // $ANTLR start "innerBlock"
    innerBlock: function() {
        var retval = new FormulaParser.innerBlock_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var NEWLINE19 = null;
         var expression18 = null;

        var NEWLINE19_tree=null;
        var stream_NEWLINE=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token NEWLINE");
        var stream_expression=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule expression");
        try {
            // /Library/WebServer/Documents/calc/Formula.g:139:2: ( ( expression ( ( NEWLINE )+ ) )* -> ^( LINES ( expression )+ ) )
            // /Library/WebServer/Documents/calc/Formula.g:139:4: ( expression ( ( NEWLINE )+ ) )*
            // /Library/WebServer/Documents/calc/Formula.g:139:4: ( expression ( ( NEWLINE )+ ) )*
            loop7:
            do {
                var alt7=2;
                var LA7_0 = this.input.LA(1);

                if ( (LA7_0==WHILESTATEMENT||LA7_0==FORSTATEMENT||LA7_0==IFSTATEMENT||LA7_0==FUNCTIONSTATEMENT||(LA7_0>=RETURNSTATEMENT && LA7_0<=TRYSTATEMENT)||(LA7_0>=THROWSTATEMENT && LA7_0<=IDENT)||LA7_0==PRIMITIVE||LA7_0==MINUS||(LA7_0>=NOT && LA7_0<=LARR)||LA7_0==LCURL||(LA7_0>=STRING && LA7_0<=FALSE)||LA7_0==113) ) {
                    alt7=1;
                }


                switch (alt7) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:139:5: expression ( ( NEWLINE )+ )
                    this.pushFollow(FormulaParser.FOLLOW_expression_in_innerBlock590);
                    expression18=this.expression();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) stream_expression.add(expression18.getTree());
                    // /Library/WebServer/Documents/calc/Formula.g:139:17: ( ( NEWLINE )+ )
                    // /Library/WebServer/Documents/calc/Formula.g:139:18: ( NEWLINE )+
                    // /Library/WebServer/Documents/calc/Formula.g:139:18: ( NEWLINE )+
                    var cnt6=0;
                    loop6:
                    do {
                        var alt6=2;
                        var LA6_0 = this.input.LA(1);

                        if ( (LA6_0==NEWLINE) ) {
                            alt6=1;
                        }


                        switch (alt6) {
                        case 1 :
                            // /Library/WebServer/Documents/calc/Formula.g:0:0: NEWLINE
                            NEWLINE19=this.match(this.input,NEWLINE,FormulaParser.FOLLOW_NEWLINE_in_innerBlock594); if (this.state.failed) return retval; 
                            if ( this.state.backtracking===0 ) stream_NEWLINE.add(NEWLINE19);



                            break;

                        default :
                            if ( cnt6 >= 1 ) {
                                break loop6;
                            }
                            if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                                var eee = new org.antlr.runtime.EarlyExitException(6, this.input);
                                throw eee;
                        }
                        cnt6++;
                    } while (true);






                    break;

                default :
                    break loop7;
                }
            } while (true);



            // AST REWRITE
            // elements: expression
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            if ( this.state.backtracking===0 ) {
            retval.tree = root_0;
            var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

            root_0 = this.adaptor.nil();
            // 139:30: -> ^( LINES ( expression )+ )
            {
                // /Library/WebServer/Documents/calc/Formula.g:139:33: ^( LINES ( expression )+ )
                {
                var root_1 = this.adaptor.nil();
                root_1 = this.adaptor.becomeRoot(this.adaptor.create(LINES, "LINES"), root_1);

                if ( !(stream_expression.hasNext()) ) {
                    throw new org.antlr.runtime.tree.RewriteEarlyExitException();
                }
                while ( stream_expression.hasNext() ) {
                    this.adaptor.addChild(root_1, stream_expression.nextTree());

                }
                stream_expression.reset();

                this.adaptor.addChild(root_0, root_1);
                }

            }

            retval.tree = root_0;}


            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    whileLoop_return: (function() {
        FormulaParser.whileLoop_return = function(){};
        org.antlr.lang.extend(FormulaParser.whileLoop_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // /Library/WebServer/Documents/calc/Formula.g:142:1: whileLoop : WHILESTATEMENT logicalExpression ( NEWLINE )+ innerBlock ENDBLOCK LOOPSTATEMENT -> ^( WHILE logicalExpression innerBlock ) ;
    // $ANTLR start "whileLoop"
    whileLoop: function() {
        var retval = new FormulaParser.whileLoop_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var WHILESTATEMENT20 = null;
        var NEWLINE22 = null;
        var ENDBLOCK24 = null;
        var LOOPSTATEMENT25 = null;
         var logicalExpression21 = null;
         var innerBlock23 = null;

        var WHILESTATEMENT20_tree=null;
        var NEWLINE22_tree=null;
        var ENDBLOCK24_tree=null;
        var LOOPSTATEMENT25_tree=null;
        var stream_NEWLINE=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token NEWLINE");
        var stream_ENDBLOCK=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token ENDBLOCK");
        var stream_LOOPSTATEMENT=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token LOOPSTATEMENT");
        var stream_WHILESTATEMENT=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token WHILESTATEMENT");
        var stream_innerBlock=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule innerBlock");
        var stream_logicalExpression=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule logicalExpression");
        try {
            // /Library/WebServer/Documents/calc/Formula.g:143:2: ( WHILESTATEMENT logicalExpression ( NEWLINE )+ innerBlock ENDBLOCK LOOPSTATEMENT -> ^( WHILE logicalExpression innerBlock ) )
            // /Library/WebServer/Documents/calc/Formula.g:143:4: WHILESTATEMENT logicalExpression ( NEWLINE )+ innerBlock ENDBLOCK LOOPSTATEMENT
            WHILESTATEMENT20=this.match(this.input,WHILESTATEMENT,FormulaParser.FOLLOW_WHILESTATEMENT_in_whileLoop619); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_WHILESTATEMENT.add(WHILESTATEMENT20);

            this.pushFollow(FormulaParser.FOLLOW_logicalExpression_in_whileLoop621);
            logicalExpression21=this.logicalExpression();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) stream_logicalExpression.add(logicalExpression21.getTree());
            // /Library/WebServer/Documents/calc/Formula.g:143:37: ( NEWLINE )+
            var cnt8=0;
            loop8:
            do {
                var alt8=2;
                var LA8_0 = this.input.LA(1);

                if ( (LA8_0==NEWLINE) ) {
                    alt8=1;
                }


                switch (alt8) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:0:0: NEWLINE
                    NEWLINE22=this.match(this.input,NEWLINE,FormulaParser.FOLLOW_NEWLINE_in_whileLoop623); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_NEWLINE.add(NEWLINE22);



                    break;

                default :
                    if ( cnt8 >= 1 ) {
                        break loop8;
                    }
                    if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        var eee = new org.antlr.runtime.EarlyExitException(8, this.input);
                        throw eee;
                }
                cnt8++;
            } while (true);

            this.pushFollow(FormulaParser.FOLLOW_innerBlock_in_whileLoop626);
            innerBlock23=this.innerBlock();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) stream_innerBlock.add(innerBlock23.getTree());
            ENDBLOCK24=this.match(this.input,ENDBLOCK,FormulaParser.FOLLOW_ENDBLOCK_in_whileLoop629); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_ENDBLOCK.add(ENDBLOCK24);

            LOOPSTATEMENT25=this.match(this.input,LOOPSTATEMENT,FormulaParser.FOLLOW_LOOPSTATEMENT_in_whileLoop631); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_LOOPSTATEMENT.add(LOOPSTATEMENT25);



            // AST REWRITE
            // elements: innerBlock, logicalExpression
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            if ( this.state.backtracking===0 ) {
            retval.tree = root_0;
            var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

            root_0 = this.adaptor.nil();
            // 143:81: -> ^( WHILE logicalExpression innerBlock )
            {
                // /Library/WebServer/Documents/calc/Formula.g:143:84: ^( WHILE logicalExpression innerBlock )
                {
                var root_1 = this.adaptor.nil();
                root_1 = this.adaptor.becomeRoot(this.adaptor.create(WHILE, "WHILE"), root_1);

                this.adaptor.addChild(root_1, stream_logicalExpression.nextTree());
                this.adaptor.addChild(root_1, stream_innerBlock.nextTree());

                this.adaptor.addChild(root_0, root_1);
                }

            }

            retval.tree = root_0;}


            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    forLoop_return: (function() {
        FormulaParser.forLoop_return = function(){};
        org.antlr.lang.extend(FormulaParser.forLoop_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // /Library/WebServer/Documents/calc/Formula.g:146:1: forLoop : FORSTATEMENT IDENT FROMSTATEMENT logicalExpression TOSTATEMENT logicalExpression ( BYSTATEMENT logicalExpression )? ( NEWLINE )+ innerBlock ENDBLOCK LOOPSTATEMENT -> ^( FOR IDENT ^( PARAMS ( logicalExpression )* ) innerBlock ) ;
    // $ANTLR start "forLoop"
    forLoop: function() {
        var retval = new FormulaParser.forLoop_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var FORSTATEMENT26 = null;
        var IDENT27 = null;
        var FROMSTATEMENT28 = null;
        var TOSTATEMENT30 = null;
        var BYSTATEMENT32 = null;
        var NEWLINE34 = null;
        var ENDBLOCK36 = null;
        var LOOPSTATEMENT37 = null;
         var logicalExpression29 = null;
         var logicalExpression31 = null;
         var logicalExpression33 = null;
         var innerBlock35 = null;

        var FORSTATEMENT26_tree=null;
        var IDENT27_tree=null;
        var FROMSTATEMENT28_tree=null;
        var TOSTATEMENT30_tree=null;
        var BYSTATEMENT32_tree=null;
        var NEWLINE34_tree=null;
        var ENDBLOCK36_tree=null;
        var LOOPSTATEMENT37_tree=null;
        var stream_FORSTATEMENT=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token FORSTATEMENT");
        var stream_IDENT=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token IDENT");
        var stream_FROMSTATEMENT=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token FROMSTATEMENT");
        var stream_NEWLINE=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token NEWLINE");
        var stream_TOSTATEMENT=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token TOSTATEMENT");
        var stream_ENDBLOCK=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token ENDBLOCK");
        var stream_LOOPSTATEMENT=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token LOOPSTATEMENT");
        var stream_BYSTATEMENT=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token BYSTATEMENT");
        var stream_innerBlock=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule innerBlock");
        var stream_logicalExpression=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule logicalExpression");
        try {
            // /Library/WebServer/Documents/calc/Formula.g:147:2: ( FORSTATEMENT IDENT FROMSTATEMENT logicalExpression TOSTATEMENT logicalExpression ( BYSTATEMENT logicalExpression )? ( NEWLINE )+ innerBlock ENDBLOCK LOOPSTATEMENT -> ^( FOR IDENT ^( PARAMS ( logicalExpression )* ) innerBlock ) )
            // /Library/WebServer/Documents/calc/Formula.g:147:4: FORSTATEMENT IDENT FROMSTATEMENT logicalExpression TOSTATEMENT logicalExpression ( BYSTATEMENT logicalExpression )? ( NEWLINE )+ innerBlock ENDBLOCK LOOPSTATEMENT
            FORSTATEMENT26=this.match(this.input,FORSTATEMENT,FormulaParser.FOLLOW_FORSTATEMENT_in_forLoop652); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_FORSTATEMENT.add(FORSTATEMENT26);

            IDENT27=this.match(this.input,IDENT,FormulaParser.FOLLOW_IDENT_in_forLoop654); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_IDENT.add(IDENT27);

            FROMSTATEMENT28=this.match(this.input,FROMSTATEMENT,FormulaParser.FOLLOW_FROMSTATEMENT_in_forLoop656); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_FROMSTATEMENT.add(FROMSTATEMENT28);

            this.pushFollow(FormulaParser.FOLLOW_logicalExpression_in_forLoop658);
            logicalExpression29=this.logicalExpression();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) stream_logicalExpression.add(logicalExpression29.getTree());
            TOSTATEMENT30=this.match(this.input,TOSTATEMENT,FormulaParser.FOLLOW_TOSTATEMENT_in_forLoop660); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_TOSTATEMENT.add(TOSTATEMENT30);

            this.pushFollow(FormulaParser.FOLLOW_logicalExpression_in_forLoop662);
            logicalExpression31=this.logicalExpression();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) stream_logicalExpression.add(logicalExpression31.getTree());
            // /Library/WebServer/Documents/calc/Formula.g:147:85: ( BYSTATEMENT logicalExpression )?
            var alt9=2;
            var LA9_0 = this.input.LA(1);

            if ( (LA9_0==BYSTATEMENT) ) {
                alt9=1;
            }
            switch (alt9) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:147:86: BYSTATEMENT logicalExpression
                    BYSTATEMENT32=this.match(this.input,BYSTATEMENT,FormulaParser.FOLLOW_BYSTATEMENT_in_forLoop665); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_BYSTATEMENT.add(BYSTATEMENT32);

                    this.pushFollow(FormulaParser.FOLLOW_logicalExpression_in_forLoop667);
                    logicalExpression33=this.logicalExpression();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) stream_logicalExpression.add(logicalExpression33.getTree());


                    break;

            }

            // /Library/WebServer/Documents/calc/Formula.g:147:118: ( NEWLINE )+
            var cnt10=0;
            loop10:
            do {
                var alt10=2;
                var LA10_0 = this.input.LA(1);

                if ( (LA10_0==NEWLINE) ) {
                    alt10=1;
                }


                switch (alt10) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:0:0: NEWLINE
                    NEWLINE34=this.match(this.input,NEWLINE,FormulaParser.FOLLOW_NEWLINE_in_forLoop671); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_NEWLINE.add(NEWLINE34);



                    break;

                default :
                    if ( cnt10 >= 1 ) {
                        break loop10;
                    }
                    if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        var eee = new org.antlr.runtime.EarlyExitException(10, this.input);
                        throw eee;
                }
                cnt10++;
            } while (true);

            this.pushFollow(FormulaParser.FOLLOW_innerBlock_in_forLoop674);
            innerBlock35=this.innerBlock();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) stream_innerBlock.add(innerBlock35.getTree());
            ENDBLOCK36=this.match(this.input,ENDBLOCK,FormulaParser.FOLLOW_ENDBLOCK_in_forLoop677); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_ENDBLOCK.add(ENDBLOCK36);

            LOOPSTATEMENT37=this.match(this.input,LOOPSTATEMENT,FormulaParser.FOLLOW_LOOPSTATEMENT_in_forLoop679); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_LOOPSTATEMENT.add(LOOPSTATEMENT37);



            // AST REWRITE
            // elements: logicalExpression, innerBlock, IDENT
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            if ( this.state.backtracking===0 ) {
            retval.tree = root_0;
            var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

            root_0 = this.adaptor.nil();
            // 147:162: -> ^( FOR IDENT ^( PARAMS ( logicalExpression )* ) innerBlock )
            {
                // /Library/WebServer/Documents/calc/Formula.g:147:165: ^( FOR IDENT ^( PARAMS ( logicalExpression )* ) innerBlock )
                {
                var root_1 = this.adaptor.nil();
                root_1 = this.adaptor.becomeRoot(this.adaptor.create(FOR, "FOR"), root_1);

                this.adaptor.addChild(root_1, stream_IDENT.nextNode());
                // /Library/WebServer/Documents/calc/Formula.g:147:177: ^( PARAMS ( logicalExpression )* )
                {
                var root_2 = this.adaptor.nil();
                root_2 = this.adaptor.becomeRoot(this.adaptor.create(PARAMS, "PARAMS"), root_2);

                // /Library/WebServer/Documents/calc/Formula.g:147:186: ( logicalExpression )*
                while ( stream_logicalExpression.hasNext() ) {
                    this.adaptor.addChild(root_2, stream_logicalExpression.nextTree());

                }
                stream_logicalExpression.reset();

                this.adaptor.addChild(root_1, root_2);
                }
                this.adaptor.addChild(root_1, stream_innerBlock.nextTree());

                this.adaptor.addChild(root_0, root_1);
                }

            }

            retval.tree = root_0;}


            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    forInLoop_return: (function() {
        FormulaParser.forInLoop_return = function(){};
        org.antlr.lang.extend(FormulaParser.forInLoop_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // /Library/WebServer/Documents/calc/Formula.g:150:1: forInLoop : FORSTATEMENT IDENT INSTATEMENT logicalExpression ( NEWLINE )+ innerBlock ENDBLOCK LOOPSTATEMENT -> ^( FORIN IDENT logicalExpression innerBlock ) ;
    // $ANTLR start "forInLoop"
    forInLoop: function() {
        var retval = new FormulaParser.forInLoop_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var FORSTATEMENT38 = null;
        var IDENT39 = null;
        var INSTATEMENT40 = null;
        var NEWLINE42 = null;
        var ENDBLOCK44 = null;
        var LOOPSTATEMENT45 = null;
         var logicalExpression41 = null;
         var innerBlock43 = null;

        var FORSTATEMENT38_tree=null;
        var IDENT39_tree=null;
        var INSTATEMENT40_tree=null;
        var NEWLINE42_tree=null;
        var ENDBLOCK44_tree=null;
        var LOOPSTATEMENT45_tree=null;
        var stream_FORSTATEMENT=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token FORSTATEMENT");
        var stream_IDENT=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token IDENT");
        var stream_NEWLINE=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token NEWLINE");
        var stream_ENDBLOCK=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token ENDBLOCK");
        var stream_LOOPSTATEMENT=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token LOOPSTATEMENT");
        var stream_INSTATEMENT=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token INSTATEMENT");
        var stream_innerBlock=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule innerBlock");
        var stream_logicalExpression=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule logicalExpression");
        try {
            // /Library/WebServer/Documents/calc/Formula.g:151:2: ( FORSTATEMENT IDENT INSTATEMENT logicalExpression ( NEWLINE )+ innerBlock ENDBLOCK LOOPSTATEMENT -> ^( FORIN IDENT logicalExpression innerBlock ) )
            // /Library/WebServer/Documents/calc/Formula.g:151:4: FORSTATEMENT IDENT INSTATEMENT logicalExpression ( NEWLINE )+ innerBlock ENDBLOCK LOOPSTATEMENT
            FORSTATEMENT38=this.match(this.input,FORSTATEMENT,FormulaParser.FOLLOW_FORSTATEMENT_in_forInLoop707); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_FORSTATEMENT.add(FORSTATEMENT38);

            IDENT39=this.match(this.input,IDENT,FormulaParser.FOLLOW_IDENT_in_forInLoop709); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_IDENT.add(IDENT39);

            INSTATEMENT40=this.match(this.input,INSTATEMENT,FormulaParser.FOLLOW_INSTATEMENT_in_forInLoop711); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_INSTATEMENT.add(INSTATEMENT40);

            this.pushFollow(FormulaParser.FOLLOW_logicalExpression_in_forInLoop713);
            logicalExpression41=this.logicalExpression();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) stream_logicalExpression.add(logicalExpression41.getTree());
            // /Library/WebServer/Documents/calc/Formula.g:151:53: ( NEWLINE )+
            var cnt11=0;
            loop11:
            do {
                var alt11=2;
                var LA11_0 = this.input.LA(1);

                if ( (LA11_0==NEWLINE) ) {
                    alt11=1;
                }


                switch (alt11) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:0:0: NEWLINE
                    NEWLINE42=this.match(this.input,NEWLINE,FormulaParser.FOLLOW_NEWLINE_in_forInLoop715); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_NEWLINE.add(NEWLINE42);



                    break;

                default :
                    if ( cnt11 >= 1 ) {
                        break loop11;
                    }
                    if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        var eee = new org.antlr.runtime.EarlyExitException(11, this.input);
                        throw eee;
                }
                cnt11++;
            } while (true);

            this.pushFollow(FormulaParser.FOLLOW_innerBlock_in_forInLoop718);
            innerBlock43=this.innerBlock();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) stream_innerBlock.add(innerBlock43.getTree());
            ENDBLOCK44=this.match(this.input,ENDBLOCK,FormulaParser.FOLLOW_ENDBLOCK_in_forInLoop721); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_ENDBLOCK.add(ENDBLOCK44);

            LOOPSTATEMENT45=this.match(this.input,LOOPSTATEMENT,FormulaParser.FOLLOW_LOOPSTATEMENT_in_forInLoop723); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_LOOPSTATEMENT.add(LOOPSTATEMENT45);



            // AST REWRITE
            // elements: IDENT, innerBlock, logicalExpression
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            if ( this.state.backtracking===0 ) {
            retval.tree = root_0;
            var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

            root_0 = this.adaptor.nil();
            // 151:98: -> ^( FORIN IDENT logicalExpression innerBlock )
            {
                // /Library/WebServer/Documents/calc/Formula.g:151:101: ^( FORIN IDENT logicalExpression innerBlock )
                {
                var root_1 = this.adaptor.nil();
                root_1 = this.adaptor.becomeRoot(this.adaptor.create(FORIN, "FORIN"), root_1);

                this.adaptor.addChild(root_1, stream_IDENT.nextNode());
                this.adaptor.addChild(root_1, stream_logicalExpression.nextTree());
                this.adaptor.addChild(root_1, stream_innerBlock.nextTree());

                this.adaptor.addChild(root_0, root_1);
                }

            }

            retval.tree = root_0;}


            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    ifThenElse_return: (function() {
        FormulaParser.ifThenElse_return = function(){};
        org.antlr.lang.extend(FormulaParser.ifThenElse_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // /Library/WebServer/Documents/calc/Formula.g:154:1: ifThenElse : IFSTATEMENT logicalExpression THENSTATEMENT ( NEWLINE )+ innerBlock ( ELSESTATEMENT IFSTATEMENT logicalExpression THENSTATEMENT ( NEWLINE )+ innerBlock )* ( ELSESTATEMENT ( NEWLINE )+ innerBlock )? ENDBLOCK IFSTATEMENT -> ^( IFTHENELSE ^( PARAMS ( logicalExpression )+ ) ^( PARAMS ( innerBlock )+ ) ) ;
    // $ANTLR start "ifThenElse"
    ifThenElse: function() {
        var retval = new FormulaParser.ifThenElse_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var IFSTATEMENT46 = null;
        var THENSTATEMENT48 = null;
        var NEWLINE49 = null;
        var ELSESTATEMENT51 = null;
        var IFSTATEMENT52 = null;
        var THENSTATEMENT54 = null;
        var NEWLINE55 = null;
        var ELSESTATEMENT57 = null;
        var NEWLINE58 = null;
        var ENDBLOCK60 = null;
        var IFSTATEMENT61 = null;
         var logicalExpression47 = null;
         var innerBlock50 = null;
         var logicalExpression53 = null;
         var innerBlock56 = null;
         var innerBlock59 = null;

        var IFSTATEMENT46_tree=null;
        var THENSTATEMENT48_tree=null;
        var NEWLINE49_tree=null;
        var ELSESTATEMENT51_tree=null;
        var IFSTATEMENT52_tree=null;
        var THENSTATEMENT54_tree=null;
        var NEWLINE55_tree=null;
        var ELSESTATEMENT57_tree=null;
        var NEWLINE58_tree=null;
        var ENDBLOCK60_tree=null;
        var IFSTATEMENT61_tree=null;
        var stream_IFSTATEMENT=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token IFSTATEMENT");
        var stream_NEWLINE=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token NEWLINE");
        var stream_ENDBLOCK=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token ENDBLOCK");
        var stream_ELSESTATEMENT=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token ELSESTATEMENT");
        var stream_THENSTATEMENT=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token THENSTATEMENT");
        var stream_innerBlock=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule innerBlock");
        var stream_logicalExpression=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule logicalExpression");
        try {
            // /Library/WebServer/Documents/calc/Formula.g:155:2: ( IFSTATEMENT logicalExpression THENSTATEMENT ( NEWLINE )+ innerBlock ( ELSESTATEMENT IFSTATEMENT logicalExpression THENSTATEMENT ( NEWLINE )+ innerBlock )* ( ELSESTATEMENT ( NEWLINE )+ innerBlock )? ENDBLOCK IFSTATEMENT -> ^( IFTHENELSE ^( PARAMS ( logicalExpression )+ ) ^( PARAMS ( innerBlock )+ ) ) )
            // /Library/WebServer/Documents/calc/Formula.g:155:4: IFSTATEMENT logicalExpression THENSTATEMENT ( NEWLINE )+ innerBlock ( ELSESTATEMENT IFSTATEMENT logicalExpression THENSTATEMENT ( NEWLINE )+ innerBlock )* ( ELSESTATEMENT ( NEWLINE )+ innerBlock )? ENDBLOCK IFSTATEMENT
            IFSTATEMENT46=this.match(this.input,IFSTATEMENT,FormulaParser.FOLLOW_IFSTATEMENT_in_ifThenElse748); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_IFSTATEMENT.add(IFSTATEMENT46);

            this.pushFollow(FormulaParser.FOLLOW_logicalExpression_in_ifThenElse750);
            logicalExpression47=this.logicalExpression();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) stream_logicalExpression.add(logicalExpression47.getTree());
            THENSTATEMENT48=this.match(this.input,THENSTATEMENT,FormulaParser.FOLLOW_THENSTATEMENT_in_ifThenElse752); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_THENSTATEMENT.add(THENSTATEMENT48);

            // /Library/WebServer/Documents/calc/Formula.g:155:49: ( NEWLINE )+
            var cnt12=0;
            loop12:
            do {
                var alt12=2;
                var LA12_0 = this.input.LA(1);

                if ( (LA12_0==NEWLINE) ) {
                    alt12=1;
                }


                switch (alt12) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:0:0: NEWLINE
                    NEWLINE49=this.match(this.input,NEWLINE,FormulaParser.FOLLOW_NEWLINE_in_ifThenElse755); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_NEWLINE.add(NEWLINE49);



                    break;

                default :
                    if ( cnt12 >= 1 ) {
                        break loop12;
                    }
                    if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        var eee = new org.antlr.runtime.EarlyExitException(12, this.input);
                        throw eee;
                }
                cnt12++;
            } while (true);

            this.pushFollow(FormulaParser.FOLLOW_innerBlock_in_ifThenElse758);
            innerBlock50=this.innerBlock();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) stream_innerBlock.add(innerBlock50.getTree());
            // /Library/WebServer/Documents/calc/Formula.g:155:70: ( ELSESTATEMENT IFSTATEMENT logicalExpression THENSTATEMENT ( NEWLINE )+ innerBlock )*
            loop14:
            do {
                var alt14=2;
                var LA14_0 = this.input.LA(1);

                if ( (LA14_0==ELSESTATEMENT) ) {
                    var LA14_1 = this.input.LA(2);

                    if ( (LA14_1==IFSTATEMENT) ) {
                        alt14=1;
                    }


                }


                switch (alt14) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:155:71: ELSESTATEMENT IFSTATEMENT logicalExpression THENSTATEMENT ( NEWLINE )+ innerBlock
                    ELSESTATEMENT51=this.match(this.input,ELSESTATEMENT,FormulaParser.FOLLOW_ELSESTATEMENT_in_ifThenElse762); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_ELSESTATEMENT.add(ELSESTATEMENT51);

                    IFSTATEMENT52=this.match(this.input,IFSTATEMENT,FormulaParser.FOLLOW_IFSTATEMENT_in_ifThenElse764); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_IFSTATEMENT.add(IFSTATEMENT52);

                    this.pushFollow(FormulaParser.FOLLOW_logicalExpression_in_ifThenElse766);
                    logicalExpression53=this.logicalExpression();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) stream_logicalExpression.add(logicalExpression53.getTree());
                    THENSTATEMENT54=this.match(this.input,THENSTATEMENT,FormulaParser.FOLLOW_THENSTATEMENT_in_ifThenElse768); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_THENSTATEMENT.add(THENSTATEMENT54);

                    // /Library/WebServer/Documents/calc/Formula.g:155:129: ( NEWLINE )+
                    var cnt13=0;
                    loop13:
                    do {
                        var alt13=2;
                        var LA13_0 = this.input.LA(1);

                        if ( (LA13_0==NEWLINE) ) {
                            alt13=1;
                        }


                        switch (alt13) {
                        case 1 :
                            // /Library/WebServer/Documents/calc/Formula.g:0:0: NEWLINE
                            NEWLINE55=this.match(this.input,NEWLINE,FormulaParser.FOLLOW_NEWLINE_in_ifThenElse770); if (this.state.failed) return retval; 
                            if ( this.state.backtracking===0 ) stream_NEWLINE.add(NEWLINE55);



                            break;

                        default :
                            if ( cnt13 >= 1 ) {
                                break loop13;
                            }
                            if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                                var eee = new org.antlr.runtime.EarlyExitException(13, this.input);
                                throw eee;
                        }
                        cnt13++;
                    } while (true);

                    this.pushFollow(FormulaParser.FOLLOW_innerBlock_in_ifThenElse773);
                    innerBlock56=this.innerBlock();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) stream_innerBlock.add(innerBlock56.getTree());


                    break;

                default :
                    break loop14;
                }
            } while (true);

            // /Library/WebServer/Documents/calc/Formula.g:155:151: ( ELSESTATEMENT ( NEWLINE )+ innerBlock )?
            var alt16=2;
            var LA16_0 = this.input.LA(1);

            if ( (LA16_0==ELSESTATEMENT) ) {
                alt16=1;
            }
            switch (alt16) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:155:152: ELSESTATEMENT ( NEWLINE )+ innerBlock
                    ELSESTATEMENT57=this.match(this.input,ELSESTATEMENT,FormulaParser.FOLLOW_ELSESTATEMENT_in_ifThenElse778); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_ELSESTATEMENT.add(ELSESTATEMENT57);

                    // /Library/WebServer/Documents/calc/Formula.g:155:166: ( NEWLINE )+
                    var cnt15=0;
                    loop15:
                    do {
                        var alt15=2;
                        var LA15_0 = this.input.LA(1);

                        if ( (LA15_0==NEWLINE) ) {
                            alt15=1;
                        }


                        switch (alt15) {
                        case 1 :
                            // /Library/WebServer/Documents/calc/Formula.g:0:0: NEWLINE
                            NEWLINE58=this.match(this.input,NEWLINE,FormulaParser.FOLLOW_NEWLINE_in_ifThenElse780); if (this.state.failed) return retval; 
                            if ( this.state.backtracking===0 ) stream_NEWLINE.add(NEWLINE58);



                            break;

                        default :
                            if ( cnt15 >= 1 ) {
                                break loop15;
                            }
                            if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                                var eee = new org.antlr.runtime.EarlyExitException(15, this.input);
                                throw eee;
                        }
                        cnt15++;
                    } while (true);

                    this.pushFollow(FormulaParser.FOLLOW_innerBlock_in_ifThenElse783);
                    innerBlock59=this.innerBlock();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) stream_innerBlock.add(innerBlock59.getTree());


                    break;

            }

            ENDBLOCK60=this.match(this.input,ENDBLOCK,FormulaParser.FOLLOW_ENDBLOCK_in_ifThenElse787); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_ENDBLOCK.add(ENDBLOCK60);

            IFSTATEMENT61=this.match(this.input,IFSTATEMENT,FormulaParser.FOLLOW_IFSTATEMENT_in_ifThenElse789); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_IFSTATEMENT.add(IFSTATEMENT61);



            // AST REWRITE
            // elements: innerBlock, logicalExpression
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            if ( this.state.backtracking===0 ) {
            retval.tree = root_0;
            var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

            root_0 = this.adaptor.nil();
            // 155:209: -> ^( IFTHENELSE ^( PARAMS ( logicalExpression )+ ) ^( PARAMS ( innerBlock )+ ) )
            {
                // /Library/WebServer/Documents/calc/Formula.g:155:212: ^( IFTHENELSE ^( PARAMS ( logicalExpression )+ ) ^( PARAMS ( innerBlock )+ ) )
                {
                var root_1 = this.adaptor.nil();
                root_1 = this.adaptor.becomeRoot(this.adaptor.create(IFTHENELSE, "IFTHENELSE"), root_1);

                // /Library/WebServer/Documents/calc/Formula.g:155:225: ^( PARAMS ( logicalExpression )+ )
                {
                var root_2 = this.adaptor.nil();
                root_2 = this.adaptor.becomeRoot(this.adaptor.create(PARAMS, "PARAMS"), root_2);

                if ( !(stream_logicalExpression.hasNext()) ) {
                    throw new org.antlr.runtime.tree.RewriteEarlyExitException();
                }
                while ( stream_logicalExpression.hasNext() ) {
                    this.adaptor.addChild(root_2, stream_logicalExpression.nextTree());

                }
                stream_logicalExpression.reset();

                this.adaptor.addChild(root_1, root_2);
                }
                // /Library/WebServer/Documents/calc/Formula.g:155:254: ^( PARAMS ( innerBlock )+ )
                {
                var root_2 = this.adaptor.nil();
                root_2 = this.adaptor.becomeRoot(this.adaptor.create(PARAMS, "PARAMS"), root_2);

                if ( !(stream_innerBlock.hasNext()) ) {
                    throw new org.antlr.runtime.tree.RewriteEarlyExitException();
                }
                while ( stream_innerBlock.hasNext() ) {
                    this.adaptor.addChild(root_2, stream_innerBlock.nextTree());

                }
                stream_innerBlock.reset();

                this.adaptor.addChild(root_1, root_2);
                }

                this.adaptor.addChild(root_0, root_1);
                }

            }

            retval.tree = root_0;}


            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    functionDef_return: (function() {
        FormulaParser.functionDef_return = function(){};
        org.antlr.lang.extend(FormulaParser.functionDef_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // /Library/WebServer/Documents/calc/Formula.g:158:1: functionDef : FUNCTIONSTATEMENT IDENT '(' ( IDENT ( EQUALS defaultValue | ( ',' IDENT )* ) ( ',' IDENT EQUALS defaultValue )* )? ')' ( NEWLINE )+ innerBlock ENDBLOCK FUNCTIONSTATEMENT -> ^( FUNCTION ^( PARAMS ( IDENT )* ) ^( DEFAULTS ( defaultValue )* ) innerBlock ) ;
    // $ANTLR start "functionDef"
    functionDef: function() {
        var retval = new FormulaParser.functionDef_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var FUNCTIONSTATEMENT62 = null;
        var IDENT63 = null;
        var char_literal64 = null;
        var IDENT65 = null;
        var EQUALS66 = null;
        var char_literal68 = null;
        var IDENT69 = null;
        var char_literal70 = null;
        var IDENT71 = null;
        var EQUALS72 = null;
        var char_literal74 = null;
        var NEWLINE75 = null;
        var ENDBLOCK77 = null;
        var FUNCTIONSTATEMENT78 = null;
         var defaultValue67 = null;
         var defaultValue73 = null;
         var innerBlock76 = null;

        var FUNCTIONSTATEMENT62_tree=null;
        var IDENT63_tree=null;
        var char_literal64_tree=null;
        var IDENT65_tree=null;
        var EQUALS66_tree=null;
        var char_literal68_tree=null;
        var IDENT69_tree=null;
        var char_literal70_tree=null;
        var IDENT71_tree=null;
        var EQUALS72_tree=null;
        var char_literal74_tree=null;
        var NEWLINE75_tree=null;
        var ENDBLOCK77_tree=null;
        var FUNCTIONSTATEMENT78_tree=null;
        var stream_FUNCTIONSTATEMENT=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token FUNCTIONSTATEMENT");
        var stream_114=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token 114");
        var stream_IDENT=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token IDENT");
        var stream_EQUALS=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token EQUALS");
        var stream_113=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token 113");
        var stream_NEWLINE=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token NEWLINE");
        var stream_COMMA=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token COMMA");
        var stream_ENDBLOCK=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token ENDBLOCK");
        var stream_innerBlock=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule innerBlock");
        var stream_defaultValue=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule defaultValue");
        try {
            // /Library/WebServer/Documents/calc/Formula.g:159:2: ( FUNCTIONSTATEMENT IDENT '(' ( IDENT ( EQUALS defaultValue | ( ',' IDENT )* ) ( ',' IDENT EQUALS defaultValue )* )? ')' ( NEWLINE )+ innerBlock ENDBLOCK FUNCTIONSTATEMENT -> ^( FUNCTION ^( PARAMS ( IDENT )* ) ^( DEFAULTS ( defaultValue )* ) innerBlock ) )
            // /Library/WebServer/Documents/calc/Formula.g:159:4: FUNCTIONSTATEMENT IDENT '(' ( IDENT ( EQUALS defaultValue | ( ',' IDENT )* ) ( ',' IDENT EQUALS defaultValue )* )? ')' ( NEWLINE )+ innerBlock ENDBLOCK FUNCTIONSTATEMENT
            FUNCTIONSTATEMENT62=this.match(this.input,FUNCTIONSTATEMENT,FormulaParser.FOLLOW_FUNCTIONSTATEMENT_in_functionDef820); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_FUNCTIONSTATEMENT.add(FUNCTIONSTATEMENT62);

            IDENT63=this.match(this.input,IDENT,FormulaParser.FOLLOW_IDENT_in_functionDef822); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_IDENT.add(IDENT63);

            char_literal64=this.match(this.input,113,FormulaParser.FOLLOW_113_in_functionDef824); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_113.add(char_literal64);

            // /Library/WebServer/Documents/calc/Formula.g:159:32: ( IDENT ( EQUALS defaultValue | ( ',' IDENT )* ) ( ',' IDENT EQUALS defaultValue )* )?
            var alt20=2;
            var LA20_0 = this.input.LA(1);

            if ( (LA20_0==IDENT) ) {
                alt20=1;
            }
            switch (alt20) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:159:33: IDENT ( EQUALS defaultValue | ( ',' IDENT )* ) ( ',' IDENT EQUALS defaultValue )*
                    IDENT65=this.match(this.input,IDENT,FormulaParser.FOLLOW_IDENT_in_functionDef827); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_IDENT.add(IDENT65);

                    // /Library/WebServer/Documents/calc/Formula.g:159:40: ( EQUALS defaultValue | ( ',' IDENT )* )
                    var alt18=2;
                    var LA18_0 = this.input.LA(1);

                    if ( (LA18_0==EQUALS) ) {
                        alt18=1;
                    }
                    else if ( (LA18_0==COMMA||LA18_0==114) ) {
                        alt18=2;
                    }
                    else {
                        if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        var nvae =
                            new org.antlr.runtime.NoViableAltException("", 18, 0, this.input);

                        throw nvae;
                    }
                    switch (alt18) {
                        case 1 :
                            // /Library/WebServer/Documents/calc/Formula.g:159:41: EQUALS defaultValue
                            EQUALS66=this.match(this.input,EQUALS,FormulaParser.FOLLOW_EQUALS_in_functionDef831); if (this.state.failed) return retval; 
                            if ( this.state.backtracking===0 ) stream_EQUALS.add(EQUALS66);

                            this.pushFollow(FormulaParser.FOLLOW_defaultValue_in_functionDef834);
                            defaultValue67=this.defaultValue();

                            this.state._fsp--;
                            if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) stream_defaultValue.add(defaultValue67.getTree());


                            break;
                        case 2 :
                            // /Library/WebServer/Documents/calc/Formula.g:159:64: ( ',' IDENT )*
                            // /Library/WebServer/Documents/calc/Formula.g:159:64: ( ',' IDENT )*
                            loop17:
                            do {
                                var alt17=2;
                                var LA17_0 = this.input.LA(1);

                                if ( (LA17_0==COMMA) ) {
                                    var LA17_1 = this.input.LA(2);

                                    if ( (LA17_1==IDENT) ) {
                                        var LA17_3 = this.input.LA(3);

                                        if ( (LA17_3==COMMA||LA17_3==114) ) {
                                            alt17=1;
                                        }


                                    }


                                }


                                switch (alt17) {
                                case 1 :
                                    // /Library/WebServer/Documents/calc/Formula.g:159:65: ',' IDENT
                                    char_literal68=this.match(this.input,COMMA,FormulaParser.FOLLOW_COMMA_in_functionDef839); if (this.state.failed) return retval; 
                                    if ( this.state.backtracking===0 ) stream_COMMA.add(char_literal68);

                                    IDENT69=this.match(this.input,IDENT,FormulaParser.FOLLOW_IDENT_in_functionDef841); if (this.state.failed) return retval; 
                                    if ( this.state.backtracking===0 ) stream_IDENT.add(IDENT69);



                                    break;

                                default :
                                    break loop17;
                                }
                            } while (true);



                            break;

                    }

                    // /Library/WebServer/Documents/calc/Formula.g:159:79: ( ',' IDENT EQUALS defaultValue )*
                    loop19:
                    do {
                        var alt19=2;
                        var LA19_0 = this.input.LA(1);

                        if ( (LA19_0==COMMA) ) {
                            alt19=1;
                        }


                        switch (alt19) {
                        case 1 :
                            // /Library/WebServer/Documents/calc/Formula.g:159:80: ',' IDENT EQUALS defaultValue
                            char_literal70=this.match(this.input,COMMA,FormulaParser.FOLLOW_COMMA_in_functionDef848); if (this.state.failed) return retval; 
                            if ( this.state.backtracking===0 ) stream_COMMA.add(char_literal70);

                            IDENT71=this.match(this.input,IDENT,FormulaParser.FOLLOW_IDENT_in_functionDef850); if (this.state.failed) return retval; 
                            if ( this.state.backtracking===0 ) stream_IDENT.add(IDENT71);

                            EQUALS72=this.match(this.input,EQUALS,FormulaParser.FOLLOW_EQUALS_in_functionDef852); if (this.state.failed) return retval; 
                            if ( this.state.backtracking===0 ) stream_EQUALS.add(EQUALS72);

                            this.pushFollow(FormulaParser.FOLLOW_defaultValue_in_functionDef854);
                            defaultValue73=this.defaultValue();

                            this.state._fsp--;
                            if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) stream_defaultValue.add(defaultValue73.getTree());


                            break;

                        default :
                            break loop19;
                        }
                    } while (true);



                    break;

            }

            char_literal74=this.match(this.input,114,FormulaParser.FOLLOW_114_in_functionDef861); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_114.add(char_literal74);

            // /Library/WebServer/Documents/calc/Formula.g:159:119: ( NEWLINE )+
            var cnt21=0;
            loop21:
            do {
                var alt21=2;
                var LA21_0 = this.input.LA(1);

                if ( (LA21_0==NEWLINE) ) {
                    alt21=1;
                }


                switch (alt21) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:0:0: NEWLINE
                    NEWLINE75=this.match(this.input,NEWLINE,FormulaParser.FOLLOW_NEWLINE_in_functionDef863); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_NEWLINE.add(NEWLINE75);



                    break;

                default :
                    if ( cnt21 >= 1 ) {
                        break loop21;
                    }
                    if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        var eee = new org.antlr.runtime.EarlyExitException(21, this.input);
                        throw eee;
                }
                cnt21++;
            } while (true);

            this.pushFollow(FormulaParser.FOLLOW_innerBlock_in_functionDef866);
            innerBlock76=this.innerBlock();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) stream_innerBlock.add(innerBlock76.getTree());
            ENDBLOCK77=this.match(this.input,ENDBLOCK,FormulaParser.FOLLOW_ENDBLOCK_in_functionDef869); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_ENDBLOCK.add(ENDBLOCK77);

            FUNCTIONSTATEMENT78=this.match(this.input,FUNCTIONSTATEMENT,FormulaParser.FOLLOW_FUNCTIONSTATEMENT_in_functionDef871); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_FUNCTIONSTATEMENT.add(FUNCTIONSTATEMENT78);



            // AST REWRITE
            // elements: innerBlock, defaultValue, IDENT
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            if ( this.state.backtracking===0 ) {
            retval.tree = root_0;
            var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

            root_0 = this.adaptor.nil();
            // 159:167: -> ^( FUNCTION ^( PARAMS ( IDENT )* ) ^( DEFAULTS ( defaultValue )* ) innerBlock )
            {
                // /Library/WebServer/Documents/calc/Formula.g:159:170: ^( FUNCTION ^( PARAMS ( IDENT )* ) ^( DEFAULTS ( defaultValue )* ) innerBlock )
                {
                var root_1 = this.adaptor.nil();
                root_1 = this.adaptor.becomeRoot(this.adaptor.create(FUNCTION, "FUNCTION"), root_1);

                // /Library/WebServer/Documents/calc/Formula.g:159:181: ^( PARAMS ( IDENT )* )
                {
                var root_2 = this.adaptor.nil();
                root_2 = this.adaptor.becomeRoot(this.adaptor.create(PARAMS, "PARAMS"), root_2);

                // /Library/WebServer/Documents/calc/Formula.g:159:190: ( IDENT )*
                while ( stream_IDENT.hasNext() ) {
                    this.adaptor.addChild(root_2, stream_IDENT.nextNode());

                }
                stream_IDENT.reset();

                this.adaptor.addChild(root_1, root_2);
                }
                // /Library/WebServer/Documents/calc/Formula.g:159:198: ^( DEFAULTS ( defaultValue )* )
                {
                var root_2 = this.adaptor.nil();
                root_2 = this.adaptor.becomeRoot(this.adaptor.create(DEFAULTS, "DEFAULTS"), root_2);

                // /Library/WebServer/Documents/calc/Formula.g:159:209: ( defaultValue )*
                while ( stream_defaultValue.hasNext() ) {
                    this.adaptor.addChild(root_2, stream_defaultValue.nextTree());

                }
                stream_defaultValue.reset();

                this.adaptor.addChild(root_1, root_2);
                }
                this.adaptor.addChild(root_1, stream_innerBlock.nextTree());

                this.adaptor.addChild(root_0, root_1);
                }

            }

            retval.tree = root_0;}


            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    tryCatch_return: (function() {
        FormulaParser.tryCatch_return = function(){};
        org.antlr.lang.extend(FormulaParser.tryCatch_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // /Library/WebServer/Documents/calc/Formula.g:162:1: tryCatch : TRYSTATEMENT ( NEWLINE )+ innerBlock CATCHSTATEMENT IDENT ( NEWLINE )+ innerBlock ENDBLOCK TRYSTATEMENT -> ^( TRYCATCH ( innerBlock )* IDENT ) ;
    // $ANTLR start "tryCatch"
    tryCatch: function() {
        var retval = new FormulaParser.tryCatch_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var TRYSTATEMENT79 = null;
        var NEWLINE80 = null;
        var CATCHSTATEMENT82 = null;
        var IDENT83 = null;
        var NEWLINE84 = null;
        var ENDBLOCK86 = null;
        var TRYSTATEMENT87 = null;
         var innerBlock81 = null;
         var innerBlock85 = null;

        var TRYSTATEMENT79_tree=null;
        var NEWLINE80_tree=null;
        var CATCHSTATEMENT82_tree=null;
        var IDENT83_tree=null;
        var NEWLINE84_tree=null;
        var ENDBLOCK86_tree=null;
        var TRYSTATEMENT87_tree=null;
        var stream_IDENT=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token IDENT");
        var stream_TRYSTATEMENT=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token TRYSTATEMENT");
        var stream_NEWLINE=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token NEWLINE");
        var stream_CATCHSTATEMENT=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token CATCHSTATEMENT");
        var stream_ENDBLOCK=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token ENDBLOCK");
        var stream_innerBlock=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule innerBlock");
        try {
            // /Library/WebServer/Documents/calc/Formula.g:163:2: ( TRYSTATEMENT ( NEWLINE )+ innerBlock CATCHSTATEMENT IDENT ( NEWLINE )+ innerBlock ENDBLOCK TRYSTATEMENT -> ^( TRYCATCH ( innerBlock )* IDENT ) )
            // /Library/WebServer/Documents/calc/Formula.g:163:4: TRYSTATEMENT ( NEWLINE )+ innerBlock CATCHSTATEMENT IDENT ( NEWLINE )+ innerBlock ENDBLOCK TRYSTATEMENT
            TRYSTATEMENT79=this.match(this.input,TRYSTATEMENT,FormulaParser.FOLLOW_TRYSTATEMENT_in_tryCatch904); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_TRYSTATEMENT.add(TRYSTATEMENT79);

            // /Library/WebServer/Documents/calc/Formula.g:163:17: ( NEWLINE )+
            var cnt22=0;
            loop22:
            do {
                var alt22=2;
                var LA22_0 = this.input.LA(1);

                if ( (LA22_0==NEWLINE) ) {
                    alt22=1;
                }


                switch (alt22) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:0:0: NEWLINE
                    NEWLINE80=this.match(this.input,NEWLINE,FormulaParser.FOLLOW_NEWLINE_in_tryCatch906); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_NEWLINE.add(NEWLINE80);



                    break;

                default :
                    if ( cnt22 >= 1 ) {
                        break loop22;
                    }
                    if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        var eee = new org.antlr.runtime.EarlyExitException(22, this.input);
                        throw eee;
                }
                cnt22++;
            } while (true);

            this.pushFollow(FormulaParser.FOLLOW_innerBlock_in_tryCatch909);
            innerBlock81=this.innerBlock();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) stream_innerBlock.add(innerBlock81.getTree());
            CATCHSTATEMENT82=this.match(this.input,CATCHSTATEMENT,FormulaParser.FOLLOW_CATCHSTATEMENT_in_tryCatch911); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_CATCHSTATEMENT.add(CATCHSTATEMENT82);

            IDENT83=this.match(this.input,IDENT,FormulaParser.FOLLOW_IDENT_in_tryCatch913); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_IDENT.add(IDENT83);

            // /Library/WebServer/Documents/calc/Formula.g:163:58: ( NEWLINE )+
            var cnt23=0;
            loop23:
            do {
                var alt23=2;
                var LA23_0 = this.input.LA(1);

                if ( (LA23_0==NEWLINE) ) {
                    alt23=1;
                }


                switch (alt23) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:0:0: NEWLINE
                    NEWLINE84=this.match(this.input,NEWLINE,FormulaParser.FOLLOW_NEWLINE_in_tryCatch915); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_NEWLINE.add(NEWLINE84);



                    break;

                default :
                    if ( cnt23 >= 1 ) {
                        break loop23;
                    }
                    if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        var eee = new org.antlr.runtime.EarlyExitException(23, this.input);
                        throw eee;
                }
                cnt23++;
            } while (true);

            this.pushFollow(FormulaParser.FOLLOW_innerBlock_in_tryCatch919);
            innerBlock85=this.innerBlock();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) stream_innerBlock.add(innerBlock85.getTree());
            ENDBLOCK86=this.match(this.input,ENDBLOCK,FormulaParser.FOLLOW_ENDBLOCK_in_tryCatch921); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_ENDBLOCK.add(ENDBLOCK86);

            TRYSTATEMENT87=this.match(this.input,TRYSTATEMENT,FormulaParser.FOLLOW_TRYSTATEMENT_in_tryCatch923); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_TRYSTATEMENT.add(TRYSTATEMENT87);



            // AST REWRITE
            // elements: IDENT, innerBlock
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            if ( this.state.backtracking===0 ) {
            retval.tree = root_0;
            var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

            root_0 = this.adaptor.nil();
            // 163:101: -> ^( TRYCATCH ( innerBlock )* IDENT )
            {
                // /Library/WebServer/Documents/calc/Formula.g:163:104: ^( TRYCATCH ( innerBlock )* IDENT )
                {
                var root_1 = this.adaptor.nil();
                root_1 = this.adaptor.becomeRoot(this.adaptor.create(TRYCATCH, "TRYCATCH"), root_1);

                // /Library/WebServer/Documents/calc/Formula.g:163:115: ( innerBlock )*
                while ( stream_innerBlock.hasNext() ) {
                    this.adaptor.addChild(root_1, stream_innerBlock.nextTree());

                }
                stream_innerBlock.reset();
                this.adaptor.addChild(root_1, stream_IDENT.nextNode());

                this.adaptor.addChild(root_0, root_1);
                }

            }

            retval.tree = root_0;}


            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    throwExp_return: (function() {
        FormulaParser.throwExp_return = function(){};
        org.antlr.lang.extend(FormulaParser.throwExp_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // /Library/WebServer/Documents/calc/Formula.g:166:1: throwExp : THROWSTATEMENT primaryExpression -> ^( THROW primaryExpression ) ;
    // $ANTLR start "throwExp"
    throwExp: function() {
        var retval = new FormulaParser.throwExp_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var THROWSTATEMENT88 = null;
         var primaryExpression89 = null;

        var THROWSTATEMENT88_tree=null;
        var stream_THROWSTATEMENT=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token THROWSTATEMENT");
        var stream_primaryExpression=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule primaryExpression");
        try {
            // /Library/WebServer/Documents/calc/Formula.g:167:2: ( THROWSTATEMENT primaryExpression -> ^( THROW primaryExpression ) )
            // /Library/WebServer/Documents/calc/Formula.g:167:4: THROWSTATEMENT primaryExpression
            THROWSTATEMENT88=this.match(this.input,THROWSTATEMENT,FormulaParser.FOLLOW_THROWSTATEMENT_in_throwExp945); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_THROWSTATEMENT.add(THROWSTATEMENT88);

            this.pushFollow(FormulaParser.FOLLOW_primaryExpression_in_throwExp947);
            primaryExpression89=this.primaryExpression();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) stream_primaryExpression.add(primaryExpression89.getTree());


            // AST REWRITE
            // elements: primaryExpression
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            if ( this.state.backtracking===0 ) {
            retval.tree = root_0;
            var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

            root_0 = this.adaptor.nil();
            // 167:37: -> ^( THROW primaryExpression )
            {
                // /Library/WebServer/Documents/calc/Formula.g:167:40: ^( THROW primaryExpression )
                {
                var root_1 = this.adaptor.nil();
                root_1 = this.adaptor.becomeRoot(this.adaptor.create(THROW, "THROW"), root_1);

                this.adaptor.addChild(root_1, stream_primaryExpression.nextTree());

                this.adaptor.addChild(root_0, root_1);
                }

            }

            retval.tree = root_0;}


            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    anonFunctionDef_return: (function() {
        FormulaParser.anonFunctionDef_return = function(){};
        org.antlr.lang.extend(FormulaParser.anonFunctionDef_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // /Library/WebServer/Documents/calc/Formula.g:170:1: anonFunctionDef : FUNCTIONSTATEMENT '(' ( IDENT ( EQUALS defaultValue | ( ',' IDENT )* ) ( ',' IDENT EQUALS defaultValue )* )? ')' ( ( ( NEWLINE )+ innerBlock ENDBLOCK FUNCTIONSTATEMENT ) | expression ) -> ^( ANONFUNCTION ^( PARAMS ( IDENT )* ) ^( DEFAULTS ( defaultValue )* ) ( innerBlock )? ( expression )? ) ;
    // $ANTLR start "anonFunctionDef"
    anonFunctionDef: function() {
        var retval = new FormulaParser.anonFunctionDef_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var FUNCTIONSTATEMENT90 = null;
        var char_literal91 = null;
        var IDENT92 = null;
        var EQUALS93 = null;
        var char_literal95 = null;
        var IDENT96 = null;
        var char_literal97 = null;
        var IDENT98 = null;
        var EQUALS99 = null;
        var char_literal101 = null;
        var NEWLINE102 = null;
        var ENDBLOCK104 = null;
        var FUNCTIONSTATEMENT105 = null;
         var defaultValue94 = null;
         var defaultValue100 = null;
         var innerBlock103 = null;
         var expression106 = null;

        var FUNCTIONSTATEMENT90_tree=null;
        var char_literal91_tree=null;
        var IDENT92_tree=null;
        var EQUALS93_tree=null;
        var char_literal95_tree=null;
        var IDENT96_tree=null;
        var char_literal97_tree=null;
        var IDENT98_tree=null;
        var EQUALS99_tree=null;
        var char_literal101_tree=null;
        var NEWLINE102_tree=null;
        var ENDBLOCK104_tree=null;
        var FUNCTIONSTATEMENT105_tree=null;
        var stream_FUNCTIONSTATEMENT=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token FUNCTIONSTATEMENT");
        var stream_114=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token 114");
        var stream_IDENT=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token IDENT");
        var stream_EQUALS=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token EQUALS");
        var stream_113=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token 113");
        var stream_NEWLINE=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token NEWLINE");
        var stream_COMMA=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token COMMA");
        var stream_ENDBLOCK=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token ENDBLOCK");
        var stream_expression=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule expression");
        var stream_innerBlock=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule innerBlock");
        var stream_defaultValue=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule defaultValue");
        try {
            // /Library/WebServer/Documents/calc/Formula.g:171:2: ( FUNCTIONSTATEMENT '(' ( IDENT ( EQUALS defaultValue | ( ',' IDENT )* ) ( ',' IDENT EQUALS defaultValue )* )? ')' ( ( ( NEWLINE )+ innerBlock ENDBLOCK FUNCTIONSTATEMENT ) | expression ) -> ^( ANONFUNCTION ^( PARAMS ( IDENT )* ) ^( DEFAULTS ( defaultValue )* ) ( innerBlock )? ( expression )? ) )
            // /Library/WebServer/Documents/calc/Formula.g:171:4: FUNCTIONSTATEMENT '(' ( IDENT ( EQUALS defaultValue | ( ',' IDENT )* ) ( ',' IDENT EQUALS defaultValue )* )? ')' ( ( ( NEWLINE )+ innerBlock ENDBLOCK FUNCTIONSTATEMENT ) | expression )
            FUNCTIONSTATEMENT90=this.match(this.input,FUNCTIONSTATEMENT,FormulaParser.FOLLOW_FUNCTIONSTATEMENT_in_anonFunctionDef967); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_FUNCTIONSTATEMENT.add(FUNCTIONSTATEMENT90);

            char_literal91=this.match(this.input,113,FormulaParser.FOLLOW_113_in_anonFunctionDef970); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_113.add(char_literal91);

            // /Library/WebServer/Documents/calc/Formula.g:171:27: ( IDENT ( EQUALS defaultValue | ( ',' IDENT )* ) ( ',' IDENT EQUALS defaultValue )* )?
            var alt27=2;
            var LA27_0 = this.input.LA(1);

            if ( (LA27_0==IDENT) ) {
                alt27=1;
            }
            switch (alt27) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:171:28: IDENT ( EQUALS defaultValue | ( ',' IDENT )* ) ( ',' IDENT EQUALS defaultValue )*
                    IDENT92=this.match(this.input,IDENT,FormulaParser.FOLLOW_IDENT_in_anonFunctionDef973); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_IDENT.add(IDENT92);

                    // /Library/WebServer/Documents/calc/Formula.g:171:35: ( EQUALS defaultValue | ( ',' IDENT )* )
                    var alt25=2;
                    var LA25_0 = this.input.LA(1);

                    if ( (LA25_0==EQUALS) ) {
                        alt25=1;
                    }
                    else if ( (LA25_0==COMMA||LA25_0==114) ) {
                        alt25=2;
                    }
                    else {
                        if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        var nvae =
                            new org.antlr.runtime.NoViableAltException("", 25, 0, this.input);

                        throw nvae;
                    }
                    switch (alt25) {
                        case 1 :
                            // /Library/WebServer/Documents/calc/Formula.g:171:36: EQUALS defaultValue
                            EQUALS93=this.match(this.input,EQUALS,FormulaParser.FOLLOW_EQUALS_in_anonFunctionDef977); if (this.state.failed) return retval; 
                            if ( this.state.backtracking===0 ) stream_EQUALS.add(EQUALS93);

                            this.pushFollow(FormulaParser.FOLLOW_defaultValue_in_anonFunctionDef980);
                            defaultValue94=this.defaultValue();

                            this.state._fsp--;
                            if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) stream_defaultValue.add(defaultValue94.getTree());


                            break;
                        case 2 :
                            // /Library/WebServer/Documents/calc/Formula.g:171:59: ( ',' IDENT )*
                            // /Library/WebServer/Documents/calc/Formula.g:171:59: ( ',' IDENT )*
                            loop24:
                            do {
                                var alt24=2;
                                var LA24_0 = this.input.LA(1);

                                if ( (LA24_0==COMMA) ) {
                                    var LA24_1 = this.input.LA(2);

                                    if ( (LA24_1==IDENT) ) {
                                        var LA24_3 = this.input.LA(3);

                                        if ( (LA24_3==COMMA||LA24_3==114) ) {
                                            alt24=1;
                                        }


                                    }


                                }


                                switch (alt24) {
                                case 1 :
                                    // /Library/WebServer/Documents/calc/Formula.g:171:60: ',' IDENT
                                    char_literal95=this.match(this.input,COMMA,FormulaParser.FOLLOW_COMMA_in_anonFunctionDef985); if (this.state.failed) return retval; 
                                    if ( this.state.backtracking===0 ) stream_COMMA.add(char_literal95);

                                    IDENT96=this.match(this.input,IDENT,FormulaParser.FOLLOW_IDENT_in_anonFunctionDef987); if (this.state.failed) return retval; 
                                    if ( this.state.backtracking===0 ) stream_IDENT.add(IDENT96);



                                    break;

                                default :
                                    break loop24;
                                }
                            } while (true);



                            break;

                    }

                    // /Library/WebServer/Documents/calc/Formula.g:171:74: ( ',' IDENT EQUALS defaultValue )*
                    loop26:
                    do {
                        var alt26=2;
                        var LA26_0 = this.input.LA(1);

                        if ( (LA26_0==COMMA) ) {
                            alt26=1;
                        }


                        switch (alt26) {
                        case 1 :
                            // /Library/WebServer/Documents/calc/Formula.g:171:75: ',' IDENT EQUALS defaultValue
                            char_literal97=this.match(this.input,COMMA,FormulaParser.FOLLOW_COMMA_in_anonFunctionDef994); if (this.state.failed) return retval; 
                            if ( this.state.backtracking===0 ) stream_COMMA.add(char_literal97);

                            IDENT98=this.match(this.input,IDENT,FormulaParser.FOLLOW_IDENT_in_anonFunctionDef996); if (this.state.failed) return retval; 
                            if ( this.state.backtracking===0 ) stream_IDENT.add(IDENT98);

                            EQUALS99=this.match(this.input,EQUALS,FormulaParser.FOLLOW_EQUALS_in_anonFunctionDef998); if (this.state.failed) return retval; 
                            if ( this.state.backtracking===0 ) stream_EQUALS.add(EQUALS99);

                            this.pushFollow(FormulaParser.FOLLOW_defaultValue_in_anonFunctionDef1000);
                            defaultValue100=this.defaultValue();

                            this.state._fsp--;
                            if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) stream_defaultValue.add(defaultValue100.getTree());


                            break;

                        default :
                            break loop26;
                        }
                    } while (true);



                    break;

            }

            char_literal101=this.match(this.input,114,FormulaParser.FOLLOW_114_in_anonFunctionDef1007); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_114.add(char_literal101);

            // /Library/WebServer/Documents/calc/Formula.g:171:114: ( ( ( NEWLINE )+ innerBlock ENDBLOCK FUNCTIONSTATEMENT ) | expression )
            var alt29=2;
            var LA29_0 = this.input.LA(1);

            if ( (LA29_0==NEWLINE) ) {
                alt29=1;
            }
            else if ( (LA29_0==WHILESTATEMENT||LA29_0==FORSTATEMENT||LA29_0==IFSTATEMENT||LA29_0==FUNCTIONSTATEMENT||(LA29_0>=RETURNSTATEMENT && LA29_0<=TRYSTATEMENT)||(LA29_0>=THROWSTATEMENT && LA29_0<=IDENT)||LA29_0==PRIMITIVE||LA29_0==MINUS||(LA29_0>=NOT && LA29_0<=LARR)||LA29_0==LCURL||(LA29_0>=STRING && LA29_0<=FALSE)||LA29_0==113) ) {
                alt29=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 29, 0, this.input);

                throw nvae;
            }
            switch (alt29) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:171:116: ( ( NEWLINE )+ innerBlock ENDBLOCK FUNCTIONSTATEMENT )
                    // /Library/WebServer/Documents/calc/Formula.g:171:116: ( ( NEWLINE )+ innerBlock ENDBLOCK FUNCTIONSTATEMENT )
                    // /Library/WebServer/Documents/calc/Formula.g:171:117: ( NEWLINE )+ innerBlock ENDBLOCK FUNCTIONSTATEMENT
                    // /Library/WebServer/Documents/calc/Formula.g:171:117: ( NEWLINE )+
                    var cnt28=0;
                    loop28:
                    do {
                        var alt28=2;
                        var LA28_0 = this.input.LA(1);

                        if ( (LA28_0==NEWLINE) ) {
                            alt28=1;
                        }


                        switch (alt28) {
                        case 1 :
                            // /Library/WebServer/Documents/calc/Formula.g:0:0: NEWLINE
                            NEWLINE102=this.match(this.input,NEWLINE,FormulaParser.FOLLOW_NEWLINE_in_anonFunctionDef1012); if (this.state.failed) return retval; 
                            if ( this.state.backtracking===0 ) stream_NEWLINE.add(NEWLINE102);



                            break;

                        default :
                            if ( cnt28 >= 1 ) {
                                break loop28;
                            }
                            if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                                var eee = new org.antlr.runtime.EarlyExitException(28, this.input);
                                throw eee;
                        }
                        cnt28++;
                    } while (true);

                    this.pushFollow(FormulaParser.FOLLOW_innerBlock_in_anonFunctionDef1015);
                    innerBlock103=this.innerBlock();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) stream_innerBlock.add(innerBlock103.getTree());
                    ENDBLOCK104=this.match(this.input,ENDBLOCK,FormulaParser.FOLLOW_ENDBLOCK_in_anonFunctionDef1018); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_ENDBLOCK.add(ENDBLOCK104);

                    FUNCTIONSTATEMENT105=this.match(this.input,FUNCTIONSTATEMENT,FormulaParser.FOLLOW_FUNCTIONSTATEMENT_in_anonFunctionDef1020); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_FUNCTIONSTATEMENT.add(FUNCTIONSTATEMENT105);






                    break;
                case 2 :
                    // /Library/WebServer/Documents/calc/Formula.g:171:168: expression
                    this.pushFollow(FormulaParser.FOLLOW_expression_in_anonFunctionDef1025);
                    expression106=this.expression();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) stream_expression.add(expression106.getTree());


                    break;

            }



            // AST REWRITE
            // elements: defaultValue, innerBlock, IDENT, expression
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            if ( this.state.backtracking===0 ) {
            retval.tree = root_0;
            var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

            root_0 = this.adaptor.nil();
            // 171:180: -> ^( ANONFUNCTION ^( PARAMS ( IDENT )* ) ^( DEFAULTS ( defaultValue )* ) ( innerBlock )? ( expression )? )
            {
                // /Library/WebServer/Documents/calc/Formula.g:171:183: ^( ANONFUNCTION ^( PARAMS ( IDENT )* ) ^( DEFAULTS ( defaultValue )* ) ( innerBlock )? ( expression )? )
                {
                var root_1 = this.adaptor.nil();
                root_1 = this.adaptor.becomeRoot(this.adaptor.create(ANONFUNCTION, "ANONFUNCTION"), root_1);

                // /Library/WebServer/Documents/calc/Formula.g:171:198: ^( PARAMS ( IDENT )* )
                {
                var root_2 = this.adaptor.nil();
                root_2 = this.adaptor.becomeRoot(this.adaptor.create(PARAMS, "PARAMS"), root_2);

                // /Library/WebServer/Documents/calc/Formula.g:171:207: ( IDENT )*
                while ( stream_IDENT.hasNext() ) {
                    this.adaptor.addChild(root_2, stream_IDENT.nextNode());

                }
                stream_IDENT.reset();

                this.adaptor.addChild(root_1, root_2);
                }
                // /Library/WebServer/Documents/calc/Formula.g:171:215: ^( DEFAULTS ( defaultValue )* )
                {
                var root_2 = this.adaptor.nil();
                root_2 = this.adaptor.becomeRoot(this.adaptor.create(DEFAULTS, "DEFAULTS"), root_2);

                // /Library/WebServer/Documents/calc/Formula.g:171:226: ( defaultValue )*
                while ( stream_defaultValue.hasNext() ) {
                    this.adaptor.addChild(root_2, stream_defaultValue.nextTree());

                }
                stream_defaultValue.reset();

                this.adaptor.addChild(root_1, root_2);
                }
                // /Library/WebServer/Documents/calc/Formula.g:171:241: ( innerBlock )?
                if ( stream_innerBlock.hasNext() ) {
                    this.adaptor.addChild(root_1, stream_innerBlock.nextTree());

                }
                stream_innerBlock.reset();
                // /Library/WebServer/Documents/calc/Formula.g:171:253: ( expression )?
                if ( stream_expression.hasNext() ) {
                    this.adaptor.addChild(root_1, stream_expression.nextTree());

                }
                stream_expression.reset();

                this.adaptor.addChild(root_0, root_1);
                }

            }

            retval.tree = root_0;}


            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    assignment_return: (function() {
        FormulaParser.assignment_return = function(){};
        org.antlr.lang.extend(FormulaParser.assignment_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // /Library/WebServer/Documents/calc/Formula.g:175:1: assignment : ( IDENT '(' ( IDENT ( EQUALS defaultValue | ( ',' IDENT )* ) ( ',' IDENT EQUALS defaultValue )* )? ')' '<-' logicalExpression -> ^( FUNCTION ^( PARAMS ( IDENT )* ) ^( DEFAULTS ( defaultValue )* ) logicalExpression ) | ( PRIMITIVE | assigned ) ( ',' ( PRIMITIVE | assigned ) )* '<-' logicalExpression -> ^( ASSIGN ( PRIMITIVE )* ( assigned )* logicalExpression ) );
    // $ANTLR start "assignment"
    assignment: function() {
        var retval = new FormulaParser.assignment_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var IDENT107 = null;
        var char_literal108 = null;
        var IDENT109 = null;
        var EQUALS110 = null;
        var char_literal112 = null;
        var IDENT113 = null;
        var char_literal114 = null;
        var IDENT115 = null;
        var EQUALS116 = null;
        var char_literal118 = null;
        var string_literal119 = null;
        var PRIMITIVE121 = null;
        var char_literal123 = null;
        var PRIMITIVE124 = null;
        var string_literal126 = null;
         var defaultValue111 = null;
         var defaultValue117 = null;
         var logicalExpression120 = null;
         var assigned122 = null;
         var assigned125 = null;
         var logicalExpression127 = null;

        var IDENT107_tree=null;
        var char_literal108_tree=null;
        var IDENT109_tree=null;
        var EQUALS110_tree=null;
        var char_literal112_tree=null;
        var IDENT113_tree=null;
        var char_literal114_tree=null;
        var IDENT115_tree=null;
        var EQUALS116_tree=null;
        var char_literal118_tree=null;
        var string_literal119_tree=null;
        var PRIMITIVE121_tree=null;
        var char_literal123_tree=null;
        var PRIMITIVE124_tree=null;
        var string_literal126_tree=null;
        var stream_114=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token 114");
        var stream_IDENT=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token IDENT");
        var stream_115=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token 115");
        var stream_EQUALS=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token EQUALS");
        var stream_113=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token 113");
        var stream_COMMA=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token COMMA");
        var stream_PRIMITIVE=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token PRIMITIVE");
        var stream_assigned=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule assigned");
        var stream_defaultValue=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule defaultValue");
        var stream_logicalExpression=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule logicalExpression");
        try {
            // /Library/WebServer/Documents/calc/Formula.g:176:2: ( IDENT '(' ( IDENT ( EQUALS defaultValue | ( ',' IDENT )* ) ( ',' IDENT EQUALS defaultValue )* )? ')' '<-' logicalExpression -> ^( FUNCTION ^( PARAMS ( IDENT )* ) ^( DEFAULTS ( defaultValue )* ) logicalExpression ) | ( PRIMITIVE | assigned ) ( ',' ( PRIMITIVE | assigned ) )* '<-' logicalExpression -> ^( ASSIGN ( PRIMITIVE )* ( assigned )* logicalExpression ) )
            var alt37=2;
            var LA37_0 = this.input.LA(1);

            if ( (LA37_0==IDENT) ) {
                var LA37_1 = this.input.LA(2);

                if ( (LA37_1==113) ) {
                    alt37=1;
                }
                else if ( (LA37_1==LARR||LA37_1==LCURL||LA37_1==COMMA||(LA37_1>=115 && LA37_1<=116)) ) {
                    alt37=2;
                }
                else {
                    if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                    var nvae =
                        new org.antlr.runtime.NoViableAltException("", 37, 1, this.input);

                    throw nvae;
                }
            }
            else if ( (LA37_0==PRIMITIVE) ) {
                alt37=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 37, 0, this.input);

                throw nvae;
            }
            switch (alt37) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:177:2: IDENT '(' ( IDENT ( EQUALS defaultValue | ( ',' IDENT )* ) ( ',' IDENT EQUALS defaultValue )* )? ')' '<-' logicalExpression
                    IDENT107=this.match(this.input,IDENT,FormulaParser.FOLLOW_IDENT_in_assignment1067); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_IDENT.add(IDENT107);

                    char_literal108=this.match(this.input,113,FormulaParser.FOLLOW_113_in_assignment1069); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_113.add(char_literal108);

                    // /Library/WebServer/Documents/calc/Formula.g:177:12: ( IDENT ( EQUALS defaultValue | ( ',' IDENT )* ) ( ',' IDENT EQUALS defaultValue )* )?
                    var alt33=2;
                    var LA33_0 = this.input.LA(1);

                    if ( (LA33_0==IDENT) ) {
                        alt33=1;
                    }
                    switch (alt33) {
                        case 1 :
                            // /Library/WebServer/Documents/calc/Formula.g:177:13: IDENT ( EQUALS defaultValue | ( ',' IDENT )* ) ( ',' IDENT EQUALS defaultValue )*
                            IDENT109=this.match(this.input,IDENT,FormulaParser.FOLLOW_IDENT_in_assignment1072); if (this.state.failed) return retval; 
                            if ( this.state.backtracking===0 ) stream_IDENT.add(IDENT109);

                            // /Library/WebServer/Documents/calc/Formula.g:177:20: ( EQUALS defaultValue | ( ',' IDENT )* )
                            var alt31=2;
                            var LA31_0 = this.input.LA(1);

                            if ( (LA31_0==EQUALS) ) {
                                alt31=1;
                            }
                            else if ( (LA31_0==COMMA||LA31_0==114) ) {
                                alt31=2;
                            }
                            else {
                                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                                var nvae =
                                    new org.antlr.runtime.NoViableAltException("", 31, 0, this.input);

                                throw nvae;
                            }
                            switch (alt31) {
                                case 1 :
                                    // /Library/WebServer/Documents/calc/Formula.g:177:21: EQUALS defaultValue
                                    EQUALS110=this.match(this.input,EQUALS,FormulaParser.FOLLOW_EQUALS_in_assignment1076); if (this.state.failed) return retval; 
                                    if ( this.state.backtracking===0 ) stream_EQUALS.add(EQUALS110);

                                    this.pushFollow(FormulaParser.FOLLOW_defaultValue_in_assignment1078);
                                    defaultValue111=this.defaultValue();

                                    this.state._fsp--;
                                    if (this.state.failed) return retval;
                                    if ( this.state.backtracking===0 ) stream_defaultValue.add(defaultValue111.getTree());


                                    break;
                                case 2 :
                                    // /Library/WebServer/Documents/calc/Formula.g:177:43: ( ',' IDENT )*
                                    // /Library/WebServer/Documents/calc/Formula.g:177:43: ( ',' IDENT )*
                                    loop30:
                                    do {
                                        var alt30=2;
                                        var LA30_0 = this.input.LA(1);

                                        if ( (LA30_0==COMMA) ) {
                                            var LA30_1 = this.input.LA(2);

                                            if ( (LA30_1==IDENT) ) {
                                                var LA30_3 = this.input.LA(3);

                                                if ( (LA30_3==COMMA||LA30_3==114) ) {
                                                    alt30=1;
                                                }


                                            }


                                        }


                                        switch (alt30) {
                                        case 1 :
                                            // /Library/WebServer/Documents/calc/Formula.g:177:44: ',' IDENT
                                            char_literal112=this.match(this.input,COMMA,FormulaParser.FOLLOW_COMMA_in_assignment1083); if (this.state.failed) return retval; 
                                            if ( this.state.backtracking===0 ) stream_COMMA.add(char_literal112);

                                            IDENT113=this.match(this.input,IDENT,FormulaParser.FOLLOW_IDENT_in_assignment1085); if (this.state.failed) return retval; 
                                            if ( this.state.backtracking===0 ) stream_IDENT.add(IDENT113);



                                            break;

                                        default :
                                            break loop30;
                                        }
                                    } while (true);



                                    break;

                            }

                            // /Library/WebServer/Documents/calc/Formula.g:177:58: ( ',' IDENT EQUALS defaultValue )*
                            loop32:
                            do {
                                var alt32=2;
                                var LA32_0 = this.input.LA(1);

                                if ( (LA32_0==COMMA) ) {
                                    alt32=1;
                                }


                                switch (alt32) {
                                case 1 :
                                    // /Library/WebServer/Documents/calc/Formula.g:177:59: ',' IDENT EQUALS defaultValue
                                    char_literal114=this.match(this.input,COMMA,FormulaParser.FOLLOW_COMMA_in_assignment1092); if (this.state.failed) return retval; 
                                    if ( this.state.backtracking===0 ) stream_COMMA.add(char_literal114);

                                    IDENT115=this.match(this.input,IDENT,FormulaParser.FOLLOW_IDENT_in_assignment1094); if (this.state.failed) return retval; 
                                    if ( this.state.backtracking===0 ) stream_IDENT.add(IDENT115);

                                    EQUALS116=this.match(this.input,EQUALS,FormulaParser.FOLLOW_EQUALS_in_assignment1096); if (this.state.failed) return retval; 
                                    if ( this.state.backtracking===0 ) stream_EQUALS.add(EQUALS116);

                                    this.pushFollow(FormulaParser.FOLLOW_defaultValue_in_assignment1098);
                                    defaultValue117=this.defaultValue();

                                    this.state._fsp--;
                                    if (this.state.failed) return retval;
                                    if ( this.state.backtracking===0 ) stream_defaultValue.add(defaultValue117.getTree());


                                    break;

                                default :
                                    break loop32;
                                }
                            } while (true);



                            break;

                    }

                    char_literal118=this.match(this.input,114,FormulaParser.FOLLOW_114_in_assignment1105); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_114.add(char_literal118);

                    string_literal119=this.match(this.input,115,FormulaParser.FOLLOW_115_in_assignment1107); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_115.add(string_literal119);

                    this.pushFollow(FormulaParser.FOLLOW_logicalExpression_in_assignment1109);
                    logicalExpression120=this.logicalExpression();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) stream_logicalExpression.add(logicalExpression120.getTree());


                    // AST REWRITE
                    // elements: defaultValue, logicalExpression, IDENT
                    // token labels: 
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: 
                    if ( this.state.backtracking===0 ) {
                    retval.tree = root_0;
                    var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

                    root_0 = this.adaptor.nil();
                    // 177:121: -> ^( FUNCTION ^( PARAMS ( IDENT )* ) ^( DEFAULTS ( defaultValue )* ) logicalExpression )
                    {
                        // /Library/WebServer/Documents/calc/Formula.g:177:124: ^( FUNCTION ^( PARAMS ( IDENT )* ) ^( DEFAULTS ( defaultValue )* ) logicalExpression )
                        {
                        var root_1 = this.adaptor.nil();
                        root_1 = this.adaptor.becomeRoot(this.adaptor.create(FUNCTION, "FUNCTION"), root_1);

                        // /Library/WebServer/Documents/calc/Formula.g:177:135: ^( PARAMS ( IDENT )* )
                        {
                        var root_2 = this.adaptor.nil();
                        root_2 = this.adaptor.becomeRoot(this.adaptor.create(PARAMS, "PARAMS"), root_2);

                        // /Library/WebServer/Documents/calc/Formula.g:177:144: ( IDENT )*
                        while ( stream_IDENT.hasNext() ) {
                            this.adaptor.addChild(root_2, stream_IDENT.nextNode());

                        }
                        stream_IDENT.reset();

                        this.adaptor.addChild(root_1, root_2);
                        }
                        // /Library/WebServer/Documents/calc/Formula.g:177:152: ^( DEFAULTS ( defaultValue )* )
                        {
                        var root_2 = this.adaptor.nil();
                        root_2 = this.adaptor.becomeRoot(this.adaptor.create(DEFAULTS, "DEFAULTS"), root_2);

                        // /Library/WebServer/Documents/calc/Formula.g:177:163: ( defaultValue )*
                        while ( stream_defaultValue.hasNext() ) {
                            this.adaptor.addChild(root_2, stream_defaultValue.nextTree());

                        }
                        stream_defaultValue.reset();

                        this.adaptor.addChild(root_1, root_2);
                        }
                        this.adaptor.addChild(root_1, stream_logicalExpression.nextTree());

                        this.adaptor.addChild(root_0, root_1);
                        }

                    }

                    retval.tree = root_0;}

                    break;
                case 2 :
                    // /Library/WebServer/Documents/calc/Formula.g:178:2: ( PRIMITIVE | assigned ) ( ',' ( PRIMITIVE | assigned ) )* '<-' logicalExpression
                    // /Library/WebServer/Documents/calc/Formula.g:178:2: ( PRIMITIVE | assigned )
                    var alt34=2;
                    var LA34_0 = this.input.LA(1);

                    if ( (LA34_0==PRIMITIVE) ) {
                        alt34=1;
                    }
                    else if ( (LA34_0==IDENT) ) {
                        alt34=2;
                    }
                    else {
                        if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        var nvae =
                            new org.antlr.runtime.NoViableAltException("", 34, 0, this.input);

                        throw nvae;
                    }
                    switch (alt34) {
                        case 1 :
                            // /Library/WebServer/Documents/calc/Formula.g:178:3: PRIMITIVE
                            PRIMITIVE121=this.match(this.input,PRIMITIVE,FormulaParser.FOLLOW_PRIMITIVE_in_assignment1137); if (this.state.failed) return retval; 
                            if ( this.state.backtracking===0 ) stream_PRIMITIVE.add(PRIMITIVE121);



                            break;
                        case 2 :
                            // /Library/WebServer/Documents/calc/Formula.g:178:15: assigned
                            this.pushFollow(FormulaParser.FOLLOW_assigned_in_assignment1141);
                            assigned122=this.assigned();

                            this.state._fsp--;
                            if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) stream_assigned.add(assigned122.getTree());


                            break;

                    }

                    // /Library/WebServer/Documents/calc/Formula.g:178:25: ( ',' ( PRIMITIVE | assigned ) )*
                    loop36:
                    do {
                        var alt36=2;
                        var LA36_0 = this.input.LA(1);

                        if ( (LA36_0==COMMA) ) {
                            alt36=1;
                        }


                        switch (alt36) {
                        case 1 :
                            // /Library/WebServer/Documents/calc/Formula.g:178:26: ',' ( PRIMITIVE | assigned )
                            char_literal123=this.match(this.input,COMMA,FormulaParser.FOLLOW_COMMA_in_assignment1145); if (this.state.failed) return retval; 
                            if ( this.state.backtracking===0 ) stream_COMMA.add(char_literal123);

                            // /Library/WebServer/Documents/calc/Formula.g:178:30: ( PRIMITIVE | assigned )
                            var alt35=2;
                            var LA35_0 = this.input.LA(1);

                            if ( (LA35_0==PRIMITIVE) ) {
                                alt35=1;
                            }
                            else if ( (LA35_0==IDENT) ) {
                                alt35=2;
                            }
                            else {
                                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                                var nvae =
                                    new org.antlr.runtime.NoViableAltException("", 35, 0, this.input);

                                throw nvae;
                            }
                            switch (alt35) {
                                case 1 :
                                    // /Library/WebServer/Documents/calc/Formula.g:178:31: PRIMITIVE
                                    PRIMITIVE124=this.match(this.input,PRIMITIVE,FormulaParser.FOLLOW_PRIMITIVE_in_assignment1148); if (this.state.failed) return retval; 
                                    if ( this.state.backtracking===0 ) stream_PRIMITIVE.add(PRIMITIVE124);



                                    break;
                                case 2 :
                                    // /Library/WebServer/Documents/calc/Formula.g:178:43: assigned
                                    this.pushFollow(FormulaParser.FOLLOW_assigned_in_assignment1152);
                                    assigned125=this.assigned();

                                    this.state._fsp--;
                                    if (this.state.failed) return retval;
                                    if ( this.state.backtracking===0 ) stream_assigned.add(assigned125.getTree());


                                    break;

                            }



                            break;

                        default :
                            break loop36;
                        }
                    } while (true);

                    string_literal126=this.match(this.input,115,FormulaParser.FOLLOW_115_in_assignment1158); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_115.add(string_literal126);

                    this.pushFollow(FormulaParser.FOLLOW_logicalExpression_in_assignment1160);
                    logicalExpression127=this.logicalExpression();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) stream_logicalExpression.add(logicalExpression127.getTree());


                    // AST REWRITE
                    // elements: PRIMITIVE, assigned, logicalExpression
                    // token labels: 
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: 
                    if ( this.state.backtracking===0 ) {
                    retval.tree = root_0;
                    var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

                    root_0 = this.adaptor.nil();
                    // 178:79: -> ^( ASSIGN ( PRIMITIVE )* ( assigned )* logicalExpression )
                    {
                        // /Library/WebServer/Documents/calc/Formula.g:178:82: ^( ASSIGN ( PRIMITIVE )* ( assigned )* logicalExpression )
                        {
                        var root_1 = this.adaptor.nil();
                        root_1 = this.adaptor.becomeRoot(this.adaptor.create(ASSIGN, "ASSIGN"), root_1);

                        // /Library/WebServer/Documents/calc/Formula.g:178:91: ( PRIMITIVE )*
                        while ( stream_PRIMITIVE.hasNext() ) {
                            this.adaptor.addChild(root_1, stream_PRIMITIVE.nextNode());

                        }
                        stream_PRIMITIVE.reset();
                        // /Library/WebServer/Documents/calc/Formula.g:178:102: ( assigned )*
                        while ( stream_assigned.hasNext() ) {
                            this.adaptor.addChild(root_1, stream_assigned.nextTree());

                        }
                        stream_assigned.reset();
                        this.adaptor.addChild(root_1, stream_logicalExpression.nextTree());

                        this.adaptor.addChild(root_0, root_1);
                        }

                    }

                    retval.tree = root_0;}

                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    assigned_return: (function() {
        FormulaParser.assigned_return = function(){};
        org.antlr.lang.extend(FormulaParser.assigned_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // /Library/WebServer/Documents/calc/Formula.g:181:1: assigned : IDENT ( selector )? -> ^( ASSIGNED IDENT ( selector )? ) ;
    // $ANTLR start "assigned"
    assigned: function() {
        var retval = new FormulaParser.assigned_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var IDENT128 = null;
         var selector129 = null;

        var IDENT128_tree=null;
        var stream_IDENT=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token IDENT");
        var stream_selector=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule selector");
        try {
            // /Library/WebServer/Documents/calc/Formula.g:182:2: ( IDENT ( selector )? -> ^( ASSIGNED IDENT ( selector )? ) )
            // /Library/WebServer/Documents/calc/Formula.g:182:4: IDENT ( selector )?
            IDENT128=this.match(this.input,IDENT,FormulaParser.FOLLOW_IDENT_in_assigned1186); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_IDENT.add(IDENT128);

            // /Library/WebServer/Documents/calc/Formula.g:182:10: ( selector )?
            var alt38=2;
            var LA38_0 = this.input.LA(1);

            if ( (LA38_0==LARR||LA38_0==LCURL||LA38_0==116) ) {
                alt38=1;
            }
            switch (alt38) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:0:0: selector
                    this.pushFollow(FormulaParser.FOLLOW_selector_in_assigned1188);
                    selector129=this.selector();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) stream_selector.add(selector129.getTree());


                    break;

            }



            // AST REWRITE
            // elements: selector, IDENT
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            if ( this.state.backtracking===0 ) {
            retval.tree = root_0;
            var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

            root_0 = this.adaptor.nil();
            // 182:20: -> ^( ASSIGNED IDENT ( selector )? )
            {
                // /Library/WebServer/Documents/calc/Formula.g:182:23: ^( ASSIGNED IDENT ( selector )? )
                {
                var root_1 = this.adaptor.nil();
                root_1 = this.adaptor.becomeRoot(this.adaptor.create(ASSIGNED, "ASSIGNED"), root_1);

                this.adaptor.addChild(root_1, stream_IDENT.nextNode());
                // /Library/WebServer/Documents/calc/Formula.g:182:40: ( selector )?
                if ( stream_selector.hasNext() ) {
                    this.adaptor.addChild(root_1, stream_selector.nextTree());

                }
                stream_selector.reset();

                this.adaptor.addChild(root_0, root_1);
                }

            }

            retval.tree = root_0;}


            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    logicalExpression_return: (function() {
        FormulaParser.logicalExpression_return = function(){};
        org.antlr.lang.extend(FormulaParser.logicalExpression_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // /Library/WebServer/Documents/calc/Formula.g:186:1: logicalExpression : booleanXORExpression ( OR booleanXORExpression )* ;
    // $ANTLR start "logicalExpression"
    logicalExpression: function() {
        var retval = new FormulaParser.logicalExpression_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var OR131 = null;
         var booleanXORExpression130 = null;
         var booleanXORExpression132 = null;

        var OR131_tree=null;

        try {
            // /Library/WebServer/Documents/calc/Formula.g:187:2: ( booleanXORExpression ( OR booleanXORExpression )* )
            // /Library/WebServer/Documents/calc/Formula.g:187:4: booleanXORExpression ( OR booleanXORExpression )*
            root_0 = this.adaptor.nil();

            this.pushFollow(FormulaParser.FOLLOW_booleanXORExpression_in_logicalExpression1214);
            booleanXORExpression130=this.booleanXORExpression();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, booleanXORExpression130.getTree());
            // /Library/WebServer/Documents/calc/Formula.g:187:25: ( OR booleanXORExpression )*
            loop39:
            do {
                var alt39=2;
                var LA39_0 = this.input.LA(1);

                if ( (LA39_0==OR) ) {
                    var LA39_2 = this.input.LA(2);

                    if ( (this.synpred47_Formula()) ) {
                        alt39=1;
                    }


                }


                switch (alt39) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:187:26: OR booleanXORExpression
                    OR131=this.match(this.input,OR,FormulaParser.FOLLOW_OR_in_logicalExpression1217); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    OR131_tree = this.adaptor.create(OR131);
                    root_0 = this.adaptor.becomeRoot(OR131_tree, root_0);
                    }
                    this.pushFollow(FormulaParser.FOLLOW_booleanXORExpression_in_logicalExpression1220);
                    booleanXORExpression132=this.booleanXORExpression();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, booleanXORExpression132.getTree());


                    break;

                default :
                    break loop39;
                }
            } while (true);




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    booleanXORExpression_return: (function() {
        FormulaParser.booleanXORExpression_return = function(){};
        org.antlr.lang.extend(FormulaParser.booleanXORExpression_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // /Library/WebServer/Documents/calc/Formula.g:192:1: booleanXORExpression : booleanAndExpression ( XOR booleanAndExpression )* ;
    // $ANTLR start "booleanXORExpression"
    booleanXORExpression: function() {
        var retval = new FormulaParser.booleanXORExpression_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var XOR134 = null;
         var booleanAndExpression133 = null;
         var booleanAndExpression135 = null;

        var XOR134_tree=null;

        try {
            // /Library/WebServer/Documents/calc/Formula.g:193:2: ( booleanAndExpression ( XOR booleanAndExpression )* )
            // /Library/WebServer/Documents/calc/Formula.g:193:4: booleanAndExpression ( XOR booleanAndExpression )*
            root_0 = this.adaptor.nil();

            this.pushFollow(FormulaParser.FOLLOW_booleanAndExpression_in_booleanXORExpression1250);
            booleanAndExpression133=this.booleanAndExpression();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, booleanAndExpression133.getTree());
            // /Library/WebServer/Documents/calc/Formula.g:193:25: ( XOR booleanAndExpression )*
            loop40:
            do {
                var alt40=2;
                var LA40_0 = this.input.LA(1);

                if ( (LA40_0==XOR) ) {
                    var LA40_2 = this.input.LA(2);

                    if ( (this.synpred48_Formula()) ) {
                        alt40=1;
                    }


                }


                switch (alt40) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:193:26: XOR booleanAndExpression
                    XOR134=this.match(this.input,XOR,FormulaParser.FOLLOW_XOR_in_booleanXORExpression1253); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    XOR134_tree = this.adaptor.create(XOR134);
                    root_0 = this.adaptor.becomeRoot(XOR134_tree, root_0);
                    }
                    this.pushFollow(FormulaParser.FOLLOW_booleanAndExpression_in_booleanXORExpression1256);
                    booleanAndExpression135=this.booleanAndExpression();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, booleanAndExpression135.getTree());


                    break;

                default :
                    break loop40;
                }
            } while (true);




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    booleanAndExpression_return: (function() {
        FormulaParser.booleanAndExpression_return = function(){};
        org.antlr.lang.extend(FormulaParser.booleanAndExpression_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // /Library/WebServer/Documents/calc/Formula.g:198:1: booleanAndExpression : equalityExpression ( AND equalityExpression )* ;
    // $ANTLR start "booleanAndExpression"
    booleanAndExpression: function() {
        var retval = new FormulaParser.booleanAndExpression_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var AND137 = null;
         var equalityExpression136 = null;
         var equalityExpression138 = null;

        var AND137_tree=null;

        try {
            // /Library/WebServer/Documents/calc/Formula.g:199:2: ( equalityExpression ( AND equalityExpression )* )
            // /Library/WebServer/Documents/calc/Formula.g:199:4: equalityExpression ( AND equalityExpression )*
            root_0 = this.adaptor.nil();

            this.pushFollow(FormulaParser.FOLLOW_equalityExpression_in_booleanAndExpression1285);
            equalityExpression136=this.equalityExpression();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, equalityExpression136.getTree());
            // /Library/WebServer/Documents/calc/Formula.g:199:23: ( AND equalityExpression )*
            loop41:
            do {
                var alt41=2;
                var LA41_0 = this.input.LA(1);

                if ( (LA41_0==AND) ) {
                    var LA41_2 = this.input.LA(2);

                    if ( (this.synpred49_Formula()) ) {
                        alt41=1;
                    }


                }


                switch (alt41) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:199:24: AND equalityExpression
                    AND137=this.match(this.input,AND,FormulaParser.FOLLOW_AND_in_booleanAndExpression1288); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    AND137_tree = this.adaptor.create(AND137);
                    root_0 = this.adaptor.becomeRoot(AND137_tree, root_0);
                    }
                    this.pushFollow(FormulaParser.FOLLOW_equalityExpression_in_booleanAndExpression1291);
                    equalityExpression138=this.equalityExpression();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, equalityExpression138.getTree());


                    break;

                default :
                    break loop41;
                }
            } while (true);




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    equalityExpression_return: (function() {
        FormulaParser.equalityExpression_return = function(){};
        org.antlr.lang.extend(FormulaParser.equalityExpression_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // /Library/WebServer/Documents/calc/Formula.g:204:1: equalityExpression : relationalExpression ( ( EQUALS | NOTEQUALS ) relationalExpression )* ;
    // $ANTLR start "equalityExpression"
    equalityExpression: function() {
        var retval = new FormulaParser.equalityExpression_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var set140 = null;
         var relationalExpression139 = null;
         var relationalExpression141 = null;

        var set140_tree=null;

        try {
            // /Library/WebServer/Documents/calc/Formula.g:205:2: ( relationalExpression ( ( EQUALS | NOTEQUALS ) relationalExpression )* )
            // /Library/WebServer/Documents/calc/Formula.g:205:4: relationalExpression ( ( EQUALS | NOTEQUALS ) relationalExpression )*
            root_0 = this.adaptor.nil();

            this.pushFollow(FormulaParser.FOLLOW_relationalExpression_in_equalityExpression1322);
            relationalExpression139=this.relationalExpression();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, relationalExpression139.getTree());
            // /Library/WebServer/Documents/calc/Formula.g:205:25: ( ( EQUALS | NOTEQUALS ) relationalExpression )*
            loop42:
            do {
                var alt42=2;
                var LA42_0 = this.input.LA(1);

                if ( (LA42_0==EQUALS||LA42_0==NOTEQUALS) ) {
                    var LA42_2 = this.input.LA(2);

                    if ( (this.synpred51_Formula()) ) {
                        alt42=1;
                    }


                }


                switch (alt42) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:205:26: ( EQUALS | NOTEQUALS ) relationalExpression
                    
                    set140=this.input.LT(1);
                    if ( this.input.LA(1)==EQUALS||this.input.LA(1)==NOTEQUALS ) {
                        this.input.consume();
                        if ( this.state.backtracking===0 ) root_0 = this.adaptor.becomeRoot(this.adaptor.create(set140), root_0);
                        this.state.errorRecovery=false;this.state.failed=false;
                    }
                    else {
                        if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                        throw mse;
                    }

                    this.pushFollow(FormulaParser.FOLLOW_relationalExpression_in_equalityExpression1332);
                    relationalExpression141=this.relationalExpression();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, relationalExpression141.getTree());


                    break;

                default :
                    break loop42;
                }
            } while (true);




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    relationalExpression_return: (function() {
        FormulaParser.relationalExpression_return = function(){};
        org.antlr.lang.extend(FormulaParser.relationalExpression_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // /Library/WebServer/Documents/calc/Formula.g:215:1: relationalExpression : additiveExpression ( ( LT | LTEQ | GT | GTEQ ) additiveExpression )* ;
    // $ANTLR start "relationalExpression"
    relationalExpression: function() {
        var retval = new FormulaParser.relationalExpression_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var set143 = null;
         var additiveExpression142 = null;
         var additiveExpression144 = null;

        var set143_tree=null;

        try {
            // /Library/WebServer/Documents/calc/Formula.g:216:2: ( additiveExpression ( ( LT | LTEQ | GT | GTEQ ) additiveExpression )* )
            // /Library/WebServer/Documents/calc/Formula.g:216:4: additiveExpression ( ( LT | LTEQ | GT | GTEQ ) additiveExpression )*
            root_0 = this.adaptor.nil();

            this.pushFollow(FormulaParser.FOLLOW_additiveExpression_in_relationalExpression1374);
            additiveExpression142=this.additiveExpression();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, additiveExpression142.getTree());
            // /Library/WebServer/Documents/calc/Formula.g:216:23: ( ( LT | LTEQ | GT | GTEQ ) additiveExpression )*
            loop43:
            do {
                var alt43=2;
                var LA43_0 = this.input.LA(1);

                if ( ((LA43_0>=LT && LA43_0<=GTEQ)) ) {
                    var LA43_2 = this.input.LA(2);

                    if ( (this.synpred55_Formula()) ) {
                        alt43=1;
                    }


                }


                switch (alt43) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:216:25: ( LT | LTEQ | GT | GTEQ ) additiveExpression
                   
                    set143=this.input.LT(1);
                    if ( (this.input.LA(1)>=LT && this.input.LA(1)<=GTEQ) ) {
                        this.input.consume();
                        if ( this.state.backtracking===0 ) root_0 = this.adaptor.becomeRoot(this.adaptor.create(set143), root_0);
                        this.state.errorRecovery=false;this.state.failed=false;
                    }
                    else {
                        if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                        throw mse;
                    }

                    this.pushFollow(FormulaParser.FOLLOW_additiveExpression_in_relationalExpression1389);
                    additiveExpression144=this.additiveExpression();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, additiveExpression144.getTree());


                    break;

                default :
                    break loop43;
                }
            } while (true);




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    additiveExpression_return: (function() {
        FormulaParser.additiveExpression_return = function(){};
        org.antlr.lang.extend(FormulaParser.additiveExpression_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // /Library/WebServer/Documents/calc/Formula.g:224:1: additiveExpression : multiplicativeExpression ( ( PLUS | MINUS ) multiplicativeExpression )* ;
    // $ANTLR start "additiveExpression"
    additiveExpression: function() {
        var retval = new FormulaParser.additiveExpression_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var set146 = null;
         var multiplicativeExpression145 = null;
         var multiplicativeExpression147 = null;

        var set146_tree=null;

        try {
            // /Library/WebServer/Documents/calc/Formula.g:225:2: ( multiplicativeExpression ( ( PLUS | MINUS ) multiplicativeExpression )* )
            // /Library/WebServer/Documents/calc/Formula.g:225:4: multiplicativeExpression ( ( PLUS | MINUS ) multiplicativeExpression )*
            root_0 = this.adaptor.nil();

            this.pushFollow(FormulaParser.FOLLOW_multiplicativeExpression_in_additiveExpression1432);
            multiplicativeExpression145=this.multiplicativeExpression();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, multiplicativeExpression145.getTree());
            // /Library/WebServer/Documents/calc/Formula.g:225:29: ( ( PLUS | MINUS ) multiplicativeExpression )*
            loop44:
            do {
                var alt44=2;
                var LA44_0 = this.input.LA(1);

                if ( ((LA44_0>=PLUS && LA44_0<=MINUS)) ) {
                    var LA44_2 = this.input.LA(2);

                    if ( (this.synpred57_Formula()) ) {
                        alt44=1;
                    }


                }


                switch (alt44) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:225:31: ( PLUS | MINUS ) multiplicativeExpression
                    
                    set146=this.input.LT(1);
                    if ( (this.input.LA(1)>=PLUS && this.input.LA(1)<=MINUS) ) {
                        this.input.consume();
                        if ( this.state.backtracking===0 ) root_0 = this.adaptor.becomeRoot(this.adaptor.create(set146), root_0);
                        this.state.errorRecovery=false;this.state.failed=false;
                    }
                    else {
                        if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                        throw mse;
                    }

                    this.pushFollow(FormulaParser.FOLLOW_multiplicativeExpression_in_additiveExpression1443);
                    multiplicativeExpression147=this.multiplicativeExpression();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, multiplicativeExpression147.getTree());


                    break;

                default :
                    break loop44;
                }
            } while (true);




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    multiplicativeExpression_return: (function() {
        FormulaParser.multiplicativeExpression_return = function(){};
        org.antlr.lang.extend(FormulaParser.multiplicativeExpression_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // /Library/WebServer/Documents/calc/Formula.g:231:1: multiplicativeExpression : arrayExpression ( ( MULT | DIV | MOD ) arrayExpression )* ;
    // $ANTLR start "multiplicativeExpression"
    multiplicativeExpression: function() {
        var retval = new FormulaParser.multiplicativeExpression_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var set149 = null;
         var arrayExpression148 = null;
         var arrayExpression150 = null;

        var set149_tree=null;

        try {
            // /Library/WebServer/Documents/calc/Formula.g:232:2: ( arrayExpression ( ( MULT | DIV | MOD ) arrayExpression )* )
            // /Library/WebServer/Documents/calc/Formula.g:232:4: arrayExpression ( ( MULT | DIV | MOD ) arrayExpression )*
            root_0 = this.adaptor.nil();

            this.pushFollow(FormulaParser.FOLLOW_arrayExpression_in_multiplicativeExpression1473);
            arrayExpression148=this.arrayExpression();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, arrayExpression148.getTree());
            // /Library/WebServer/Documents/calc/Formula.g:232:20: ( ( MULT | DIV | MOD ) arrayExpression )*
            loop45:
            do {
                var alt45=2;
                var LA45_0 = this.input.LA(1);

                if ( ((LA45_0>=MULT && LA45_0<=MOD)) ) {
                    var LA45_2 = this.input.LA(2);

                    if ( (this.synpred60_Formula()) ) {
                        alt45=1;
                    }


                }


                switch (alt45) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:232:22: ( MULT | DIV | MOD ) arrayExpression
                    
                    set149=this.input.LT(1);
                    if ( (this.input.LA(1)>=MULT && this.input.LA(1)<=MOD) ) {
                        this.input.consume();
                        if ( this.state.backtracking===0 ) root_0 = this.adaptor.becomeRoot(this.adaptor.create(set149), root_0);
                        this.state.errorRecovery=false;this.state.failed=false;
                    }
                    else {
                        if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                        throw mse;
                    }

                    this.pushFollow(FormulaParser.FOLLOW_arrayExpression_in_multiplicativeExpression1486);
                    arrayExpression150=this.arrayExpression();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, arrayExpression150.getTree());


                    break;

                default :
                    break loop45;
                }
            } while (true);




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    arrayExpression_return: (function() {
        FormulaParser.arrayExpression_return = function(){};
        org.antlr.lang.extend(FormulaParser.arrayExpression_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // /Library/WebServer/Documents/calc/Formula.g:239:1: arrayExpression : negationExpression ({...}? COLON {...}? negationExpression )? ({...}? COLON {...}? negationExpression )? -> ^( RANGE ( negationExpression )* ) ;
    // $ANTLR start "arrayExpression"
    arrayExpression: function() {
        var retval = new FormulaParser.arrayExpression_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var COLON152 = null;
        var COLON154 = null;
         var negationExpression151 = null;
         var negationExpression153 = null;
         var negationExpression155 = null;

        var COLON152_tree=null;
        var COLON154_tree=null;
        var stream_COLON=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token COLON");
        var stream_negationExpression=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule negationExpression");
        try {
            // /Library/WebServer/Documents/calc/Formula.g:240:2: ( negationExpression ({...}? COLON {...}? negationExpression )? ({...}? COLON {...}? negationExpression )? -> ^( RANGE ( negationExpression )* ) )
            // /Library/WebServer/Documents/calc/Formula.g:240:4: negationExpression ({...}? COLON {...}? negationExpression )? ({...}? COLON {...}? negationExpression )?
            this.pushFollow(FormulaParser.FOLLOW_negationExpression_in_arrayExpression1532);
            negationExpression151=this.negationExpression();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) stream_negationExpression.add(negationExpression151.getTree());
            // /Library/WebServer/Documents/calc/Formula.g:240:24: ({...}? COLON {...}? negationExpression )?
            var alt46=2;
            var LA46_0 = this.input.LA(1);

            if ( (LA46_0==COLON) ) {
                var LA46_1 = this.input.LA(2);

                if ( ((this.synpred61_Formula()&&( this.input.get(this.input.index()-1).getText()!=" "))) ) {
                    alt46=1;
                }
            }
            switch (alt46) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:240:25: {...}? COLON {...}? negationExpression
                    if ( !(( this.input.get(this.input.index()-1).getText()!=" ")) ) {
                        if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        throw new org.antlr.runtime.FailedPredicateException(this.input, "arrayExpression", " this.input.get(this.input.index()-1).getText()!=\" \"");
                    }
                    COLON152=this.match(this.input,COLON,FormulaParser.FOLLOW_COLON_in_arrayExpression1538); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_COLON.add(COLON152);

                    if ( !(( this.input.get(this.input.index()-1).getText()!=" ")) ) {
                        if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        throw new org.antlr.runtime.FailedPredicateException(this.input, "arrayExpression", " this.input.get(this.input.index()-1).getText()!=\" \"");
                    }
                    this.pushFollow(FormulaParser.FOLLOW_negationExpression_in_arrayExpression1542);
                    negationExpression153=this.negationExpression();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) stream_negationExpression.add(negationExpression153.getTree());


                    break;

            }

            // /Library/WebServer/Documents/calc/Formula.g:240:165: ({...}? COLON {...}? negationExpression )?
            var alt47=2;
            var LA47_0 = this.input.LA(1);

            if ( (LA47_0==COLON) ) {
                var LA47_1 = this.input.LA(2);

                if ( ((this.synpred62_Formula()&&( this.input.get(this.input.index()-1).getText()!=" "))) ) {
                    alt47=1;
                }
            }
            switch (alt47) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:240:167: {...}? COLON {...}? negationExpression
                    if ( !(( this.input.get(this.input.index()-1).getText()!=" ")) ) {
                        if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        throw new org.antlr.runtime.FailedPredicateException(this.input, "arrayExpression", " this.input.get(this.input.index()-1).getText()!=\" \"");
                    }
                    COLON154=this.match(this.input,COLON,FormulaParser.FOLLOW_COLON_in_arrayExpression1551); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_COLON.add(COLON154);

                    if ( !(( this.input.get(this.input.index()-1).getText()!=" ")) ) {
                        if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        throw new org.antlr.runtime.FailedPredicateException(this.input, "arrayExpression", " this.input.get(this.input.index()-1).getText()!=\" \"");
                    }
                    this.pushFollow(FormulaParser.FOLLOW_negationExpression_in_arrayExpression1555);
                    negationExpression155=this.negationExpression();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) stream_negationExpression.add(negationExpression155.getTree());


                    break;

            }



            // AST REWRITE
            // elements: negationExpression
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            if ( this.state.backtracking===0 ) {
            retval.tree = root_0;
            var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

            root_0 = this.adaptor.nil();
            // 240:306: -> ^( RANGE ( negationExpression )* )
            {
                // /Library/WebServer/Documents/calc/Formula.g:240:309: ^( RANGE ( negationExpression )* )
                {
                var root_1 = this.adaptor.nil();
                root_1 = this.adaptor.becomeRoot(this.adaptor.create(RANGE, "RANGE"), root_1);

                // /Library/WebServer/Documents/calc/Formula.g:240:317: ( negationExpression )*
                while ( stream_negationExpression.hasNext() ) {
                    this.adaptor.addChild(root_1, stream_negationExpression.nextTree());

                }
                stream_negationExpression.reset();

                this.adaptor.addChild(root_0, root_1);
                }

            }

            retval.tree = root_0;}


            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    negationExpression_return: (function() {
        FormulaParser.negationExpression_return = function(){};
        org.antlr.lang.extend(FormulaParser.negationExpression_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // /Library/WebServer/Documents/calc/Formula.g:244:1: negationExpression : ( MINUS powerExpression -> ^( NEGATE powerExpression ) | powerExpression );
    // $ANTLR start "negationExpression"
    negationExpression: function() {
        var retval = new FormulaParser.negationExpression_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var MINUS156 = null;
         var powerExpression157 = null;
         var powerExpression158 = null;

        var MINUS156_tree=null;
        var stream_MINUS=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token MINUS");
        var stream_powerExpression=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule powerExpression");
        try {
            // /Library/WebServer/Documents/calc/Formula.g:245:2: ( MINUS powerExpression -> ^( NEGATE powerExpression ) | powerExpression )
            var alt48=2;
            var LA48_0 = this.input.LA(1);

            if ( (LA48_0==MINUS) ) {
                alt48=1;
            }
            else if ( (LA48_0==FUNCTIONSTATEMENT||LA48_0==NEWSTATEMENT||LA48_0==IDENT||LA48_0==PRIMITIVE||(LA48_0>=NOT && LA48_0<=LARR)||LA48_0==LCURL||(LA48_0>=STRING && LA48_0<=FALSE)||LA48_0==113) ) {
                alt48=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 48, 0, this.input);

                throw nvae;
            }
            switch (alt48) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:245:4: MINUS powerExpression
                    MINUS156=this.match(this.input,MINUS,FormulaParser.FOLLOW_MINUS_in_negationExpression1580); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_MINUS.add(MINUS156);

                    this.pushFollow(FormulaParser.FOLLOW_powerExpression_in_negationExpression1582);
                    powerExpression157=this.powerExpression();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) stream_powerExpression.add(powerExpression157.getTree());


                    // AST REWRITE
                    // elements: powerExpression
                    // token labels: 
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: 
                    if ( this.state.backtracking===0 ) {
                    retval.tree = root_0;
                    var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

                    root_0 = this.adaptor.nil();
                    // 245:26: -> ^( NEGATE powerExpression )
                    {
                        // /Library/WebServer/Documents/calc/Formula.g:245:29: ^( NEGATE powerExpression )
                        {
                        var root_1 = this.adaptor.nil();
                        root_1 = this.adaptor.becomeRoot(this.adaptor.create(NEGATE, "NEGATE"), root_1);

                        this.adaptor.addChild(root_1, stream_powerExpression.nextTree());

                        this.adaptor.addChild(root_0, root_1);
                        }

                    }

                    retval.tree = root_0;}

                    break;
                case 2 :
                    // /Library/WebServer/Documents/calc/Formula.g:246:3: powerExpression
                    root_0 = this.adaptor.nil();

                    this.pushFollow(FormulaParser.FOLLOW_powerExpression_in_negationExpression1596);
                    powerExpression158=this.powerExpression();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, powerExpression158.getTree());


                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    powerExpression_return: (function() {
        FormulaParser.powerExpression_return = function(){};
        org.antlr.lang.extend(FormulaParser.powerExpression_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // /Library/WebServer/Documents/calc/Formula.g:248:1: powerExpression : unaryExpression ( POW unaryOrNegate )* -> ^( POWER unaryExpression ( unaryOrNegate )* ) ;
    // $ANTLR start "powerExpression"
    powerExpression: function() {
        var retval = new FormulaParser.powerExpression_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var POW160 = null;
         var unaryExpression159 = null;
         var unaryOrNegate161 = null;

        var POW160_tree=null;
        var stream_POW=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token POW");
        var stream_unaryOrNegate=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule unaryOrNegate");
        var stream_unaryExpression=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule unaryExpression");
        try {
            // /Library/WebServer/Documents/calc/Formula.g:249:2: ( unaryExpression ( POW unaryOrNegate )* -> ^( POWER unaryExpression ( unaryOrNegate )* ) )
            // /Library/WebServer/Documents/calc/Formula.g:249:4: unaryExpression ( POW unaryOrNegate )*
            this.pushFollow(FormulaParser.FOLLOW_unaryExpression_in_powerExpression1607);
            unaryExpression159=this.unaryExpression();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) stream_unaryExpression.add(unaryExpression159.getTree());
            // /Library/WebServer/Documents/calc/Formula.g:249:20: ( POW unaryOrNegate )*
            loop49:
            do {
                var alt49=2;
                var LA49_0 = this.input.LA(1);

                if ( (LA49_0==POW) ) {
                    var LA49_2 = this.input.LA(2);

                    if ( (this.synpred64_Formula()) ) {
                        alt49=1;
                    }


                }


                switch (alt49) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:249:21: POW unaryOrNegate
                    POW160=this.match(this.input,POW,FormulaParser.FOLLOW_POW_in_powerExpression1610); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_POW.add(POW160);

                    this.pushFollow(FormulaParser.FOLLOW_unaryOrNegate_in_powerExpression1612);
                    unaryOrNegate161=this.unaryOrNegate();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) stream_unaryOrNegate.add(unaryOrNegate161.getTree());


                    break;

                default :
                    break loop49;
                }
            } while (true);



            // AST REWRITE
            // elements: unaryOrNegate, unaryExpression
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            if ( this.state.backtracking===0 ) {
            retval.tree = root_0;
            var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

            root_0 = this.adaptor.nil();
            // 249:43: -> ^( POWER unaryExpression ( unaryOrNegate )* )
            {
                // /Library/WebServer/Documents/calc/Formula.g:249:47: ^( POWER unaryExpression ( unaryOrNegate )* )
                {
                var root_1 = this.adaptor.nil();
                root_1 = this.adaptor.becomeRoot(this.adaptor.create(POWER, "POWER"), root_1);

                this.adaptor.addChild(root_1, stream_unaryExpression.nextTree());
                // /Library/WebServer/Documents/calc/Formula.g:249:71: ( unaryOrNegate )*
                while ( stream_unaryOrNegate.hasNext() ) {
                    this.adaptor.addChild(root_1, stream_unaryOrNegate.nextTree());

                }
                stream_unaryOrNegate.reset();

                this.adaptor.addChild(root_0, root_1);
                }

            }

            retval.tree = root_0;}


            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    unaryOrNegate_return: (function() {
        FormulaParser.unaryOrNegate_return = function(){};
        org.antlr.lang.extend(FormulaParser.unaryOrNegate_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // /Library/WebServer/Documents/calc/Formula.g:252:1: unaryOrNegate : ( unaryExpression | MINUS unaryExpression -> ^( NEGATE unaryExpression ) );
    // $ANTLR start "unaryOrNegate"
    unaryOrNegate: function() {
        var retval = new FormulaParser.unaryOrNegate_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var MINUS163 = null;
         var unaryExpression162 = null;
         var unaryExpression164 = null;

        var MINUS163_tree=null;
        var stream_MINUS=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token MINUS");
        var stream_unaryExpression=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule unaryExpression");
        try {
            // /Library/WebServer/Documents/calc/Formula.g:253:2: ( unaryExpression | MINUS unaryExpression -> ^( NEGATE unaryExpression ) )
            var alt50=2;
            var LA50_0 = this.input.LA(1);

            if ( (LA50_0==FUNCTIONSTATEMENT||LA50_0==NEWSTATEMENT||LA50_0==IDENT||LA50_0==PRIMITIVE||(LA50_0>=NOT && LA50_0<=LARR)||LA50_0==LCURL||(LA50_0>=STRING && LA50_0<=FALSE)||LA50_0==113) ) {
                alt50=1;
            }
            else if ( (LA50_0==MINUS) ) {
                alt50=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 50, 0, this.input);

                throw nvae;
            }
            switch (alt50) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:253:4: unaryExpression
                    root_0 = this.adaptor.nil();

                    this.pushFollow(FormulaParser.FOLLOW_unaryExpression_in_unaryOrNegate1639);
                    unaryExpression162=this.unaryExpression();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, unaryExpression162.getTree());


                    break;
                case 2 :
                    // /Library/WebServer/Documents/calc/Formula.g:254:3: MINUS unaryExpression
                    MINUS163=this.match(this.input,MINUS,FormulaParser.FOLLOW_MINUS_in_unaryOrNegate1645); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_MINUS.add(MINUS163);

                    this.pushFollow(FormulaParser.FOLLOW_unaryExpression_in_unaryOrNegate1647);
                    unaryExpression164=this.unaryExpression();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) stream_unaryExpression.add(unaryExpression164.getTree());


                    // AST REWRITE
                    // elements: unaryExpression
                    // token labels: 
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: 
                    if ( this.state.backtracking===0 ) {
                    retval.tree = root_0;
                    var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

                    root_0 = this.adaptor.nil();
                    // 254:25: -> ^( NEGATE unaryExpression )
                    {
                        // /Library/WebServer/Documents/calc/Formula.g:254:28: ^( NEGATE unaryExpression )
                        {
                        var root_1 = this.adaptor.nil();
                        root_1 = this.adaptor.becomeRoot(this.adaptor.create(NEGATE, "NEGATE"), root_1);

                        this.adaptor.addChild(root_1, stream_unaryExpression.nextTree());

                        this.adaptor.addChild(root_0, root_1);
                        }

                    }

                    retval.tree = root_0;}

                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    unaryExpression_return: (function() {
        FormulaParser.unaryExpression_return = function(){};
        org.antlr.lang.extend(FormulaParser.unaryExpression_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // /Library/WebServer/Documents/calc/Formula.g:259:1: unaryExpression : ( NOT innerPrimaryExpression | innerPrimaryExpression );
    // $ANTLR start "unaryExpression"
    unaryExpression: function() {
        var retval = new FormulaParser.unaryExpression_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var NOT165 = null;
         var innerPrimaryExpression166 = null;
         var innerPrimaryExpression167 = null;

        var NOT165_tree=null;

        try {
            // /Library/WebServer/Documents/calc/Formula.g:260:2: ( NOT innerPrimaryExpression | innerPrimaryExpression )
            var alt51=2;
            var LA51_0 = this.input.LA(1);

            if ( (LA51_0==NOT) ) {
                alt51=1;
            }
            else if ( (LA51_0==FUNCTIONSTATEMENT||LA51_0==NEWSTATEMENT||LA51_0==IDENT||LA51_0==PRIMITIVE||LA51_0==LARR||LA51_0==LCURL||(LA51_0>=STRING && LA51_0<=FALSE)||LA51_0==113) ) {
                alt51=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 51, 0, this.input);

                throw nvae;
            }
            switch (alt51) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:260:4: NOT innerPrimaryExpression
                    root_0 = this.adaptor.nil();

                    NOT165=this.match(this.input,NOT,FormulaParser.FOLLOW_NOT_in_unaryExpression1675); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    NOT165_tree = this.adaptor.create(NOT165);
                    root_0 = this.adaptor.becomeRoot(NOT165_tree, root_0);
                    }
                    this.pushFollow(FormulaParser.FOLLOW_innerPrimaryExpression_in_unaryExpression1678);
                    innerPrimaryExpression166=this.innerPrimaryExpression();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, innerPrimaryExpression166.getTree());


                    break;
                case 2 :
                    // /Library/WebServer/Documents/calc/Formula.g:261:8: innerPrimaryExpression
                    root_0 = this.adaptor.nil();

                    this.pushFollow(FormulaParser.FOLLOW_innerPrimaryExpression_in_unaryExpression1687);
                    innerPrimaryExpression167=this.innerPrimaryExpression();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, innerPrimaryExpression167.getTree());


                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    innerPrimaryExpression_return: (function() {
        FormulaParser.innerPrimaryExpression_return = function(){};
        org.antlr.lang.extend(FormulaParser.innerPrimaryExpression_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // /Library/WebServer/Documents/calc/Formula.g:266:1: innerPrimaryExpression : selectionExpression -> ^( INNER selectionExpression ) ;
    // $ANTLR start "innerPrimaryExpression"
    innerPrimaryExpression: function() {
        var retval = new FormulaParser.innerPrimaryExpression_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var selectionExpression168 = null;

        var stream_selectionExpression=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule selectionExpression");
        try {
            // /Library/WebServer/Documents/calc/Formula.g:267:2: ( selectionExpression -> ^( INNER selectionExpression ) )
            // /Library/WebServer/Documents/calc/Formula.g:267:4: selectionExpression
            this.pushFollow(FormulaParser.FOLLOW_selectionExpression_in_innerPrimaryExpression1718);
            selectionExpression168=this.selectionExpression();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) stream_selectionExpression.add(selectionExpression168.getTree());


            // AST REWRITE
            // elements: selectionExpression
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            if ( this.state.backtracking===0 ) {
            retval.tree = root_0;
            var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

            root_0 = this.adaptor.nil();
            // 267:24: -> ^( INNER selectionExpression )
            {
                // /Library/WebServer/Documents/calc/Formula.g:267:27: ^( INNER selectionExpression )
                {
                var root_1 = this.adaptor.nil();
                root_1 = this.adaptor.becomeRoot(this.adaptor.create(INNER, "INNER"), root_1);

                this.adaptor.addChild(root_1, stream_selectionExpression.nextTree());

                this.adaptor.addChild(root_0, root_1);
                }

            }

            retval.tree = root_0;}


            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    selectionExpression_return: (function() {
        FormulaParser.selectionExpression_return = function(){};
        org.antlr.lang.extend(FormulaParser.selectionExpression_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // /Library/WebServer/Documents/calc/Formula.g:270:1: selectionExpression : primaryExpression ({...}? ( selector | funCall ) )* ;
    // $ANTLR start "selectionExpression"
    selectionExpression: function() {
        var retval = new FormulaParser.selectionExpression_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var primaryExpression169 = null;
         var selector170 = null;
         var funCall171 = null;


        try {
            // /Library/WebServer/Documents/calc/Formula.g:271:2: ( primaryExpression ({...}? ( selector | funCall ) )* )
            // /Library/WebServer/Documents/calc/Formula.g:271:4: primaryExpression ({...}? ( selector | funCall ) )*
            root_0 = this.adaptor.nil();

            this.pushFollow(FormulaParser.FOLLOW_primaryExpression_in_selectionExpression1738);
            primaryExpression169=this.primaryExpression();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, primaryExpression169.getTree());
            // /Library/WebServer/Documents/calc/Formula.g:271:22: ({...}? ( selector | funCall ) )*
            loop53:
            do {
                var alt53=2;
                switch ( this.input.LA(1) ) {
                case LARR:
                    var LA53_2 = this.input.LA(2);

                    if ( ((this.synpred68_Formula()&&( this.input.get(this.input.index()-1).getText()!=" "))) ) {
                        alt53=1;
                    }


                    break;
                case LCURL:
                    var LA53_3 = this.input.LA(2);

                    if ( ((this.synpred68_Formula()&&( this.input.get(this.input.index()-1).getText()!=" "))) ) {
                        alt53=1;
                    }


                    break;
                case 116:
                    var LA53_4 = this.input.LA(2);

                    if ( ((this.synpred68_Formula()&&( this.input.get(this.input.index()-1).getText()!=" "))) ) {
                        alt53=1;
                    }


                    break;
                case 113:
                    var LA53_5 = this.input.LA(2);

                    if ( ((this.synpred68_Formula()&&( this.input.get(this.input.index()-1).getText()!=" "))) ) {
                        alt53=1;
                    }


                    break;

                }

                switch (alt53) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:271:23: {...}? ( selector | funCall )
                    if ( !(( this.input.get(this.input.index()-1).getText()!=" ")) ) {
                        if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        throw new org.antlr.runtime.FailedPredicateException(this.input, "selectionExpression", " this.input.get(this.input.index()-1).getText()!=\" \"");
                    }
                    // /Library/WebServer/Documents/calc/Formula.g:271:79: ( selector | funCall )
                    var alt52=2;
                    var LA52_0 = this.input.LA(1);

                    if ( (LA52_0==LARR||LA52_0==LCURL||LA52_0==116) ) {
                        alt52=1;
                    }
                    else if ( (LA52_0==113) ) {
                        alt52=2;
                    }
                    else {
                        if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        var nvae =
                            new org.antlr.runtime.NoViableAltException("", 52, 0, this.input);

                        throw nvae;
                    }
                    switch (alt52) {
                        case 1 :
                            // /Library/WebServer/Documents/calc/Formula.g:271:80: selector
                            this.pushFollow(FormulaParser.FOLLOW_selector_in_selectionExpression1744);
                            selector170=this.selector();

                            this.state._fsp--;
                            if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, selector170.getTree());


                            break;
                        case 2 :
                            // /Library/WebServer/Documents/calc/Formula.g:271:89: funCall
                            this.pushFollow(FormulaParser.FOLLOW_funCall_in_selectionExpression1746);
                            funCall171=this.funCall();

                            this.state._fsp--;
                            if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, funCall171.getTree());


                            break;

                    }



                    break;

                default :
                    break loop53;
                }
            } while (true);




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    funCall_return: (function() {
        FormulaParser.funCall_return = function(){};
        org.antlr.lang.extend(FormulaParser.funCall_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // /Library/WebServer/Documents/calc/Formula.g:274:1: funCall : '(' ( logicalExpression ( ',' logicalExpression )* )? ')' -> ^( FUNCALL ( logicalExpression )* ) ;
    // $ANTLR start "funCall"
    funCall: function() {
        var retval = new FormulaParser.funCall_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var char_literal172 = null;
        var char_literal174 = null;
        var char_literal176 = null;
         var logicalExpression173 = null;
         var logicalExpression175 = null;

        var char_literal172_tree=null;
        var char_literal174_tree=null;
        var char_literal176_tree=null;
        var stream_114=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token 114");
        var stream_113=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token 113");
        var stream_COMMA=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token COMMA");
        var stream_logicalExpression=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule logicalExpression");
        try {
            // /Library/WebServer/Documents/calc/Formula.g:274:9: ( '(' ( logicalExpression ( ',' logicalExpression )* )? ')' -> ^( FUNCALL ( logicalExpression )* ) )
            // /Library/WebServer/Documents/calc/Formula.g:275:2: '(' ( logicalExpression ( ',' logicalExpression )* )? ')'
            char_literal172=this.match(this.input,113,FormulaParser.FOLLOW_113_in_funCall1761); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_113.add(char_literal172);

            // /Library/WebServer/Documents/calc/Formula.g:275:6: ( logicalExpression ( ',' logicalExpression )* )?
            var alt55=2;
            var LA55_0 = this.input.LA(1);

            if ( (LA55_0==FUNCTIONSTATEMENT||LA55_0==NEWSTATEMENT||LA55_0==IDENT||LA55_0==PRIMITIVE||LA55_0==MINUS||(LA55_0>=NOT && LA55_0<=LARR)||LA55_0==LCURL||(LA55_0>=STRING && LA55_0<=FALSE)||LA55_0==113) ) {
                alt55=1;
            }
            switch (alt55) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:275:8: logicalExpression ( ',' logicalExpression )*
                    this.pushFollow(FormulaParser.FOLLOW_logicalExpression_in_funCall1765);
                    logicalExpression173=this.logicalExpression();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) stream_logicalExpression.add(logicalExpression173.getTree());
                    // /Library/WebServer/Documents/calc/Formula.g:275:26: ( ',' logicalExpression )*
                    loop54:
                    do {
                        var alt54=2;
                        var LA54_0 = this.input.LA(1);

                        if ( (LA54_0==COMMA) ) {
                            alt54=1;
                        }


                        switch (alt54) {
                        case 1 :
                            // /Library/WebServer/Documents/calc/Formula.g:275:27: ',' logicalExpression
                            char_literal174=this.match(this.input,COMMA,FormulaParser.FOLLOW_COMMA_in_funCall1768); if (this.state.failed) return retval; 
                            if ( this.state.backtracking===0 ) stream_COMMA.add(char_literal174);

                            this.pushFollow(FormulaParser.FOLLOW_logicalExpression_in_funCall1770);
                            logicalExpression175=this.logicalExpression();

                            this.state._fsp--;
                            if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) stream_logicalExpression.add(logicalExpression175.getTree());


                            break;

                        default :
                            break loop54;
                        }
                    } while (true);



                    break;

            }

            char_literal176=this.match(this.input,114,FormulaParser.FOLLOW_114_in_funCall1777); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_114.add(char_literal176);



            // AST REWRITE
            // elements: logicalExpression
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            if ( this.state.backtracking===0 ) {
            retval.tree = root_0;
            var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

            root_0 = this.adaptor.nil();
            // 275:58: -> ^( FUNCALL ( logicalExpression )* )
            {
                // /Library/WebServer/Documents/calc/Formula.g:275:61: ^( FUNCALL ( logicalExpression )* )
                {
                var root_1 = this.adaptor.nil();
                root_1 = this.adaptor.becomeRoot(this.adaptor.create(FUNCALL, "FUNCALL"), root_1);

                // /Library/WebServer/Documents/calc/Formula.g:275:71: ( logicalExpression )*
                while ( stream_logicalExpression.hasNext() ) {
                    this.adaptor.addChild(root_1, stream_logicalExpression.nextTree());

                }
                stream_logicalExpression.reset();

                this.adaptor.addChild(root_0, root_1);
                }

            }

            retval.tree = root_0;}


            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    primaryExpression_return: (function() {
        FormulaParser.primaryExpression_return = function(){};
        org.antlr.lang.extend(FormulaParser.primaryExpression_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // /Library/WebServer/Documents/calc/Formula.g:278:1: primaryExpression : ( '(' logicalExpression ')' | value );
    // $ANTLR start "primaryExpression"
    primaryExpression: function() {
        var retval = new FormulaParser.primaryExpression_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var char_literal177 = null;
        var char_literal179 = null;
         var logicalExpression178 = null;
         var value180 = null;

        var char_literal177_tree=null;
        var char_literal179_tree=null;

        try {
            // /Library/WebServer/Documents/calc/Formula.g:279:2: ( '(' logicalExpression ')' | value )
            var alt56=2;
            var LA56_0 = this.input.LA(1);

            if ( (LA56_0==113) ) {
                alt56=1;
            }
            else if ( (LA56_0==FUNCTIONSTATEMENT||LA56_0==NEWSTATEMENT||LA56_0==IDENT||LA56_0==PRIMITIVE||LA56_0==LARR||LA56_0==LCURL||(LA56_0>=STRING && LA56_0<=FALSE)) ) {
                alt56=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 56, 0, this.input);

                throw nvae;
            }
            switch (alt56) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:279:4: '(' logicalExpression ')'
                    root_0 = this.adaptor.nil();

                    char_literal177=this.match(this.input,113,FormulaParser.FOLLOW_113_in_primaryExpression1798); if (this.state.failed) return retval;
                    this.pushFollow(FormulaParser.FOLLOW_logicalExpression_in_primaryExpression1801);
                    logicalExpression178=this.logicalExpression();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, logicalExpression178.getTree());
                    char_literal179=this.match(this.input,114,FormulaParser.FOLLOW_114_in_primaryExpression1803); if (this.state.failed) return retval;


                    break;
                case 2 :
                    // /Library/WebServer/Documents/calc/Formula.g:280:4: value
                    root_0 = this.adaptor.nil();

                    this.pushFollow(FormulaParser.FOLLOW_value_in_primaryExpression1809);
                    value180=this.value();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, value180.getTree());


                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    value_return: (function() {
        FormulaParser.value_return = function(){};
        org.antlr.lang.extend(FormulaParser.value_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // /Library/WebServer/Documents/calc/Formula.g:283:1: value : ( number | bool | string | material | IDENT | primitive | array | anonFunctionDef | newObject );
    // $ANTLR start "value"
    value: function() {
        var retval = new FormulaParser.value_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var IDENT185 = null;
         var number181 = null;
         var bool182 = null;
         var string183 = null;
         var material184 = null;
         var primitive186 = null;
         var array187 = null;
         var anonFunctionDef188 = null;
         var newObject189 = null;

        var IDENT185_tree=null;

        try {
            // /Library/WebServer/Documents/calc/Formula.g:284:2: ( number | bool | string | material | IDENT | primitive | array | anonFunctionDef | newObject )
            var alt57=9;
            alt57 = this.dfa57.predict(this.input);
            switch (alt57) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:284:5: number
                    root_0 = this.adaptor.nil();

                    this.pushFollow(FormulaParser.FOLLOW_number_in_value1823);
                    number181=this.number();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, number181.getTree());


                    break;
                case 2 :
                    // /Library/WebServer/Documents/calc/Formula.g:285:5: bool
                    root_0 = this.adaptor.nil();

                    this.pushFollow(FormulaParser.FOLLOW_bool_in_value1829);
                    bool182=this.bool();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, bool182.getTree());


                    break;
                case 3 :
                    // /Library/WebServer/Documents/calc/Formula.g:286:5: string
                    root_0 = this.adaptor.nil();

                    this.pushFollow(FormulaParser.FOLLOW_string_in_value1835);
                    string183=this.string();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, string183.getTree());


                    break;
                case 4 :
                    // /Library/WebServer/Documents/calc/Formula.g:287:5: material
                    root_0 = this.adaptor.nil();

                    this.pushFollow(FormulaParser.FOLLOW_material_in_value1841);
                    material184=this.material();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, material184.getTree());


                    break;
                case 5 :
                    // /Library/WebServer/Documents/calc/Formula.g:288:4: IDENT
                    root_0 = this.adaptor.nil();

                    IDENT185=this.match(this.input,IDENT,FormulaParser.FOLLOW_IDENT_in_value1846); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    IDENT185_tree = this.adaptor.create(IDENT185);
                    this.adaptor.addChild(root_0, IDENT185_tree);
                    }


                    break;
                case 6 :
                    // /Library/WebServer/Documents/calc/Formula.g:289:4: primitive
                    root_0 = this.adaptor.nil();

                    this.pushFollow(FormulaParser.FOLLOW_primitive_in_value1851);
                    primitive186=this.primitive();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, primitive186.getTree());


                    break;
                case 7 :
                    // /Library/WebServer/Documents/calc/Formula.g:290:4: array
                    root_0 = this.adaptor.nil();

                    this.pushFollow(FormulaParser.FOLLOW_array_in_value1856);
                    array187=this.array();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, array187.getTree());


                    break;
                case 8 :
                    // /Library/WebServer/Documents/calc/Formula.g:291:4: anonFunctionDef
                    root_0 = this.adaptor.nil();

                    this.pushFollow(FormulaParser.FOLLOW_anonFunctionDef_in_value1861);
                    anonFunctionDef188=this.anonFunctionDef();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, anonFunctionDef188.getTree());


                    break;
                case 9 :
                    // /Library/WebServer/Documents/calc/Formula.g:292:4: newObject
                    root_0 = this.adaptor.nil();

                    this.pushFollow(FormulaParser.FOLLOW_newObject_in_value1866);
                    newObject189=this.newObject();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, newObject189.getTree());


                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    newObject_return: (function() {
        FormulaParser.newObject_return = function(){};
        org.antlr.lang.extend(FormulaParser.newObject_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // /Library/WebServer/Documents/calc/Formula.g:295:1: newObject : NEWSTATEMENT IDENT ( funCall )? -> ^( NEW IDENT ( funCall )? ) ;
    // $ANTLR start "newObject"
    newObject: function() {
        var retval = new FormulaParser.newObject_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var NEWSTATEMENT190 = null;
        var IDENT191 = null;
         var funCall192 = null;

        var NEWSTATEMENT190_tree=null;
        var IDENT191_tree=null;
        var stream_IDENT=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token IDENT");
        var stream_NEWSTATEMENT=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token NEWSTATEMENT");
        var stream_funCall=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule funCall");
        try {
            // /Library/WebServer/Documents/calc/Formula.g:296:1: ( NEWSTATEMENT IDENT ( funCall )? -> ^( NEW IDENT ( funCall )? ) )
            // /Library/WebServer/Documents/calc/Formula.g:296:3: NEWSTATEMENT IDENT ( funCall )?
            NEWSTATEMENT190=this.match(this.input,NEWSTATEMENT,FormulaParser.FOLLOW_NEWSTATEMENT_in_newObject1876); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_NEWSTATEMENT.add(NEWSTATEMENT190);

            IDENT191=this.match(this.input,IDENT,FormulaParser.FOLLOW_IDENT_in_newObject1878); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_IDENT.add(IDENT191);

            // /Library/WebServer/Documents/calc/Formula.g:296:22: ( funCall )?
            var alt58=2;
            alt58 = this.dfa58.predict(this.input);
            switch (alt58) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:0:0: funCall
                    this.pushFollow(FormulaParser.FOLLOW_funCall_in_newObject1880);
                    funCall192=this.funCall();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) stream_funCall.add(funCall192.getTree());


                    break;

            }



            // AST REWRITE
            // elements: funCall, IDENT
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            if ( this.state.backtracking===0 ) {
            retval.tree = root_0;
            var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

            root_0 = this.adaptor.nil();
            // 296:31: -> ^( NEW IDENT ( funCall )? )
            {
                // /Library/WebServer/Documents/calc/Formula.g:296:34: ^( NEW IDENT ( funCall )? )
                {
                var root_1 = this.adaptor.nil();
                root_1 = this.adaptor.becomeRoot(this.adaptor.create(NEW, "NEW"), root_1);

                this.adaptor.addChild(root_1, stream_IDENT.nextNode());
                // /Library/WebServer/Documents/calc/Formula.g:296:46: ( funCall )?
                if ( stream_funCall.hasNext() ) {
                    this.adaptor.addChild(root_1, stream_funCall.nextTree());

                }
                stream_funCall.reset();

                this.adaptor.addChild(root_0, root_1);
                }

            }

            retval.tree = root_0;}


            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    defaultValue_return: (function() {
        FormulaParser.defaultValue_return = function(){};
        org.antlr.lang.extend(FormulaParser.defaultValue_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // /Library/WebServer/Documents/calc/Formula.g:299:1: defaultValue : ( negnumber | number | bool | string | array );
    // $ANTLR start "defaultValue"
    defaultValue: function() {
        var retval = new FormulaParser.defaultValue_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var negnumber193 = null;
         var number194 = null;
         var bool195 = null;
         var string196 = null;
         var array197 = null;


        try {
            // /Library/WebServer/Documents/calc/Formula.g:300:2: ( negnumber | number | bool | string | array )
            var alt59=5;
            switch ( this.input.LA(1) ) {
            case MINUS:
                alt59=1;
                break;
            case INTEGER:
            case FLOAT:
                alt59=2;
                break;
            case TRUE:
            case FALSE:
                alt59=3;
                break;
            case STRING:
                alt59=4;
                break;
            case LARR:
            case LCURL:
                alt59=5;
                break;
            default:
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 59, 0, this.input);

                throw nvae;
            }

            switch (alt59) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:300:5: negnumber
                    root_0 = this.adaptor.nil();

                    this.pushFollow(FormulaParser.FOLLOW_negnumber_in_defaultValue1906);
                    negnumber193=this.negnumber();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, negnumber193.getTree());


                    break;
                case 2 :
                    // /Library/WebServer/Documents/calc/Formula.g:301:5: number
                    root_0 = this.adaptor.nil();

                    this.pushFollow(FormulaParser.FOLLOW_number_in_defaultValue1912);
                    number194=this.number();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, number194.getTree());


                    break;
                case 3 :
                    // /Library/WebServer/Documents/calc/Formula.g:302:5: bool
                    root_0 = this.adaptor.nil();

                    this.pushFollow(FormulaParser.FOLLOW_bool_in_defaultValue1918);
                    bool195=this.bool();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, bool195.getTree());


                    break;
                case 4 :
                    // /Library/WebServer/Documents/calc/Formula.g:303:5: string
                    root_0 = this.adaptor.nil();

                    this.pushFollow(FormulaParser.FOLLOW_string_in_defaultValue1924);
                    string196=this.string();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, string196.getTree());


                    break;
                case 5 :
                    // /Library/WebServer/Documents/calc/Formula.g:304:5: array
                    root_0 = this.adaptor.nil();

                    this.pushFollow(FormulaParser.FOLLOW_array_in_defaultValue1930);
                    array197=this.array();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, array197.getTree());


                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    array_return: (function() {
        FormulaParser.array_return = function(){};
        org.antlr.lang.extend(FormulaParser.array_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // /Library/WebServer/Documents/calc/Formula.g:307:1: array : ( LARR ( NEWLINE )* ( label ( NEWLINE )* ( ',' ( NEWLINE )* label ( NEWLINE )* )* )? ( NEWLINE )* RARR -> ^( ARRAY ( label )* ) | LCURL ( NEWLINE )* ( label ( NEWLINE )* ( ',' ( NEWLINE )* label ( NEWLINE )* )* )? ( NEWLINE )* RCURL -> ^( ARRAY ( label )* ) );
    // $ANTLR start "array"
    array: function() {
        var retval = new FormulaParser.array_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var LARR198 = null;
        var NEWLINE199 = null;
        var NEWLINE201 = null;
        var char_literal202 = null;
        var NEWLINE203 = null;
        var NEWLINE205 = null;
        var NEWLINE206 = null;
        var RARR207 = null;
        var LCURL208 = null;
        var NEWLINE209 = null;
        var NEWLINE211 = null;
        var char_literal212 = null;
        var NEWLINE213 = null;
        var NEWLINE215 = null;
        var NEWLINE216 = null;
        var RCURL217 = null;
         var label200 = null;
         var label204 = null;
         var label210 = null;
         var label214 = null;

        var LARR198_tree=null;
        var NEWLINE199_tree=null;
        var NEWLINE201_tree=null;
        var char_literal202_tree=null;
        var NEWLINE203_tree=null;
        var NEWLINE205_tree=null;
        var NEWLINE206_tree=null;
        var RARR207_tree=null;
        var LCURL208_tree=null;
        var NEWLINE209_tree=null;
        var NEWLINE211_tree=null;
        var char_literal212_tree=null;
        var NEWLINE213_tree=null;
        var NEWLINE215_tree=null;
        var NEWLINE216_tree=null;
        var RCURL217_tree=null;
        var stream_LCURL=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token LCURL");
        var stream_NEWLINE=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token NEWLINE");
        var stream_RARR=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token RARR");
        var stream_COMMA=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token COMMA");
        var stream_LARR=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token LARR");
        var stream_RCURL=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token RCURL");
        var stream_label=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule label");
        try {
            // /Library/WebServer/Documents/calc/Formula.g:308:2: ( LARR ( NEWLINE )* ( label ( NEWLINE )* ( ',' ( NEWLINE )* label ( NEWLINE )* )* )? ( NEWLINE )* RARR -> ^( ARRAY ( label )* ) | LCURL ( NEWLINE )* ( label ( NEWLINE )* ( ',' ( NEWLINE )* label ( NEWLINE )* )* )? ( NEWLINE )* RCURL -> ^( ARRAY ( label )* ) )
            var alt74=2;
            var LA74_0 = this.input.LA(1);

            if ( (LA74_0==LARR) ) {
                alt74=1;
            }
            else if ( (LA74_0==LCURL) ) {
                alt74=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 74, 0, this.input);

                throw nvae;
            }
            switch (alt74) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:309:2: LARR ( NEWLINE )* ( label ( NEWLINE )* ( ',' ( NEWLINE )* label ( NEWLINE )* )* )? ( NEWLINE )* RARR
                    LARR198=this.match(this.input,LARR,FormulaParser.FOLLOW_LARR_in_array1944); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_LARR.add(LARR198);

                    // /Library/WebServer/Documents/calc/Formula.g:309:7: ( NEWLINE )*
                    loop60:
                    do {
                        var alt60=2;
                        var LA60_0 = this.input.LA(1);

                        if ( (LA60_0==NEWLINE) ) {
                            var LA60_2 = this.input.LA(2);

                            if ( (this.synpred85_Formula()) ) {
                                alt60=1;
                            }


                        }


                        switch (alt60) {
                        case 1 :
                            // /Library/WebServer/Documents/calc/Formula.g:0:0: NEWLINE
                            NEWLINE199=this.match(this.input,NEWLINE,FormulaParser.FOLLOW_NEWLINE_in_array1946); if (this.state.failed) return retval; 
                            if ( this.state.backtracking===0 ) stream_NEWLINE.add(NEWLINE199);



                            break;

                        default :
                            break loop60;
                        }
                    } while (true);

                    // /Library/WebServer/Documents/calc/Formula.g:309:16: ( label ( NEWLINE )* ( ',' ( NEWLINE )* label ( NEWLINE )* )* )?
                    var alt65=2;
                    alt65 = this.dfa65.predict(this.input);
                    switch (alt65) {
                        case 1 :
                            // /Library/WebServer/Documents/calc/Formula.g:309:17: label ( NEWLINE )* ( ',' ( NEWLINE )* label ( NEWLINE )* )*
                            this.pushFollow(FormulaParser.FOLLOW_label_in_array1950);
                            label200=this.label();

                            this.state._fsp--;
                            if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) stream_label.add(label200.getTree());
                            // /Library/WebServer/Documents/calc/Formula.g:309:23: ( NEWLINE )*
                            loop61:
                            do {
                                var alt61=2;
                                var LA61_0 = this.input.LA(1);

                                if ( (LA61_0==NEWLINE) ) {
                                    var LA61_2 = this.input.LA(2);

                                    if ( (this.synpred86_Formula()) ) {
                                        alt61=1;
                                    }


                                }


                                switch (alt61) {
                                case 1 :
                                    // /Library/WebServer/Documents/calc/Formula.g:0:0: NEWLINE
                                    NEWLINE201=this.match(this.input,NEWLINE,FormulaParser.FOLLOW_NEWLINE_in_array1952); if (this.state.failed) return retval; 
                                    if ( this.state.backtracking===0 ) stream_NEWLINE.add(NEWLINE201);



                                    break;

                                default :
                                    break loop61;
                                }
                            } while (true);

                            // /Library/WebServer/Documents/calc/Formula.g:309:32: ( ',' ( NEWLINE )* label ( NEWLINE )* )*
                            loop64:
                            do {
                                var alt64=2;
                                var LA64_0 = this.input.LA(1);

                                if ( (LA64_0==COMMA) ) {
                                    alt64=1;
                                }


                                switch (alt64) {
                                case 1 :
                                    // /Library/WebServer/Documents/calc/Formula.g:309:33: ',' ( NEWLINE )* label ( NEWLINE )*
                                    char_literal202=this.match(this.input,COMMA,FormulaParser.FOLLOW_COMMA_in_array1956); if (this.state.failed) return retval; 
                                    if ( this.state.backtracking===0 ) stream_COMMA.add(char_literal202);

                                    // /Library/WebServer/Documents/calc/Formula.g:309:37: ( NEWLINE )*
                                    loop62:
                                    do {
                                        var alt62=2;
                                        var LA62_0 = this.input.LA(1);

                                        if ( (LA62_0==NEWLINE) ) {
                                            var LA62_2 = this.input.LA(2);

                                            if ( (this.synpred87_Formula()) ) {
                                                alt62=1;
                                            }


                                        }


                                        switch (alt62) {
                                        case 1 :
                                            // /Library/WebServer/Documents/calc/Formula.g:0:0: NEWLINE
                                            NEWLINE203=this.match(this.input,NEWLINE,FormulaParser.FOLLOW_NEWLINE_in_array1958); if (this.state.failed) return retval; 
                                            if ( this.state.backtracking===0 ) stream_NEWLINE.add(NEWLINE203);



                                            break;

                                        default :
                                            break loop62;
                                        }
                                    } while (true);

                                    this.pushFollow(FormulaParser.FOLLOW_label_in_array1961);
                                    label204=this.label();

                                    this.state._fsp--;
                                    if (this.state.failed) return retval;
                                    if ( this.state.backtracking===0 ) stream_label.add(label204.getTree());
                                    // /Library/WebServer/Documents/calc/Formula.g:309:52: ( NEWLINE )*
                                    loop63:
                                    do {
                                        var alt63=2;
                                        var LA63_0 = this.input.LA(1);

                                        if ( (LA63_0==NEWLINE) ) {
                                            var LA63_1 = this.input.LA(2);

                                            if ( (this.synpred88_Formula()) ) {
                                                alt63=1;
                                            }


                                        }


                                        switch (alt63) {
                                        case 1 :
                                            // /Library/WebServer/Documents/calc/Formula.g:0:0: NEWLINE
                                            NEWLINE205=this.match(this.input,NEWLINE,FormulaParser.FOLLOW_NEWLINE_in_array1963); if (this.state.failed) return retval; 
                                            if ( this.state.backtracking===0 ) stream_NEWLINE.add(NEWLINE205);



                                            break;

                                        default :
                                            break loop63;
                                        }
                                    } while (true);



                                    break;

                                default :
                                    break loop64;
                                }
                            } while (true);



                            break;

                    }

                    // /Library/WebServer/Documents/calc/Formula.g:309:65: ( NEWLINE )*
                    loop66:
                    do {
                        var alt66=2;
                        var LA66_0 = this.input.LA(1);

                        if ( (LA66_0==NEWLINE) ) {
                            alt66=1;
                        }


                        switch (alt66) {
                        case 1 :
                            // /Library/WebServer/Documents/calc/Formula.g:0:0: NEWLINE
                            NEWLINE206=this.match(this.input,NEWLINE,FormulaParser.FOLLOW_NEWLINE_in_array1970); if (this.state.failed) return retval; 
                            if ( this.state.backtracking===0 ) stream_NEWLINE.add(NEWLINE206);



                            break;

                        default :
                            break loop66;
                        }
                    } while (true);

                    RARR207=this.match(this.input,RARR,FormulaParser.FOLLOW_RARR_in_array1973); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_RARR.add(RARR207);



                    // AST REWRITE
                    // elements: label
                    // token labels: 
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: 
                    if ( this.state.backtracking===0 ) {
                    retval.tree = root_0;
                    var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

                    root_0 = this.adaptor.nil();
                    // 309:79: -> ^( ARRAY ( label )* )
                    {
                        // /Library/WebServer/Documents/calc/Formula.g:309:82: ^( ARRAY ( label )* )
                        {
                        var root_1 = this.adaptor.nil();
                        root_1 = this.adaptor.becomeRoot(this.adaptor.create(ARRAY, "ARRAY"), root_1);

                        // /Library/WebServer/Documents/calc/Formula.g:309:90: ( label )*
                        while ( stream_label.hasNext() ) {
                            this.adaptor.addChild(root_1, stream_label.nextTree());

                        }
                        stream_label.reset();

                        this.adaptor.addChild(root_0, root_1);
                        }

                    }

                    retval.tree = root_0;}

                    break;
                case 2 :
                    // /Library/WebServer/Documents/calc/Formula.g:310:4: LCURL ( NEWLINE )* ( label ( NEWLINE )* ( ',' ( NEWLINE )* label ( NEWLINE )* )* )? ( NEWLINE )* RCURL
                    LCURL208=this.match(this.input,LCURL,FormulaParser.FOLLOW_LCURL_in_array1987); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_LCURL.add(LCURL208);

                    // /Library/WebServer/Documents/calc/Formula.g:310:10: ( NEWLINE )*
                    loop67:
                    do {
                        var alt67=2;
                        var LA67_0 = this.input.LA(1);

                        if ( (LA67_0==NEWLINE) ) {
                            var LA67_2 = this.input.LA(2);

                            if ( (this.synpred93_Formula()) ) {
                                alt67=1;
                            }


                        }


                        switch (alt67) {
                        case 1 :
                            // /Library/WebServer/Documents/calc/Formula.g:0:0: NEWLINE
                            NEWLINE209=this.match(this.input,NEWLINE,FormulaParser.FOLLOW_NEWLINE_in_array1989); if (this.state.failed) return retval; 
                            if ( this.state.backtracking===0 ) stream_NEWLINE.add(NEWLINE209);



                            break;

                        default :
                            break loop67;
                        }
                    } while (true);

                    // /Library/WebServer/Documents/calc/Formula.g:310:19: ( label ( NEWLINE )* ( ',' ( NEWLINE )* label ( NEWLINE )* )* )?
                    var alt72=2;
                    alt72 = this.dfa72.predict(this.input);
                    switch (alt72) {
                        case 1 :
                            // /Library/WebServer/Documents/calc/Formula.g:310:20: label ( NEWLINE )* ( ',' ( NEWLINE )* label ( NEWLINE )* )*
                            this.pushFollow(FormulaParser.FOLLOW_label_in_array1993);
                            label210=this.label();

                            this.state._fsp--;
                            if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) stream_label.add(label210.getTree());
                            // /Library/WebServer/Documents/calc/Formula.g:310:26: ( NEWLINE )*
                            loop68:
                            do {
                                var alt68=2;
                                var LA68_0 = this.input.LA(1);

                                if ( (LA68_0==NEWLINE) ) {
                                    var LA68_2 = this.input.LA(2);

                                    if ( (this.synpred94_Formula()) ) {
                                        alt68=1;
                                    }


                                }


                                switch (alt68) {
                                case 1 :
                                    // /Library/WebServer/Documents/calc/Formula.g:0:0: NEWLINE
                                    NEWLINE211=this.match(this.input,NEWLINE,FormulaParser.FOLLOW_NEWLINE_in_array1995); if (this.state.failed) return retval; 
                                    if ( this.state.backtracking===0 ) stream_NEWLINE.add(NEWLINE211);



                                    break;

                                default :
                                    break loop68;
                                }
                            } while (true);

                            // /Library/WebServer/Documents/calc/Formula.g:310:34: ( ',' ( NEWLINE )* label ( NEWLINE )* )*
                            loop71:
                            do {
                                var alt71=2;
                                var LA71_0 = this.input.LA(1);

                                if ( (LA71_0==COMMA) ) {
                                    alt71=1;
                                }


                                switch (alt71) {
                                case 1 :
                                    // /Library/WebServer/Documents/calc/Formula.g:310:35: ',' ( NEWLINE )* label ( NEWLINE )*
                                    char_literal212=this.match(this.input,COMMA,FormulaParser.FOLLOW_COMMA_in_array1998); if (this.state.failed) return retval; 
                                    if ( this.state.backtracking===0 ) stream_COMMA.add(char_literal212);

                                    // /Library/WebServer/Documents/calc/Formula.g:310:39: ( NEWLINE )*
                                    loop69:
                                    do {
                                        var alt69=2;
                                        var LA69_0 = this.input.LA(1);

                                        if ( (LA69_0==NEWLINE) ) {
                                            var LA69_2 = this.input.LA(2);

                                            if ( (this.synpred95_Formula()) ) {
                                                alt69=1;
                                            }


                                        }


                                        switch (alt69) {
                                        case 1 :
                                            // /Library/WebServer/Documents/calc/Formula.g:0:0: NEWLINE
                                            NEWLINE213=this.match(this.input,NEWLINE,FormulaParser.FOLLOW_NEWLINE_in_array2000); if (this.state.failed) return retval; 
                                            if ( this.state.backtracking===0 ) stream_NEWLINE.add(NEWLINE213);



                                            break;

                                        default :
                                            break loop69;
                                        }
                                    } while (true);

                                    this.pushFollow(FormulaParser.FOLLOW_label_in_array2003);
                                    label214=this.label();

                                    this.state._fsp--;
                                    if (this.state.failed) return retval;
                                    if ( this.state.backtracking===0 ) stream_label.add(label214.getTree());
                                    // /Library/WebServer/Documents/calc/Formula.g:310:54: ( NEWLINE )*
                                    loop70:
                                    do {
                                        var alt70=2;
                                        var LA70_0 = this.input.LA(1);

                                        if ( (LA70_0==NEWLINE) ) {
                                            var LA70_1 = this.input.LA(2);

                                            if ( (this.synpred96_Formula()) ) {
                                                alt70=1;
                                            }


                                        }


                                        switch (alt70) {
                                        case 1 :
                                            // /Library/WebServer/Documents/calc/Formula.g:0:0: NEWLINE
                                            NEWLINE215=this.match(this.input,NEWLINE,FormulaParser.FOLLOW_NEWLINE_in_array2005); if (this.state.failed) return retval; 
                                            if ( this.state.backtracking===0 ) stream_NEWLINE.add(NEWLINE215);



                                            break;

                                        default :
                                            break loop70;
                                        }
                                    } while (true);



                                    break;

                                default :
                                    break loop71;
                                }
                            } while (true);



                            break;

                    }

                    // /Library/WebServer/Documents/calc/Formula.g:310:67: ( NEWLINE )*
                    loop73:
                    do {
                        var alt73=2;
                        var LA73_0 = this.input.LA(1);

                        if ( (LA73_0==NEWLINE) ) {
                            alt73=1;
                        }


                        switch (alt73) {
                        case 1 :
                            // /Library/WebServer/Documents/calc/Formula.g:0:0: NEWLINE
                            NEWLINE216=this.match(this.input,NEWLINE,FormulaParser.FOLLOW_NEWLINE_in_array2012); if (this.state.failed) return retval; 
                            if ( this.state.backtracking===0 ) stream_NEWLINE.add(NEWLINE216);



                            break;

                        default :
                            break loop73;
                        }
                    } while (true);

                    RCURL217=this.match(this.input,RCURL,FormulaParser.FOLLOW_RCURL_in_array2015); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_RCURL.add(RCURL217);



                    // AST REWRITE
                    // elements: label
                    // token labels: 
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: 
                    if ( this.state.backtracking===0 ) {
                    retval.tree = root_0;
                    var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

                    root_0 = this.adaptor.nil();
                    // 310:82: -> ^( ARRAY ( label )* )
                    {
                        // /Library/WebServer/Documents/calc/Formula.g:310:85: ^( ARRAY ( label )* )
                        {
                        var root_1 = this.adaptor.nil();
                        root_1 = this.adaptor.becomeRoot(this.adaptor.create(ARRAY, "ARRAY"), root_1);

                        // /Library/WebServer/Documents/calc/Formula.g:310:93: ( label )*
                        while ( stream_label.hasNext() ) {
                            this.adaptor.addChild(root_1, stream_label.nextTree());

                        }
                        stream_label.reset();

                        this.adaptor.addChild(root_0, root_1);
                        }

                    }

                    retval.tree = root_0;}

                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    selector_return: (function() {
        FormulaParser.selector_return = function(){};
        org.antlr.lang.extend(FormulaParser.selector_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // /Library/WebServer/Documents/calc/Formula.g:313:1: selector : ( minarray | dotselector ) -> ^( SELECTOR ( minarray )? ( dotselector )? ) ;
    // $ANTLR start "selector"
    selector: function() {
        var retval = new FormulaParser.selector_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var minarray218 = null;
         var dotselector219 = null;

        var stream_dotselector=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule dotselector");
        var stream_minarray=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule minarray");
        try {
            // /Library/WebServer/Documents/calc/Formula.g:314:2: ( ( minarray | dotselector ) -> ^( SELECTOR ( minarray )? ( dotselector )? ) )
            // /Library/WebServer/Documents/calc/Formula.g:314:4: ( minarray | dotselector )
            // /Library/WebServer/Documents/calc/Formula.g:314:4: ( minarray | dotselector )
            var alt75=2;
            var LA75_0 = this.input.LA(1);

            if ( (LA75_0==LARR||LA75_0==LCURL) ) {
                alt75=1;
            }
            else if ( (LA75_0==116) ) {
                alt75=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 75, 0, this.input);

                throw nvae;
            }
            switch (alt75) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:314:5: minarray
                    this.pushFollow(FormulaParser.FOLLOW_minarray_in_selector2036);
                    minarray218=this.minarray();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) stream_minarray.add(minarray218.getTree());


                    break;
                case 2 :
                    // /Library/WebServer/Documents/calc/Formula.g:314:16: dotselector
                    this.pushFollow(FormulaParser.FOLLOW_dotselector_in_selector2040);
                    dotselector219=this.dotselector();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) stream_dotselector.add(dotselector219.getTree());


                    break;

            }



            // AST REWRITE
            // elements: minarray, dotselector
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            if ( this.state.backtracking===0 ) {
            retval.tree = root_0;
            var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

            root_0 = this.adaptor.nil();
            // 314:29: -> ^( SELECTOR ( minarray )? ( dotselector )? )
            {
                // /Library/WebServer/Documents/calc/Formula.g:314:32: ^( SELECTOR ( minarray )? ( dotselector )? )
                {
                var root_1 = this.adaptor.nil();
                root_1 = this.adaptor.becomeRoot(this.adaptor.create(SELECTOR, "SELECTOR"), root_1);

                // /Library/WebServer/Documents/calc/Formula.g:314:43: ( minarray )?
                if ( stream_minarray.hasNext() ) {
                    this.adaptor.addChild(root_1, stream_minarray.nextTree());

                }
                stream_minarray.reset();
                // /Library/WebServer/Documents/calc/Formula.g:314:53: ( dotselector )?
                if ( stream_dotselector.hasNext() ) {
                    this.adaptor.addChild(root_1, stream_dotselector.nextTree());

                }
                stream_dotselector.reset();

                this.adaptor.addChild(root_0, root_1);
                }

            }

            retval.tree = root_0;}


            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    minarray_return: (function() {
        FormulaParser.minarray_return = function(){};
        org.antlr.lang.extend(FormulaParser.minarray_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // /Library/WebServer/Documents/calc/Formula.g:317:1: minarray : ( LARR ( logicalExpression | MULT ) ( COMMA ( logicalExpression | MULT ) )* RARR | LCURL ( logicalExpression | MULT ) ( COMMA ( logicalExpression | MULT ) )* RCURL );
    // $ANTLR start "minarray"
    minarray: function() {
        var retval = new FormulaParser.minarray_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var LARR220 = null;
        var MULT222 = null;
        var COMMA223 = null;
        var MULT225 = null;
        var RARR226 = null;
        var LCURL227 = null;
        var MULT229 = null;
        var COMMA230 = null;
        var MULT232 = null;
        var RCURL233 = null;
         var logicalExpression221 = null;
         var logicalExpression224 = null;
         var logicalExpression228 = null;
         var logicalExpression231 = null;

        var LARR220_tree=null;
        var MULT222_tree=null;
        var COMMA223_tree=null;
        var MULT225_tree=null;
        var RARR226_tree=null;
        var LCURL227_tree=null;
        var MULT229_tree=null;
        var COMMA230_tree=null;
        var MULT232_tree=null;
        var RCURL233_tree=null;

        try {
            // /Library/WebServer/Documents/calc/Formula.g:318:2: ( LARR ( logicalExpression | MULT ) ( COMMA ( logicalExpression | MULT ) )* RARR | LCURL ( logicalExpression | MULT ) ( COMMA ( logicalExpression | MULT ) )* RCURL )
            var alt82=2;
            var LA82_0 = this.input.LA(1);

            if ( (LA82_0==LARR) ) {
                alt82=1;
            }
            else if ( (LA82_0==LCURL) ) {
                alt82=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 82, 0, this.input);

                throw nvae;
            }
            switch (alt82) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:319:2: LARR ( logicalExpression | MULT ) ( COMMA ( logicalExpression | MULT ) )* RARR
                    root_0 = this.adaptor.nil();

                    LARR220=this.match(this.input,LARR,FormulaParser.FOLLOW_LARR_in_minarray2067); if (this.state.failed) return retval;
                    // /Library/WebServer/Documents/calc/Formula.g:319:9: ( logicalExpression | MULT )
                    var alt76=2;
                    var LA76_0 = this.input.LA(1);

                    if ( (LA76_0==FUNCTIONSTATEMENT||LA76_0==NEWSTATEMENT||LA76_0==IDENT||LA76_0==PRIMITIVE||LA76_0==MINUS||(LA76_0>=NOT && LA76_0<=LARR)||LA76_0==LCURL||(LA76_0>=STRING && LA76_0<=FALSE)||LA76_0==113) ) {
                        alt76=1;
                    }
                    else if ( (LA76_0==MULT) ) {
                        alt76=2;
                    }
                    else {
                        if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        var nvae =
                            new org.antlr.runtime.NoViableAltException("", 76, 0, this.input);

                        throw nvae;
                    }
                    switch (alt76) {
                        case 1 :
                            // /Library/WebServer/Documents/calc/Formula.g:319:10: logicalExpression
                            this.pushFollow(FormulaParser.FOLLOW_logicalExpression_in_minarray2072);
                            logicalExpression221=this.logicalExpression();

                            this.state._fsp--;
                            if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, logicalExpression221.getTree());


                            break;
                        case 2 :
                            // /Library/WebServer/Documents/calc/Formula.g:319:28: MULT
                            MULT222=this.match(this.input,MULT,FormulaParser.FOLLOW_MULT_in_minarray2074); if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) {
                            MULT222_tree = this.adaptor.create(MULT222);
                            this.adaptor.addChild(root_0, MULT222_tree);
                            }


                            break;

                    }

                    // /Library/WebServer/Documents/calc/Formula.g:319:34: ( COMMA ( logicalExpression | MULT ) )*
                    loop78:
                    do {
                        var alt78=2;
                        var LA78_0 = this.input.LA(1);

                        if ( (LA78_0==COMMA) ) {
                            alt78=1;
                        }


                        switch (alt78) {
                        case 1 :
                            // /Library/WebServer/Documents/calc/Formula.g:319:35: COMMA ( logicalExpression | MULT )
                            COMMA223=this.match(this.input,COMMA,FormulaParser.FOLLOW_COMMA_in_minarray2078); if (this.state.failed) return retval;
                            // /Library/WebServer/Documents/calc/Formula.g:319:42: ( logicalExpression | MULT )
                            var alt77=2;
                            var LA77_0 = this.input.LA(1);

                            if ( (LA77_0==FUNCTIONSTATEMENT||LA77_0==NEWSTATEMENT||LA77_0==IDENT||LA77_0==PRIMITIVE||LA77_0==MINUS||(LA77_0>=NOT && LA77_0<=LARR)||LA77_0==LCURL||(LA77_0>=STRING && LA77_0<=FALSE)||LA77_0==113) ) {
                                alt77=1;
                            }
                            else if ( (LA77_0==MULT) ) {
                                alt77=2;
                            }
                            else {
                                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                                var nvae =
                                    new org.antlr.runtime.NoViableAltException("", 77, 0, this.input);

                                throw nvae;
                            }
                            switch (alt77) {
                                case 1 :
                                    // /Library/WebServer/Documents/calc/Formula.g:319:43: logicalExpression
                                    this.pushFollow(FormulaParser.FOLLOW_logicalExpression_in_minarray2082);
                                    logicalExpression224=this.logicalExpression();

                                    this.state._fsp--;
                                    if (this.state.failed) return retval;
                                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, logicalExpression224.getTree());


                                    break;
                                case 2 :
                                    // /Library/WebServer/Documents/calc/Formula.g:319:61: MULT
                                    MULT225=this.match(this.input,MULT,FormulaParser.FOLLOW_MULT_in_minarray2084); if (this.state.failed) return retval;
                                    if ( this.state.backtracking===0 ) {
                                    MULT225_tree = this.adaptor.create(MULT225);
                                    this.adaptor.addChild(root_0, MULT225_tree);
                                    }


                                    break;

                            }



                            break;

                        default :
                            break loop78;
                        }
                    } while (true);

                    RARR226=this.match(this.input,RARR,FormulaParser.FOLLOW_RARR_in_minarray2091); if (this.state.failed) return retval;


                    break;
                case 2 :
                    // /Library/WebServer/Documents/calc/Formula.g:320:4: LCURL ( logicalExpression | MULT ) ( COMMA ( logicalExpression | MULT ) )* RCURL
                    root_0 = this.adaptor.nil();

                    LCURL227=this.match(this.input,LCURL,FormulaParser.FOLLOW_LCURL_in_minarray2097); if (this.state.failed) return retval;
                    // /Library/WebServer/Documents/calc/Formula.g:320:12: ( logicalExpression | MULT )
                    var alt79=2;
                    var LA79_0 = this.input.LA(1);

                    if ( (LA79_0==FUNCTIONSTATEMENT||LA79_0==NEWSTATEMENT||LA79_0==IDENT||LA79_0==PRIMITIVE||LA79_0==MINUS||(LA79_0>=NOT && LA79_0<=LARR)||LA79_0==LCURL||(LA79_0>=STRING && LA79_0<=FALSE)||LA79_0==113) ) {
                        alt79=1;
                    }
                    else if ( (LA79_0==MULT) ) {
                        alt79=2;
                    }
                    else {
                        if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        var nvae =
                            new org.antlr.runtime.NoViableAltException("", 79, 0, this.input);

                        throw nvae;
                    }
                    switch (alt79) {
                        case 1 :
                            // /Library/WebServer/Documents/calc/Formula.g:320:13: logicalExpression
                            this.pushFollow(FormulaParser.FOLLOW_logicalExpression_in_minarray2102);
                            logicalExpression228=this.logicalExpression();

                            this.state._fsp--;
                            if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, logicalExpression228.getTree());


                            break;
                        case 2 :
                            // /Library/WebServer/Documents/calc/Formula.g:320:31: MULT
                            MULT229=this.match(this.input,MULT,FormulaParser.FOLLOW_MULT_in_minarray2104); if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) {
                            MULT229_tree = this.adaptor.create(MULT229);
                            this.adaptor.addChild(root_0, MULT229_tree);
                            }


                            break;

                    }

                    // /Library/WebServer/Documents/calc/Formula.g:320:37: ( COMMA ( logicalExpression | MULT ) )*
                    loop81:
                    do {
                        var alt81=2;
                        var LA81_0 = this.input.LA(1);

                        if ( (LA81_0==COMMA) ) {
                            alt81=1;
                        }


                        switch (alt81) {
                        case 1 :
                            // /Library/WebServer/Documents/calc/Formula.g:320:38: COMMA ( logicalExpression | MULT )
                            COMMA230=this.match(this.input,COMMA,FormulaParser.FOLLOW_COMMA_in_minarray2108); if (this.state.failed) return retval;
                            // /Library/WebServer/Documents/calc/Formula.g:320:45: ( logicalExpression | MULT )
                            var alt80=2;
                            var LA80_0 = this.input.LA(1);

                            if ( (LA80_0==FUNCTIONSTATEMENT||LA80_0==NEWSTATEMENT||LA80_0==IDENT||LA80_0==PRIMITIVE||LA80_0==MINUS||(LA80_0>=NOT && LA80_0<=LARR)||LA80_0==LCURL||(LA80_0>=STRING && LA80_0<=FALSE)||LA80_0==113) ) {
                                alt80=1;
                            }
                            else if ( (LA80_0==MULT) ) {
                                alt80=2;
                            }
                            else {
                                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                                var nvae =
                                    new org.antlr.runtime.NoViableAltException("", 80, 0, this.input);

                                throw nvae;
                            }
                            switch (alt80) {
                                case 1 :
                                    // /Library/WebServer/Documents/calc/Formula.g:320:46: logicalExpression
                                    this.pushFollow(FormulaParser.FOLLOW_logicalExpression_in_minarray2112);
                                    logicalExpression231=this.logicalExpression();

                                    this.state._fsp--;
                                    if (this.state.failed) return retval;
                                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, logicalExpression231.getTree());


                                    break;
                                case 2 :
                                    // /Library/WebServer/Documents/calc/Formula.g:320:64: MULT
                                    MULT232=this.match(this.input,MULT,FormulaParser.FOLLOW_MULT_in_minarray2114); if (this.state.failed) return retval;
                                    if ( this.state.backtracking===0 ) {
                                    MULT232_tree = this.adaptor.create(MULT232);
                                    this.adaptor.addChild(root_0, MULT232_tree);
                                    }


                                    break;

                            }



                            break;

                        default :
                            break loop81;
                        }
                    } while (true);

                    RCURL233=this.match(this.input,RCURL,FormulaParser.FOLLOW_RCURL_in_minarray2121); if (this.state.failed) return retval;


                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    dotselector_return: (function() {
        FormulaParser.dotselector_return = function(){};
        org.antlr.lang.extend(FormulaParser.dotselector_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // /Library/WebServer/Documents/calc/Formula.g:322:1: dotselector : ( '.' arrayName )+ -> ^( DOTSELECTOR ( arrayName )+ ) ;
    // $ANTLR start "dotselector"
    dotselector: function() {
        var retval = new FormulaParser.dotselector_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var char_literal234 = null;
         var arrayName235 = null;

        var char_literal234_tree=null;
        var stream_116=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token 116");
        var stream_arrayName=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule arrayName");
        try {
            // /Library/WebServer/Documents/calc/Formula.g:323:2: ( ( '.' arrayName )+ -> ^( DOTSELECTOR ( arrayName )+ ) )
            // /Library/WebServer/Documents/calc/Formula.g:323:4: ( '.' arrayName )+
            // /Library/WebServer/Documents/calc/Formula.g:323:4: ( '.' arrayName )+
            var cnt83=0;
            loop83:
            do {
                var alt83=2;
                var LA83_0 = this.input.LA(1);

                if ( (LA83_0==116) ) {
                    var LA83_2 = this.input.LA(2);

                    if ( (this.synpred108_Formula()) ) {
                        alt83=1;
                    }


                }


                switch (alt83) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:323:5: '.' arrayName
                    char_literal234=this.match(this.input,116,FormulaParser.FOLLOW_116_in_dotselector2133); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_116.add(char_literal234);

                    this.pushFollow(FormulaParser.FOLLOW_arrayName_in_dotselector2135);
                    arrayName235=this.arrayName();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) stream_arrayName.add(arrayName235.getTree());


                    break;

                default :
                    if ( cnt83 >= 1 ) {
                        break loop83;
                    }
                    if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        var eee = new org.antlr.runtime.EarlyExitException(83, this.input);
                        throw eee;
                }
                cnt83++;
            } while (true);



            // AST REWRITE
            // elements: arrayName
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            if ( this.state.backtracking===0 ) {
            retval.tree = root_0;
            var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

            root_0 = this.adaptor.nil();
            // 323:21: -> ^( DOTSELECTOR ( arrayName )+ )
            {
                // /Library/WebServer/Documents/calc/Formula.g:323:24: ^( DOTSELECTOR ( arrayName )+ )
                {
                var root_1 = this.adaptor.nil();
                root_1 = this.adaptor.becomeRoot(this.adaptor.create(DOTSELECTOR, "DOTSELECTOR"), root_1);

                if ( !(stream_arrayName.hasNext()) ) {
                    throw new org.antlr.runtime.tree.RewriteEarlyExitException();
                }
                while ( stream_arrayName.hasNext() ) {
                    this.adaptor.addChild(root_1, stream_arrayName.nextTree());

                }
                stream_arrayName.reset();

                this.adaptor.addChild(root_0, root_1);
                }

            }

            retval.tree = root_0;}


            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    arrayName_return: (function() {
        FormulaParser.arrayName_return = function(){};
        org.antlr.lang.extend(FormulaParser.arrayName_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // /Library/WebServer/Documents/calc/Formula.g:326:1: arrayName : ( IDENT | STRING | MULT );
    // $ANTLR start "arrayName"
    arrayName: function() {
        var retval = new FormulaParser.arrayName_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var set236 = null;

        var set236_tree=null;

        try {
            // /Library/WebServer/Documents/calc/Formula.g:327:2: ( IDENT | STRING | MULT )
            // /Library/WebServer/Documents/calc/Formula.g:
            root_0 = this.adaptor.nil();

            set236=this.input.LT(1);
            if ( this.input.LA(1)==IDENT||this.input.LA(1)==MULT||this.input.LA(1)==STRING ) {
                this.input.consume();
                if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set236));
                this.state.errorRecovery=false;this.state.failed=false;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                throw mse;
            }




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    label_return: (function() {
        FormulaParser.label_return = function(){};
        org.antlr.lang.extend(FormulaParser.label_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // /Library/WebServer/Documents/calc/Formula.g:330:1: label : ( arrayName ( NEWLINE )* COLON )? ( NEWLINE )* logicalExpression -> ^( LABEL logicalExpression ( arrayName )? ) ;
    // $ANTLR start "label"
    label: function() {
        var retval = new FormulaParser.label_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var NEWLINE238 = null;
        var COLON239 = null;
        var NEWLINE240 = null;
         var arrayName237 = null;
         var logicalExpression241 = null;

        var NEWLINE238_tree=null;
        var COLON239_tree=null;
        var NEWLINE240_tree=null;
        var stream_COLON=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token COLON");
        var stream_NEWLINE=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token NEWLINE");
        var stream_arrayName=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule arrayName");
        var stream_logicalExpression=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule logicalExpression");
        try {
            // /Library/WebServer/Documents/calc/Formula.g:330:7: ( ( arrayName ( NEWLINE )* COLON )? ( NEWLINE )* logicalExpression -> ^( LABEL logicalExpression ( arrayName )? ) )
            // /Library/WebServer/Documents/calc/Formula.g:331:2: ( arrayName ( NEWLINE )* COLON )? ( NEWLINE )* logicalExpression
            // /Library/WebServer/Documents/calc/Formula.g:331:2: ( arrayName ( NEWLINE )* COLON )?
            var alt85=2;
            alt85 = this.dfa85.predict(this.input);
            switch (alt85) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:331:3: arrayName ( NEWLINE )* COLON
                    this.pushFollow(FormulaParser.FOLLOW_arrayName_in_label2173);
                    arrayName237=this.arrayName();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) stream_arrayName.add(arrayName237.getTree());
                    // /Library/WebServer/Documents/calc/Formula.g:331:13: ( NEWLINE )*
                    loop84:
                    do {
                        var alt84=2;
                        var LA84_0 = this.input.LA(1);

                        if ( (LA84_0==NEWLINE) ) {
                            alt84=1;
                        }


                        switch (alt84) {
                        case 1 :
                            // /Library/WebServer/Documents/calc/Formula.g:0:0: NEWLINE
                            NEWLINE238=this.match(this.input,NEWLINE,FormulaParser.FOLLOW_NEWLINE_in_label2175); if (this.state.failed) return retval; 
                            if ( this.state.backtracking===0 ) stream_NEWLINE.add(NEWLINE238);



                            break;

                        default :
                            break loop84;
                        }
                    } while (true);

                    COLON239=this.match(this.input,COLON,FormulaParser.FOLLOW_COLON_in_label2178); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_COLON.add(COLON239);



                    break;

            }

            // /Library/WebServer/Documents/calc/Formula.g:331:30: ( NEWLINE )*
            loop86:
            do {
                var alt86=2;
                var LA86_0 = this.input.LA(1);

                if ( (LA86_0==NEWLINE) ) {
                    alt86=1;
                }


                switch (alt86) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:0:0: NEWLINE
                    NEWLINE240=this.match(this.input,NEWLINE,FormulaParser.FOLLOW_NEWLINE_in_label2182); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_NEWLINE.add(NEWLINE240);



                    break;

                default :
                    break loop86;
                }
            } while (true);

            this.pushFollow(FormulaParser.FOLLOW_logicalExpression_in_label2185);
            logicalExpression241=this.logicalExpression();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) stream_logicalExpression.add(logicalExpression241.getTree());


            // AST REWRITE
            // elements: arrayName, logicalExpression
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            if ( this.state.backtracking===0 ) {
            retval.tree = root_0;
            var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

            root_0 = this.adaptor.nil();
            // 331:57: -> ^( LABEL logicalExpression ( arrayName )? )
            {
                // /Library/WebServer/Documents/calc/Formula.g:331:60: ^( LABEL logicalExpression ( arrayName )? )
                {
                var root_1 = this.adaptor.nil();
                root_1 = this.adaptor.becomeRoot(this.adaptor.create(LABEL, "LABEL"), root_1);

                this.adaptor.addChild(root_1, stream_logicalExpression.nextTree());
                // /Library/WebServer/Documents/calc/Formula.g:331:86: ( arrayName )?
                if ( stream_arrayName.hasNext() ) {
                    this.adaptor.addChild(root_1, stream_arrayName.nextTree());

                }
                stream_arrayName.reset();

                this.adaptor.addChild(root_0, root_1);
                }

            }

            retval.tree = root_0;}


            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    number_return: (function() {
        FormulaParser.number_return = function(){};
        org.antlr.lang.extend(FormulaParser.number_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // /Library/WebServer/Documents/calc/Formula.g:342:1: number : ( INTEGER | FLOAT );
    // $ANTLR start "number"
    number: function() {
        var retval = new FormulaParser.number_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var set242 = null;

        var set242_tree=null;

        try {
            // /Library/WebServer/Documents/calc/Formula.g:342:8: ( INTEGER | FLOAT )
            // /Library/WebServer/Documents/calc/Formula.g:
            root_0 = this.adaptor.nil();

            set242=this.input.LT(1);
            if ( (this.input.LA(1)>=INTEGER && this.input.LA(1)<=FLOAT) ) {
                this.input.consume();
                if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set242));
                this.state.errorRecovery=false;this.state.failed=false;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                throw mse;
            }




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    negnumber_return: (function() {
        FormulaParser.negnumber_return = function(){};
        org.antlr.lang.extend(FormulaParser.negnumber_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // /Library/WebServer/Documents/calc/Formula.g:344:1: negnumber : '-' number -> ^( NEGATE number ) ;
    // $ANTLR start "negnumber"
    negnumber: function() {
        var retval = new FormulaParser.negnumber_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var char_literal243 = null;
         var number244 = null;

        var char_literal243_tree=null;
        var stream_MINUS=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token MINUS");
        var stream_number=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule number");
        try {
            // /Library/WebServer/Documents/calc/Formula.g:344:11: ( '-' number -> ^( NEGATE number ) )
            // /Library/WebServer/Documents/calc/Formula.g:344:13: '-' number
            char_literal243=this.match(this.input,MINUS,FormulaParser.FOLLOW_MINUS_in_negnumber2261); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_MINUS.add(char_literal243);

            this.pushFollow(FormulaParser.FOLLOW_number_in_negnumber2263);
            number244=this.number();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) stream_number.add(number244.getTree());


            // AST REWRITE
            // elements: number
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            if ( this.state.backtracking===0 ) {
            retval.tree = root_0;
            var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

            root_0 = this.adaptor.nil();
            // 344:24: -> ^( NEGATE number )
            {
                // /Library/WebServer/Documents/calc/Formula.g:344:27: ^( NEGATE number )
                {
                var root_1 = this.adaptor.nil();
                root_1 = this.adaptor.becomeRoot(this.adaptor.create(NEGATE, "NEGATE"), root_1);

                this.adaptor.addChild(root_1, stream_number.nextTree());

                this.adaptor.addChild(root_0, root_1);
                }

            }

            retval.tree = root_0;}


            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    bool_return: (function() {
        FormulaParser.bool_return = function(){};
        org.antlr.lang.extend(FormulaParser.bool_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // /Library/WebServer/Documents/calc/Formula.g:354:1: bool : ( TRUE | FALSE );
    // $ANTLR start "bool"
    bool: function() {
        var retval = new FormulaParser.bool_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var set245 = null;

        var set245_tree=null;

        try {
            // /Library/WebServer/Documents/calc/Formula.g:355:2: ( TRUE | FALSE )
            // /Library/WebServer/Documents/calc/Formula.g:
            root_0 = this.adaptor.nil();

            set245=this.input.LT(1);
            if ( (this.input.LA(1)>=TRUE && this.input.LA(1)<=FALSE) ) {
                this.input.consume();
                if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set245));
                this.state.errorRecovery=false;this.state.failed=false;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                throw mse;
            }




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    material_return: (function() {
        FormulaParser.material_return = function(){};
        org.antlr.lang.extend(FormulaParser.material_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // /Library/WebServer/Documents/calc/Formula.g:367:1: material : LCURL additiveExpression {...}? unitMultiplicativeExpression RCURL -> ^( MATERIAL unitMultiplicativeExpression additiveExpression ) ;
    // $ANTLR start "material"
    material: function() {
        var retval = new FormulaParser.material_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var LCURL246 = null;
        var RCURL249 = null;
         var additiveExpression247 = null;
         var unitMultiplicativeExpression248 = null;

        var LCURL246_tree=null;
        var RCURL249_tree=null;
        var stream_LCURL=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token LCURL");
        var stream_RCURL=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token RCURL");
        var stream_unitMultiplicativeExpression=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule unitMultiplicativeExpression");
        var stream_additiveExpression=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule additiveExpression");
        try {
            // /Library/WebServer/Documents/calc/Formula.g:367:9: ( LCURL additiveExpression {...}? unitMultiplicativeExpression RCURL -> ^( MATERIAL unitMultiplicativeExpression additiveExpression ) )
            // /Library/WebServer/Documents/calc/Formula.g:367:12: LCURL additiveExpression {...}? unitMultiplicativeExpression RCURL
            LCURL246=this.match(this.input,LCURL,FormulaParser.FOLLOW_LCURL_in_material2415); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_LCURL.add(LCURL246);

            this.pushFollow(FormulaParser.FOLLOW_additiveExpression_in_material2417);
            additiveExpression247=this.additiveExpression();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) stream_additiveExpression.add(additiveExpression247.getTree());
            if ( !(( this.input.get(this.input.index()-1).getText()==" ")) ) {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                throw new org.antlr.runtime.FailedPredicateException(this.input, "material", " this.input.get(this.input.index()-1).getText()==\" \"");
            }
            this.pushFollow(FormulaParser.FOLLOW_unitMultiplicativeExpression_in_material2421);
            unitMultiplicativeExpression248=this.unitMultiplicativeExpression();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) stream_unitMultiplicativeExpression.add(unitMultiplicativeExpression248.getTree());
            RCURL249=this.match(this.input,RCURL,FormulaParser.FOLLOW_RCURL_in_material2423); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_RCURL.add(RCURL249);



            // AST REWRITE
            // elements: additiveExpression, unitMultiplicativeExpression
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            if ( this.state.backtracking===0 ) {
            retval.tree = root_0;
            var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

            root_0 = this.adaptor.nil();
            // 367:128: -> ^( MATERIAL unitMultiplicativeExpression additiveExpression )
            {
                // /Library/WebServer/Documents/calc/Formula.g:367:131: ^( MATERIAL unitMultiplicativeExpression additiveExpression )
                {
                var root_1 = this.adaptor.nil();
                root_1 = this.adaptor.becomeRoot(this.adaptor.create(MATERIAL, "MATERIAL"), root_1);

                this.adaptor.addChild(root_1, stream_unitMultiplicativeExpression.nextTree());
                this.adaptor.addChild(root_1, stream_additiveExpression.nextTree());

                this.adaptor.addChild(root_0, root_1);
                }

            }

            retval.tree = root_0;}


            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    unitMultiplicativeExpression_return: (function() {
        FormulaParser.unitMultiplicativeExpression_return = function(){};
        org.antlr.lang.extend(FormulaParser.unitMultiplicativeExpression_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // /Library/WebServer/Documents/calc/Formula.g:374:1: unitMultiplicativeExpression : unitInnerMultiplicativeExpression ( PER unitInnerMultiplicativeExpression )* ;
    // $ANTLR start "unitMultiplicativeExpression"
    unitMultiplicativeExpression: function() {
        var retval = new FormulaParser.unitMultiplicativeExpression_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var PER251 = null;
         var unitInnerMultiplicativeExpression250 = null;
         var unitInnerMultiplicativeExpression252 = null;

        var PER251_tree=null;

        try {
            // /Library/WebServer/Documents/calc/Formula.g:375:2: ( unitInnerMultiplicativeExpression ( PER unitInnerMultiplicativeExpression )* )
            // /Library/WebServer/Documents/calc/Formula.g:375:4: unitInnerMultiplicativeExpression ( PER unitInnerMultiplicativeExpression )*
            root_0 = this.adaptor.nil();

            this.pushFollow(FormulaParser.FOLLOW_unitInnerMultiplicativeExpression_in_unitMultiplicativeExpression2460);
            unitInnerMultiplicativeExpression250=this.unitInnerMultiplicativeExpression();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, unitInnerMultiplicativeExpression250.getTree());
            // /Library/WebServer/Documents/calc/Formula.g:375:38: ( PER unitInnerMultiplicativeExpression )*
            loop87:
            do {
                var alt87=2;
                var LA87_0 = this.input.LA(1);

                if ( (LA87_0==PER) ) {
                    alt87=1;
                }


                switch (alt87) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:375:40: PER unitInnerMultiplicativeExpression
                    PER251=this.match(this.input,PER,FormulaParser.FOLLOW_PER_in_unitMultiplicativeExpression2464); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    PER251_tree = this.adaptor.create(PER251);
                    root_0 = this.adaptor.becomeRoot(PER251_tree, root_0);
                    }
                    this.pushFollow(FormulaParser.FOLLOW_unitInnerMultiplicativeExpression_in_unitMultiplicativeExpression2467);
                    unitInnerMultiplicativeExpression252=this.unitInnerMultiplicativeExpression();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, unitInnerMultiplicativeExpression252.getTree());


                    break;

                default :
                    break loop87;
                }
            } while (true);




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    unitInnerMultiplicativeExpression_return: (function() {
        FormulaParser.unitInnerMultiplicativeExpression_return = function(){};
        org.antlr.lang.extend(FormulaParser.unitInnerMultiplicativeExpression_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // /Library/WebServer/Documents/calc/Formula.g:378:1: unitInnerMultiplicativeExpression : unitClump ( ( MULT | DIV ) unitClump )* ;
    // $ANTLR start "unitInnerMultiplicativeExpression"
    unitInnerMultiplicativeExpression: function() {
        var retval = new FormulaParser.unitInnerMultiplicativeExpression_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var set254 = null;
         var unitClump253 = null;
         var unitClump255 = null;

        var set254_tree=null;

        try {
            // /Library/WebServer/Documents/calc/Formula.g:379:2: ( unitClump ( ( MULT | DIV ) unitClump )* )
            // /Library/WebServer/Documents/calc/Formula.g:379:4: unitClump ( ( MULT | DIV ) unitClump )*
            root_0 = this.adaptor.nil();

            this.pushFollow(FormulaParser.FOLLOW_unitClump_in_unitInnerMultiplicativeExpression2483);
            unitClump253=this.unitClump();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, unitClump253.getTree());
            // /Library/WebServer/Documents/calc/Formula.g:379:14: ( ( MULT | DIV ) unitClump )*
            loop88:
            do {
                var alt88=2;
                var LA88_0 = this.input.LA(1);

                if ( ((LA88_0>=MULT && LA88_0<=DIV)) ) {
                    alt88=1;
                }


                switch (alt88) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:379:16: ( MULT | DIV ) unitClump
                    
                    set254=this.input.LT(1);
                    if ( (this.input.LA(1)>=MULT && this.input.LA(1)<=DIV) ) {
                        this.input.consume();
                        if ( this.state.backtracking===0 ) root_0 = this.adaptor.becomeRoot(this.adaptor.create(set254), root_0);
                        this.state.errorRecovery=false;this.state.failed=false;
                    }
                    else {
                        if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                        throw mse;
                    }

                    this.pushFollow(FormulaParser.FOLLOW_unitClump_in_unitInnerMultiplicativeExpression2494);
                    unitClump255=this.unitClump();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, unitClump255.getTree());


                    break;

                default :
                    break loop88;
                }
            } while (true);




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    unitClump_return: (function() {
        FormulaParser.unitClump_return = function(){};
        org.antlr.lang.extend(FormulaParser.unitClump_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // /Library/WebServer/Documents/calc/Formula.g:382:1: unitClump : ( ( INTEGER DIV ) unitPowerExpression ( CUBED )? ( SQUARED )? -> ^( UNITCLUMP unitPowerExpression NEGATE ( CUBED )* ( SQUARED )* ) | unitPowerExpression ( CUBED )? ( SQUARED )? -> ^( UNITCLUMP unitPowerExpression ( CUBED )* ( SQUARED )* ) );
    // $ANTLR start "unitClump"
    unitClump: function() {
        var retval = new FormulaParser.unitClump_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var INTEGER256 = null;
        var DIV257 = null;
        var CUBED259 = null;
        var SQUARED260 = null;
        var CUBED262 = null;
        var SQUARED263 = null;
         var unitPowerExpression258 = null;
         var unitPowerExpression261 = null;

        var INTEGER256_tree=null;
        var DIV257_tree=null;
        var CUBED259_tree=null;
        var SQUARED260_tree=null;
        var CUBED262_tree=null;
        var SQUARED263_tree=null;
        var stream_INTEGER=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token INTEGER");
        var stream_SQUARED=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token SQUARED");
        var stream_DIV=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token DIV");
        var stream_CUBED=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token CUBED");
        var stream_unitPowerExpression=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule unitPowerExpression");
        try {
            // /Library/WebServer/Documents/calc/Formula.g:383:2: ( ( INTEGER DIV ) unitPowerExpression ( CUBED )? ( SQUARED )? -> ^( UNITCLUMP unitPowerExpression NEGATE ( CUBED )* ( SQUARED )* ) | unitPowerExpression ( CUBED )? ( SQUARED )? -> ^( UNITCLUMP unitPowerExpression ( CUBED )* ( SQUARED )* ) )
            var alt93=2;
            var LA93_0 = this.input.LA(1);

            if ( (LA93_0==INTEGER) ) {
                alt93=1;
            }
            else if ( (LA93_0==IDENT||LA93_0==113) ) {
                alt93=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 93, 0, this.input);

                throw nvae;
            }
            switch (alt93) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:383:4: ( INTEGER DIV ) unitPowerExpression ( CUBED )? ( SQUARED )?
                    // /Library/WebServer/Documents/calc/Formula.g:383:4: ( INTEGER DIV )
                    // /Library/WebServer/Documents/calc/Formula.g:383:5: INTEGER DIV
                    INTEGER256=this.match(this.input,INTEGER,FormulaParser.FOLLOW_INTEGER_in_unitClump2510); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_INTEGER.add(INTEGER256);

                    DIV257=this.match(this.input,DIV,FormulaParser.FOLLOW_DIV_in_unitClump2512); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_DIV.add(DIV257);




                    this.pushFollow(FormulaParser.FOLLOW_unitPowerExpression_in_unitClump2515);
                    unitPowerExpression258=this.unitPowerExpression();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) stream_unitPowerExpression.add(unitPowerExpression258.getTree());
                    // /Library/WebServer/Documents/calc/Formula.g:383:38: ( CUBED )?
                    var alt89=2;
                    var LA89_0 = this.input.LA(1);

                    if ( (LA89_0==CUBED) ) {
                        alt89=1;
                    }
                    switch (alt89) {
                        case 1 :
                            // /Library/WebServer/Documents/calc/Formula.g:0:0: CUBED
                            CUBED259=this.match(this.input,CUBED,FormulaParser.FOLLOW_CUBED_in_unitClump2517); if (this.state.failed) return retval; 
                            if ( this.state.backtracking===0 ) stream_CUBED.add(CUBED259);



                            break;

                    }

                    // /Library/WebServer/Documents/calc/Formula.g:383:45: ( SQUARED )?
                    var alt90=2;
                    var LA90_0 = this.input.LA(1);

                    if ( (LA90_0==SQUARED) ) {
                        alt90=1;
                    }
                    switch (alt90) {
                        case 1 :
                            // /Library/WebServer/Documents/calc/Formula.g:0:0: SQUARED
                            SQUARED260=this.match(this.input,SQUARED,FormulaParser.FOLLOW_SQUARED_in_unitClump2520); if (this.state.failed) return retval; 
                            if ( this.state.backtracking===0 ) stream_SQUARED.add(SQUARED260);



                            break;

                    }



                    // AST REWRITE
                    // elements: CUBED, unitPowerExpression, SQUARED
                    // token labels: 
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: 
                    if ( this.state.backtracking===0 ) {
                    retval.tree = root_0;
                    var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

                    root_0 = this.adaptor.nil();
                    // 383:54: -> ^( UNITCLUMP unitPowerExpression NEGATE ( CUBED )* ( SQUARED )* )
                    {
                        // /Library/WebServer/Documents/calc/Formula.g:383:57: ^( UNITCLUMP unitPowerExpression NEGATE ( CUBED )* ( SQUARED )* )
                        {
                        var root_1 = this.adaptor.nil();
                        root_1 = this.adaptor.becomeRoot(this.adaptor.create(UNITCLUMP, "UNITCLUMP"), root_1);

                        this.adaptor.addChild(root_1, stream_unitPowerExpression.nextTree());
                        this.adaptor.addChild(root_1, this.adaptor.create(NEGATE, "NEGATE"));
                        // /Library/WebServer/Documents/calc/Formula.g:383:96: ( CUBED )*
                        while ( stream_CUBED.hasNext() ) {
                            this.adaptor.addChild(root_1, stream_CUBED.nextNode());

                        }
                        stream_CUBED.reset();
                        // /Library/WebServer/Documents/calc/Formula.g:383:103: ( SQUARED )*
                        while ( stream_SQUARED.hasNext() ) {
                            this.adaptor.addChild(root_1, stream_SQUARED.nextNode());

                        }
                        stream_SQUARED.reset();

                        this.adaptor.addChild(root_0, root_1);
                        }

                    }

                    retval.tree = root_0;}

                    break;
                case 2 :
                    // /Library/WebServer/Documents/calc/Formula.g:384:5: unitPowerExpression ( CUBED )? ( SQUARED )?
                    this.pushFollow(FormulaParser.FOLLOW_unitPowerExpression_in_unitClump2543);
                    unitPowerExpression261=this.unitPowerExpression();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) stream_unitPowerExpression.add(unitPowerExpression261.getTree());
                    // /Library/WebServer/Documents/calc/Formula.g:384:25: ( CUBED )?
                    var alt91=2;
                    var LA91_0 = this.input.LA(1);

                    if ( (LA91_0==CUBED) ) {
                        alt91=1;
                    }
                    switch (alt91) {
                        case 1 :
                            // /Library/WebServer/Documents/calc/Formula.g:0:0: CUBED
                            CUBED262=this.match(this.input,CUBED,FormulaParser.FOLLOW_CUBED_in_unitClump2545); if (this.state.failed) return retval; 
                            if ( this.state.backtracking===0 ) stream_CUBED.add(CUBED262);



                            break;

                    }

                    // /Library/WebServer/Documents/calc/Formula.g:384:32: ( SQUARED )?
                    var alt92=2;
                    var LA92_0 = this.input.LA(1);

                    if ( (LA92_0==SQUARED) ) {
                        alt92=1;
                    }
                    switch (alt92) {
                        case 1 :
                            // /Library/WebServer/Documents/calc/Formula.g:0:0: SQUARED
                            SQUARED263=this.match(this.input,SQUARED,FormulaParser.FOLLOW_SQUARED_in_unitClump2548); if (this.state.failed) return retval; 
                            if ( this.state.backtracking===0 ) stream_SQUARED.add(SQUARED263);



                            break;

                    }



                    // AST REWRITE
                    // elements: unitPowerExpression, CUBED, SQUARED
                    // token labels: 
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: 
                    if ( this.state.backtracking===0 ) {
                    retval.tree = root_0;
                    var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

                    root_0 = this.adaptor.nil();
                    // 384:41: -> ^( UNITCLUMP unitPowerExpression ( CUBED )* ( SQUARED )* )
                    {
                        // /Library/WebServer/Documents/calc/Formula.g:384:44: ^( UNITCLUMP unitPowerExpression ( CUBED )* ( SQUARED )* )
                        {
                        var root_1 = this.adaptor.nil();
                        root_1 = this.adaptor.becomeRoot(this.adaptor.create(UNITCLUMP, "UNITCLUMP"), root_1);

                        this.adaptor.addChild(root_1, stream_unitPowerExpression.nextTree());
                        // /Library/WebServer/Documents/calc/Formula.g:384:76: ( CUBED )*
                        while ( stream_CUBED.hasNext() ) {
                            this.adaptor.addChild(root_1, stream_CUBED.nextNode());

                        }
                        stream_CUBED.reset();
                        // /Library/WebServer/Documents/calc/Formula.g:384:83: ( SQUARED )*
                        while ( stream_SQUARED.hasNext() ) {
                            this.adaptor.addChild(root_1, stream_SQUARED.nextNode());

                        }
                        stream_SQUARED.reset();

                        this.adaptor.addChild(root_0, root_1);
                        }

                    }

                    retval.tree = root_0;}

                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    unitPowerExpression_return: (function() {
        FormulaParser.unitPowerExpression_return = function(){};
        org.antlr.lang.extend(FormulaParser.unitPowerExpression_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // /Library/WebServer/Documents/calc/Formula.g:388:1: unitPowerExpression : unit ( POW ( MINUS )? ( INTEGER | FLOAT ) )* ;
    // $ANTLR start "unitPowerExpression"
    unitPowerExpression: function() {
        var retval = new FormulaParser.unitPowerExpression_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var POW265 = null;
        var MINUS266 = null;
        var set267 = null;
         var unit264 = null;

        var POW265_tree=null;
        var MINUS266_tree=null;
        var set267_tree=null;

        try {
            // /Library/WebServer/Documents/calc/Formula.g:389:2: ( unit ( POW ( MINUS )? ( INTEGER | FLOAT ) )* )
            // /Library/WebServer/Documents/calc/Formula.g:389:5: unit ( POW ( MINUS )? ( INTEGER | FLOAT ) )*
            root_0 = this.adaptor.nil();

            this.pushFollow(FormulaParser.FOLLOW_unit_in_unitPowerExpression2610);
            unit264=this.unit();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, unit264.getTree());
            // /Library/WebServer/Documents/calc/Formula.g:389:10: ( POW ( MINUS )? ( INTEGER | FLOAT ) )*
            loop95:
            do {
                var alt95=2;
                var LA95_0 = this.input.LA(1);

                if ( (LA95_0==POW) ) {
                    alt95=1;
                }


                switch (alt95) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:389:12: POW ( MINUS )? ( INTEGER | FLOAT )
                    POW265=this.match(this.input,POW,FormulaParser.FOLLOW_POW_in_unitPowerExpression2614); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    POW265_tree = this.adaptor.create(POW265);
                    root_0 = this.adaptor.becomeRoot(POW265_tree, root_0);
                    }
                    // /Library/WebServer/Documents/calc/Formula.g:389:17: ( MINUS )?
                    var alt94=2;
                    var LA94_0 = this.input.LA(1);

                    if ( (LA94_0==MINUS) ) {
                        alt94=1;
                    }
                    switch (alt94) {
                        case 1 :
                            // /Library/WebServer/Documents/calc/Formula.g:0:0: MINUS
                            MINUS266=this.match(this.input,MINUS,FormulaParser.FOLLOW_MINUS_in_unitPowerExpression2617); if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) {
                            MINUS266_tree = this.adaptor.create(MINUS266);
                            this.adaptor.addChild(root_0, MINUS266_tree);
                            }


                            break;

                    }

                    set267=this.input.LT(1);
                    if ( (this.input.LA(1)>=INTEGER && this.input.LA(1)<=FLOAT) ) {
                        this.input.consume();
                        if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set267));
                        this.state.errorRecovery=false;this.state.failed=false;
                    }
                    else {
                        if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                        throw mse;
                    }



                    break;

                default :
                    break loop95;
                }
            } while (true);




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    unit_return: (function() {
        FormulaParser.unit_return = function(){};
        org.antlr.lang.extend(FormulaParser.unit_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // /Library/WebServer/Documents/calc/Formula.g:392:1: unit : ( IDENT ( IDENT )* -> ^( UNIT ( IDENT )+ ) | '(' unitMultiplicativeExpression ')' -> ^( UNITCLUMP unitMultiplicativeExpression ) );
    // $ANTLR start "unit"
    unit: function() {
        var retval = new FormulaParser.unit_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var IDENT268 = null;
        var IDENT269 = null;
        var char_literal270 = null;
        var char_literal272 = null;
         var unitMultiplicativeExpression271 = null;

        var IDENT268_tree=null;
        var IDENT269_tree=null;
        var char_literal270_tree=null;
        var char_literal272_tree=null;
        var stream_114=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token 114");
        var stream_IDENT=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token IDENT");
        var stream_113=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token 113");
        var stream_unitMultiplicativeExpression=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule unitMultiplicativeExpression");
        try {
            // /Library/WebServer/Documents/calc/Formula.g:392:6: ( IDENT ( IDENT )* -> ^( UNIT ( IDENT )+ ) | '(' unitMultiplicativeExpression ')' -> ^( UNITCLUMP unitMultiplicativeExpression ) )
            var alt97=2;
            var LA97_0 = this.input.LA(1);

            if ( (LA97_0==IDENT) ) {
                alt97=1;
            }
            else if ( (LA97_0==113) ) {
                alt97=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 97, 0, this.input);

                throw nvae;
            }
            switch (alt97) {
                case 1 :
                    // /Library/WebServer/Documents/calc/Formula.g:392:8: IDENT ( IDENT )*
                    IDENT268=this.match(this.input,IDENT,FormulaParser.FOLLOW_IDENT_in_unit2638); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_IDENT.add(IDENT268);

                    // /Library/WebServer/Documents/calc/Formula.g:392:14: ( IDENT )*
                    loop96:
                    do {
                        var alt96=2;
                        var LA96_0 = this.input.LA(1);

                        if ( (LA96_0==IDENT) ) {
                            alt96=1;
                        }


                        switch (alt96) {
                        case 1 :
                            // /Library/WebServer/Documents/calc/Formula.g:392:15: IDENT
                            IDENT269=this.match(this.input,IDENT,FormulaParser.FOLLOW_IDENT_in_unit2641); if (this.state.failed) return retval; 
                            if ( this.state.backtracking===0 ) stream_IDENT.add(IDENT269);



                            break;

                        default :
                            break loop96;
                        }
                    } while (true);



                    // AST REWRITE
                    // elements: IDENT
                    // token labels: 
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: 
                    if ( this.state.backtracking===0 ) {
                    retval.tree = root_0;
                    var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

                    root_0 = this.adaptor.nil();
                    // 392:23: -> ^( UNIT ( IDENT )+ )
                    {
                        // /Library/WebServer/Documents/calc/Formula.g:392:26: ^( UNIT ( IDENT )+ )
                        {
                        var root_1 = this.adaptor.nil();
                        root_1 = this.adaptor.becomeRoot(this.adaptor.create(UNIT, "UNIT"), root_1);

                        if ( !(stream_IDENT.hasNext()) ) {
                            throw new org.antlr.runtime.tree.RewriteEarlyExitException();
                        }
                        while ( stream_IDENT.hasNext() ) {
                            this.adaptor.addChild(root_1, stream_IDENT.nextNode());

                        }
                        stream_IDENT.reset();

                        this.adaptor.addChild(root_0, root_1);
                        }

                    }

                    retval.tree = root_0;}

                    break;
                case 2 :
                    // /Library/WebServer/Documents/calc/Formula.g:393:5: '(' unitMultiplicativeExpression ')'
                    char_literal270=this.match(this.input,113,FormulaParser.FOLLOW_113_in_unit2658); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_113.add(char_literal270);

                    this.pushFollow(FormulaParser.FOLLOW_unitMultiplicativeExpression_in_unit2660);
                    unitMultiplicativeExpression271=this.unitMultiplicativeExpression();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) stream_unitMultiplicativeExpression.add(unitMultiplicativeExpression271.getTree());
                    char_literal272=this.match(this.input,114,FormulaParser.FOLLOW_114_in_unit2662); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_114.add(char_literal272);



                    // AST REWRITE
                    // elements: unitMultiplicativeExpression
                    // token labels: 
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: 
                    if ( this.state.backtracking===0 ) {
                    retval.tree = root_0;
                    var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

                    root_0 = this.adaptor.nil();
                    // 393:42: -> ^( UNITCLUMP unitMultiplicativeExpression )
                    {
                        // /Library/WebServer/Documents/calc/Formula.g:393:45: ^( UNITCLUMP unitMultiplicativeExpression )
                        {
                        var root_1 = this.adaptor.nil();
                        root_1 = this.adaptor.becomeRoot(this.adaptor.create(UNITCLUMP, "UNITCLUMP"), root_1);

                        this.adaptor.addChild(root_1, stream_unitMultiplicativeExpression.nextTree());

                        this.adaptor.addChild(root_0, root_1);
                        }

                    }

                    retval.tree = root_0;}

                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    primitive_return: (function() {
        FormulaParser.primitive_return = function(){};
        org.antlr.lang.extend(FormulaParser.primitive_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // /Library/WebServer/Documents/calc/Formula.g:406:1: primitive : PRIMITIVE ;
    // $ANTLR start "primitive"
    primitive: function() {
        var retval = new FormulaParser.primitive_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var PRIMITIVE273 = null;

        var PRIMITIVE273_tree=null;

        try {
            // /Library/WebServer/Documents/calc/Formula.g:407:2: ( PRIMITIVE )
            // /Library/WebServer/Documents/calc/Formula.g:407:4: PRIMITIVE
            root_0 = this.adaptor.nil();

            PRIMITIVE273=this.match(this.input,PRIMITIVE,FormulaParser.FOLLOW_PRIMITIVE_in_primitive2731); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            PRIMITIVE273_tree = this.adaptor.create(PRIMITIVE273);
            this.adaptor.addChild(root_0, PRIMITIVE273_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    string_return: (function() {
        FormulaParser.string_return = function(){};
        org.antlr.lang.extend(FormulaParser.string_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // /Library/WebServer/Documents/calc/Formula.g:466:1: string : STRING ;
    // $ANTLR start "string"
    string: function() {
        var retval = new FormulaParser.string_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var STRING274 = null;

        var STRING274_tree=null;

        try {
            // /Library/WebServer/Documents/calc/Formula.g:467:4: ( STRING )
            // /Library/WebServer/Documents/calc/Formula.g:467:7: STRING
            root_0 = this.adaptor.nil();

            STRING274=this.match(this.input,STRING,FormulaParser.FOLLOW_STRING_in_string3200); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            STRING274_tree = this.adaptor.create(STRING274);
            root_0 = this.adaptor.becomeRoot(STRING274_tree, root_0);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // $ANTLR start "synpred5_Formula"
    synpred5_Formula_fragment: function() {
        // /Library/WebServer/Documents/calc/Formula.g:121:5: ( assignment )
        // /Library/WebServer/Documents/calc/Formula.g:121:5: assignment
        this.pushFollow(FormulaParser.FOLLOW_assignment_in_synpred5_Formula508);
        this.assignment();

        this.state._fsp--;
        if (this.state.failed) return ;


    },
    // $ANTLR end "synpred5_Formula",

    // $ANTLR start "synpred6_Formula"
    synpred6_Formula_fragment: function() {
        // /Library/WebServer/Documents/calc/Formula.g:122:5: ( logicalExpression )
        // /Library/WebServer/Documents/calc/Formula.g:122:5: logicalExpression
        this.pushFollow(FormulaParser.FOLLOW_logicalExpression_in_synpred6_Formula514);
        this.logicalExpression();

        this.state._fsp--;
        if (this.state.failed) return ;


    },
    // $ANTLR end "synpred6_Formula",

    // $ANTLR start "synpred8_Formula"
    synpred8_Formula_fragment: function() {
        // /Library/WebServer/Documents/calc/Formula.g:124:5: ( forLoop )
        // /Library/WebServer/Documents/calc/Formula.g:124:5: forLoop
        this.pushFollow(FormulaParser.FOLLOW_forLoop_in_synpred8_Formula526);
        this.forLoop();

        this.state._fsp--;
        if (this.state.failed) return ;


    },
    // $ANTLR end "synpred8_Formula",

    // $ANTLR start "synpred9_Formula"
    synpred9_Formula_fragment: function() {
        // /Library/WebServer/Documents/calc/Formula.g:125:5: ( forInLoop )
        // /Library/WebServer/Documents/calc/Formula.g:125:5: forInLoop
        this.pushFollow(FormulaParser.FOLLOW_forInLoop_in_synpred9_Formula532);
        this.forInLoop();

        this.state._fsp--;
        if (this.state.failed) return ;


    },
    // $ANTLR end "synpred9_Formula",

    // $ANTLR start "synpred11_Formula"
    synpred11_Formula_fragment: function() {
        // /Library/WebServer/Documents/calc/Formula.g:127:5: ( functionDef )
        // /Library/WebServer/Documents/calc/Formula.g:127:5: functionDef
        this.pushFollow(FormulaParser.FOLLOW_functionDef_in_synpred11_Formula544);
        this.functionDef();

        this.state._fsp--;
        if (this.state.failed) return ;


    },
    // $ANTLR end "synpred11_Formula",

    // $ANTLR start "synpred47_Formula"
    synpred47_Formula_fragment: function() {
        // /Library/WebServer/Documents/calc/Formula.g:187:26: ( OR booleanXORExpression )
        // /Library/WebServer/Documents/calc/Formula.g:187:26: OR booleanXORExpression
        this.match(this.input,OR,FormulaParser.FOLLOW_OR_in_synpred47_Formula1217); if (this.state.failed) return ;
        this.pushFollow(FormulaParser.FOLLOW_booleanXORExpression_in_synpred47_Formula1220);
        this.booleanXORExpression();

        this.state._fsp--;
        if (this.state.failed) return ;


    },
    // $ANTLR end "synpred47_Formula",

    // $ANTLR start "synpred48_Formula"
    synpred48_Formula_fragment: function() {
        // /Library/WebServer/Documents/calc/Formula.g:193:26: ( XOR booleanAndExpression )
        // /Library/WebServer/Documents/calc/Formula.g:193:26: XOR booleanAndExpression
        this.match(this.input,XOR,FormulaParser.FOLLOW_XOR_in_synpred48_Formula1253); if (this.state.failed) return ;
        this.pushFollow(FormulaParser.FOLLOW_booleanAndExpression_in_synpred48_Formula1256);
        this.booleanAndExpression();

        this.state._fsp--;
        if (this.state.failed) return ;


    },
    // $ANTLR end "synpred48_Formula",

    // $ANTLR start "synpred49_Formula"
    synpred49_Formula_fragment: function() {
        // /Library/WebServer/Documents/calc/Formula.g:199:24: ( AND equalityExpression )
        // /Library/WebServer/Documents/calc/Formula.g:199:24: AND equalityExpression
        this.match(this.input,AND,FormulaParser.FOLLOW_AND_in_synpred49_Formula1288); if (this.state.failed) return ;
        this.pushFollow(FormulaParser.FOLLOW_equalityExpression_in_synpred49_Formula1291);
        this.equalityExpression();

        this.state._fsp--;
        if (this.state.failed) return ;


    },
    // $ANTLR end "synpred49_Formula",

    // $ANTLR start "synpred51_Formula"
    synpred51_Formula_fragment: function() {
        // /Library/WebServer/Documents/calc/Formula.g:205:26: ( ( EQUALS | NOTEQUALS ) relationalExpression )
        // /Library/WebServer/Documents/calc/Formula.g:205:26: ( EQUALS | NOTEQUALS ) relationalExpression
        if ( this.input.LA(1)==EQUALS||this.input.LA(1)==NOTEQUALS ) {
            this.input.consume();
            this.state.errorRecovery=false;this.state.failed=false;
        }
        else {
            if (this.state.backtracking>0) {this.state.failed=true; return ;}
            var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
            throw mse;
        }

        this.pushFollow(FormulaParser.FOLLOW_relationalExpression_in_synpred51_Formula1332);
        this.relationalExpression();

        this.state._fsp--;
        if (this.state.failed) return ;


    },
    // $ANTLR end "synpred51_Formula",

    // $ANTLR start "synpred55_Formula"
    synpred55_Formula_fragment: function() {
        // /Library/WebServer/Documents/calc/Formula.g:216:25: ( ( LT | LTEQ | GT | GTEQ ) additiveExpression )
        // /Library/WebServer/Documents/calc/Formula.g:216:25: ( LT | LTEQ | GT | GTEQ ) additiveExpression
        if ( (this.input.LA(1)>=LT && this.input.LA(1)<=GTEQ) ) {
            this.input.consume();
            this.state.errorRecovery=false;this.state.failed=false;
        }
        else {
            if (this.state.backtracking>0) {this.state.failed=true; return ;}
            var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
            throw mse;
        }

        this.pushFollow(FormulaParser.FOLLOW_additiveExpression_in_synpred55_Formula1389);
        this.additiveExpression();

        this.state._fsp--;
        if (this.state.failed) return ;


    },
    // $ANTLR end "synpred55_Formula",

    // $ANTLR start "synpred57_Formula"
    synpred57_Formula_fragment: function() {
        // /Library/WebServer/Documents/calc/Formula.g:225:31: ( ( PLUS | MINUS ) multiplicativeExpression )
        // /Library/WebServer/Documents/calc/Formula.g:225:31: ( PLUS | MINUS ) multiplicativeExpression
        if ( (this.input.LA(1)>=PLUS && this.input.LA(1)<=MINUS) ) {
            this.input.consume();
            this.state.errorRecovery=false;this.state.failed=false;
        }
        else {
            if (this.state.backtracking>0) {this.state.failed=true; return ;}
            var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
            throw mse;
        }

        this.pushFollow(FormulaParser.FOLLOW_multiplicativeExpression_in_synpred57_Formula1443);
        this.multiplicativeExpression();

        this.state._fsp--;
        if (this.state.failed) return ;


    },
    // $ANTLR end "synpred57_Formula",

    // $ANTLR start "synpred60_Formula"
    synpred60_Formula_fragment: function() {
        // /Library/WebServer/Documents/calc/Formula.g:232:22: ( ( MULT | DIV | MOD ) arrayExpression )
        // /Library/WebServer/Documents/calc/Formula.g:232:22: ( MULT | DIV | MOD ) arrayExpression
        if ( (this.input.LA(1)>=MULT && this.input.LA(1)<=MOD) ) {
            this.input.consume();
            this.state.errorRecovery=false;this.state.failed=false;
        }
        else {
            if (this.state.backtracking>0) {this.state.failed=true; return ;}
            var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
            throw mse;
        }

        this.pushFollow(FormulaParser.FOLLOW_arrayExpression_in_synpred60_Formula1486);
        this.arrayExpression();

        this.state._fsp--;
        if (this.state.failed) return ;


    },
    // $ANTLR end "synpred60_Formula",

    // $ANTLR start "synpred61_Formula"
    synpred61_Formula_fragment: function() {
        // /Library/WebServer/Documents/calc/Formula.g:240:25: ({...}? COLON {...}? negationExpression )
        // /Library/WebServer/Documents/calc/Formula.g:240:25: {...}? COLON {...}? negationExpression
        if ( !(( this.input.get(this.input.index()-1).getText()!=" ")) ) {
            if (this.state.backtracking>0) {this.state.failed=true; return ;}
            throw new org.antlr.runtime.FailedPredicateException(this.input, "synpred61_Formula", " this.input.get(this.input.index()-1).getText()!=\" \"");
        }
        this.match(this.input,COLON,FormulaParser.FOLLOW_COLON_in_synpred61_Formula1538); if (this.state.failed) return ;
        if ( !(( this.input.get(this.input.index()-1).getText()!=" ")) ) {
            if (this.state.backtracking>0) {this.state.failed=true; return ;}
            throw new org.antlr.runtime.FailedPredicateException(this.input, "synpred61_Formula", " this.input.get(this.input.index()-1).getText()!=\" \"");
        }
        this.pushFollow(FormulaParser.FOLLOW_negationExpression_in_synpred61_Formula1542);
        this.negationExpression();

        this.state._fsp--;
        if (this.state.failed) return ;


    },
    // $ANTLR end "synpred61_Formula",

    // $ANTLR start "synpred62_Formula"
    synpred62_Formula_fragment: function() {
        // /Library/WebServer/Documents/calc/Formula.g:240:167: ({...}? COLON {...}? negationExpression )
        // /Library/WebServer/Documents/calc/Formula.g:240:167: {...}? COLON {...}? negationExpression
        if ( !(( this.input.get(this.input.index()-1).getText()!=" ")) ) {
            if (this.state.backtracking>0) {this.state.failed=true; return ;}
            throw new org.antlr.runtime.FailedPredicateException(this.input, "synpred62_Formula", " this.input.get(this.input.index()-1).getText()!=\" \"");
        }
        this.match(this.input,COLON,FormulaParser.FOLLOW_COLON_in_synpred62_Formula1551); if (this.state.failed) return ;
        if ( !(( this.input.get(this.input.index()-1).getText()!=" ")) ) {
            if (this.state.backtracking>0) {this.state.failed=true; return ;}
            throw new org.antlr.runtime.FailedPredicateException(this.input, "synpred62_Formula", " this.input.get(this.input.index()-1).getText()!=\" \"");
        }
        this.pushFollow(FormulaParser.FOLLOW_negationExpression_in_synpred62_Formula1555);
        this.negationExpression();

        this.state._fsp--;
        if (this.state.failed) return ;


    },
    // $ANTLR end "synpred62_Formula",

    // $ANTLR start "synpred64_Formula"
    synpred64_Formula_fragment: function() {
        // /Library/WebServer/Documents/calc/Formula.g:249:21: ( POW unaryOrNegate )
        // /Library/WebServer/Documents/calc/Formula.g:249:21: POW unaryOrNegate
        this.match(this.input,POW,FormulaParser.FOLLOW_POW_in_synpred64_Formula1610); if (this.state.failed) return ;
        this.pushFollow(FormulaParser.FOLLOW_unaryOrNegate_in_synpred64_Formula1612);
        this.unaryOrNegate();

        this.state._fsp--;
        if (this.state.failed) return ;


    },
    // $ANTLR end "synpred64_Formula",

    // $ANTLR start "synpred68_Formula"
    synpred68_Formula_fragment: function() {
        // /Library/WebServer/Documents/calc/Formula.g:271:23: ({...}? ( selector | funCall ) )
        // /Library/WebServer/Documents/calc/Formula.g:271:23: {...}? ( selector | funCall )
        if ( !(( this.input.get(this.input.index()-1).getText()!=" ")) ) {
            if (this.state.backtracking>0) {this.state.failed=true; return ;}
            throw new org.antlr.runtime.FailedPredicateException(this.input, "synpred68_Formula", " this.input.get(this.input.index()-1).getText()!=\" \"");
        }
        // /Library/WebServer/Documents/calc/Formula.g:271:79: ( selector | funCall )
        var alt119=2;
        var LA119_0 = this.input.LA(1);

        if ( (LA119_0==LARR||LA119_0==LCURL||LA119_0==116) ) {
            alt119=1;
        }
        else if ( (LA119_0==113) ) {
            alt119=2;
        }
        else {
            if (this.state.backtracking>0) {this.state.failed=true; return ;}
            var nvae =
                new org.antlr.runtime.NoViableAltException("", 119, 0, this.input);

            throw nvae;
        }
        switch (alt119) {
            case 1 :
                // /Library/WebServer/Documents/calc/Formula.g:271:80: selector
                this.pushFollow(FormulaParser.FOLLOW_selector_in_synpred68_Formula1744);
                this.selector();

                this.state._fsp--;
                if (this.state.failed) return ;


                break;
            case 2 :
                // /Library/WebServer/Documents/calc/Formula.g:271:89: funCall
                this.pushFollow(FormulaParser.FOLLOW_funCall_in_synpred68_Formula1746);
                this.funCall();

                this.state._fsp--;
                if (this.state.failed) return ;


                break;

        }



    },
    // $ANTLR end "synpred68_Formula",

    // $ANTLR start "synpred75_Formula"
    synpred75_Formula_fragment: function() {
        // /Library/WebServer/Documents/calc/Formula.g:287:5: ( material )
        // /Library/WebServer/Documents/calc/Formula.g:287:5: material
        this.pushFollow(FormulaParser.FOLLOW_material_in_synpred75_Formula1841);
        this.material();

        this.state._fsp--;
        if (this.state.failed) return ;


    },
    // $ANTLR end "synpred75_Formula",

    // $ANTLR start "synpred78_Formula"
    synpred78_Formula_fragment: function() {
        // /Library/WebServer/Documents/calc/Formula.g:290:4: ( array )
        // /Library/WebServer/Documents/calc/Formula.g:290:4: array
        this.pushFollow(FormulaParser.FOLLOW_array_in_synpred78_Formula1856);
        this.array();

        this.state._fsp--;
        if (this.state.failed) return ;


    },
    // $ANTLR end "synpred78_Formula",

    // $ANTLR start "synpred80_Formula"
    synpred80_Formula_fragment: function() {
        // /Library/WebServer/Documents/calc/Formula.g:296:22: ( funCall )
        // /Library/WebServer/Documents/calc/Formula.g:296:22: funCall
        this.pushFollow(FormulaParser.FOLLOW_funCall_in_synpred80_Formula1880);
        this.funCall();

        this.state._fsp--;
        if (this.state.failed) return ;


    },
    // $ANTLR end "synpred80_Formula",

    // $ANTLR start "synpred85_Formula"
    synpred85_Formula_fragment: function() {
        // /Library/WebServer/Documents/calc/Formula.g:309:7: ( NEWLINE )
        // /Library/WebServer/Documents/calc/Formula.g:309:7: NEWLINE
        this.match(this.input,NEWLINE,FormulaParser.FOLLOW_NEWLINE_in_synpred85_Formula1946); if (this.state.failed) return ;


    },
    // $ANTLR end "synpred85_Formula",

    // $ANTLR start "synpred86_Formula"
    synpred86_Formula_fragment: function() {
        // /Library/WebServer/Documents/calc/Formula.g:309:23: ( NEWLINE )
        // /Library/WebServer/Documents/calc/Formula.g:309:23: NEWLINE
        this.match(this.input,NEWLINE,FormulaParser.FOLLOW_NEWLINE_in_synpred86_Formula1952); if (this.state.failed) return ;


    },
    // $ANTLR end "synpred86_Formula",

    // $ANTLR start "synpred87_Formula"
    synpred87_Formula_fragment: function() {
        // /Library/WebServer/Documents/calc/Formula.g:309:37: ( NEWLINE )
        // /Library/WebServer/Documents/calc/Formula.g:309:37: NEWLINE
        this.match(this.input,NEWLINE,FormulaParser.FOLLOW_NEWLINE_in_synpred87_Formula1958); if (this.state.failed) return ;


    },
    // $ANTLR end "synpred87_Formula",

    // $ANTLR start "synpred88_Formula"
    synpred88_Formula_fragment: function() {
        // /Library/WebServer/Documents/calc/Formula.g:309:52: ( NEWLINE )
        // /Library/WebServer/Documents/calc/Formula.g:309:52: NEWLINE
        this.match(this.input,NEWLINE,FormulaParser.FOLLOW_NEWLINE_in_synpred88_Formula1963); if (this.state.failed) return ;


    },
    // $ANTLR end "synpred88_Formula",

    // $ANTLR start "synpred93_Formula"
    synpred93_Formula_fragment: function() {
        // /Library/WebServer/Documents/calc/Formula.g:310:10: ( NEWLINE )
        // /Library/WebServer/Documents/calc/Formula.g:310:10: NEWLINE
        this.match(this.input,NEWLINE,FormulaParser.FOLLOW_NEWLINE_in_synpred93_Formula1989); if (this.state.failed) return ;


    },
    // $ANTLR end "synpred93_Formula",

    // $ANTLR start "synpred94_Formula"
    synpred94_Formula_fragment: function() {
        // /Library/WebServer/Documents/calc/Formula.g:310:26: ( NEWLINE )
        // /Library/WebServer/Documents/calc/Formula.g:310:26: NEWLINE
        this.match(this.input,NEWLINE,FormulaParser.FOLLOW_NEWLINE_in_synpred94_Formula1995); if (this.state.failed) return ;


    },
    // $ANTLR end "synpred94_Formula",

    // $ANTLR start "synpred95_Formula"
    synpred95_Formula_fragment: function() {
        // /Library/WebServer/Documents/calc/Formula.g:310:39: ( NEWLINE )
        // /Library/WebServer/Documents/calc/Formula.g:310:39: NEWLINE
        this.match(this.input,NEWLINE,FormulaParser.FOLLOW_NEWLINE_in_synpred95_Formula2000); if (this.state.failed) return ;


    },
    // $ANTLR end "synpred95_Formula",

    // $ANTLR start "synpred96_Formula"
    synpred96_Formula_fragment: function() {
        // /Library/WebServer/Documents/calc/Formula.g:310:54: ( NEWLINE )
        // /Library/WebServer/Documents/calc/Formula.g:310:54: NEWLINE
        this.match(this.input,NEWLINE,FormulaParser.FOLLOW_NEWLINE_in_synpred96_Formula2005); if (this.state.failed) return ;


    },
    // $ANTLR end "synpred96_Formula",

    // $ANTLR start "synpred108_Formula"
    synpred108_Formula_fragment: function() {
        // /Library/WebServer/Documents/calc/Formula.g:323:5: ( '.' arrayName )
        // /Library/WebServer/Documents/calc/Formula.g:323:5: '.' arrayName
        this.match(this.input,116,FormulaParser.FOLLOW_116_in_synpred108_Formula2133); if (this.state.failed) return ;
        this.pushFollow(FormulaParser.FOLLOW_arrayName_in_synpred108_Formula2135);
        this.arrayName();

        this.state._fsp--;
        if (this.state.failed) return ;


    },
    // $ANTLR end "synpred108_Formula",

    // $ANTLR start "synpred112_Formula"
    synpred112_Formula_fragment: function() {
        // /Library/WebServer/Documents/calc/Formula.g:331:3: ( arrayName ( NEWLINE )* COLON )
        // /Library/WebServer/Documents/calc/Formula.g:331:3: arrayName ( NEWLINE )* COLON
        this.pushFollow(FormulaParser.FOLLOW_arrayName_in_synpred112_Formula2173);
        this.arrayName();

        this.state._fsp--;
        if (this.state.failed) return ;
        // /Library/WebServer/Documents/calc/Formula.g:331:13: ( NEWLINE )*
        loop145:
        do {
            var alt145=2;
            var LA145_0 = this.input.LA(1);

            if ( (LA145_0==NEWLINE) ) {
                alt145=1;
            }


            switch (alt145) {
            case 1 :
                // /Library/WebServer/Documents/calc/Formula.g:0:0: NEWLINE
                this.match(this.input,NEWLINE,FormulaParser.FOLLOW_NEWLINE_in_synpred112_Formula2175); if (this.state.failed) return ;


                break;

            default :
                break loop145;
            }
        } while (true);

        this.match(this.input,COLON,FormulaParser.FOLLOW_COLON_in_synpred112_Formula2178); if (this.state.failed) return ;


    },
    // $ANTLR end "synpred112_Formula"

    // Delegated rules



    synpred95_Formula: function() {
        this.state.backtracking++;
        var start = this.input.mark();
        try {
            this.synpred95_Formula_fragment(); // can never throw exception
        } catch (re) {
            alert("impossible: "+re.toString());
        }
        var success = !this.state.failed;
        this.input.rewind(start);
        this.state.backtracking--;
        this.state.failed=false;
        return success;
    },
    synpred94_Formula: function() {
        this.state.backtracking++;
        var start = this.input.mark();
        try {
            this.synpred94_Formula_fragment(); // can never throw exception
        } catch (re) {
            alert("impossible: "+re.toString());
        }
        var success = !this.state.failed;
        this.input.rewind(start);
        this.state.backtracking--;
        this.state.failed=false;
        return success;
    },
    synpred80_Formula: function() {
        this.state.backtracking++;
        var start = this.input.mark();
        try {
            this.synpred80_Formula_fragment(); // can never throw exception
        } catch (re) {
            alert("impossible: "+re.toString());
        }
        var success = !this.state.failed;
        this.input.rewind(start);
        this.state.backtracking--;
        this.state.failed=false;
        return success;
    },
    synpred49_Formula: function() {
        this.state.backtracking++;
        var start = this.input.mark();
        try {
            this.synpred49_Formula_fragment(); // can never throw exception
        } catch (re) {
            alert("impossible: "+re.toString());
        }
        var success = !this.state.failed;
        this.input.rewind(start);
        this.state.backtracking--;
        this.state.failed=false;
        return success;
    },
    synpred57_Formula: function() {
        this.state.backtracking++;
        var start = this.input.mark();
        try {
            this.synpred57_Formula_fragment(); // can never throw exception
        } catch (re) {
            alert("impossible: "+re.toString());
        }
        var success = !this.state.failed;
        this.input.rewind(start);
        this.state.backtracking--;
        this.state.failed=false;
        return success;
    },
    synpred68_Formula: function() {
        this.state.backtracking++;
        var start = this.input.mark();
        try {
            this.synpred68_Formula_fragment(); // can never throw exception
        } catch (re) {
            alert("impossible: "+re.toString());
        }
        var success = !this.state.failed;
        this.input.rewind(start);
        this.state.backtracking--;
        this.state.failed=false;
        return success;
    },
    synpred51_Formula: function() {
        this.state.backtracking++;
        var start = this.input.mark();
        try {
            this.synpred51_Formula_fragment(); // can never throw exception
        } catch (re) {
            alert("impossible: "+re.toString());
        }
        var success = !this.state.failed;
        this.input.rewind(start);
        this.state.backtracking--;
        this.state.failed=false;
        return success;
    },
    synpred62_Formula: function() {
        this.state.backtracking++;
        var start = this.input.mark();
        try {
            this.synpred62_Formula_fragment(); // can never throw exception
        } catch (re) {
            alert("impossible: "+re.toString());
        }
        var success = !this.state.failed;
        this.input.rewind(start);
        this.state.backtracking--;
        this.state.failed=false;
        return success;
    },
    synpred64_Formula: function() {
        this.state.backtracking++;
        var start = this.input.mark();
        try {
            this.synpred64_Formula_fragment(); // can never throw exception
        } catch (re) {
            alert("impossible: "+re.toString());
        }
        var success = !this.state.failed;
        this.input.rewind(start);
        this.state.backtracking--;
        this.state.failed=false;
        return success;
    },
    synpred93_Formula: function() {
        this.state.backtracking++;
        var start = this.input.mark();
        try {
            this.synpred93_Formula_fragment(); // can never throw exception
        } catch (re) {
            alert("impossible: "+re.toString());
        }
        var success = !this.state.failed;
        this.input.rewind(start);
        this.state.backtracking--;
        this.state.failed=false;
        return success;
    },
    synpred55_Formula: function() {
        this.state.backtracking++;
        var start = this.input.mark();
        try {
            this.synpred55_Formula_fragment(); // can never throw exception
        } catch (re) {
            alert("impossible: "+re.toString());
        }
        var success = !this.state.failed;
        this.input.rewind(start);
        this.state.backtracking--;
        this.state.failed=false;
        return success;
    },
    synpred85_Formula: function() {
        this.state.backtracking++;
        var start = this.input.mark();
        try {
            this.synpred85_Formula_fragment(); // can never throw exception
        } catch (re) {
            alert("impossible: "+re.toString());
        }
        var success = !this.state.failed;
        this.input.rewind(start);
        this.state.backtracking--;
        this.state.failed=false;
        return success;
    },
    synpred87_Formula: function() {
        this.state.backtracking++;
        var start = this.input.mark();
        try {
            this.synpred87_Formula_fragment(); // can never throw exception
        } catch (re) {
            alert("impossible: "+re.toString());
        }
        var success = !this.state.failed;
        this.input.rewind(start);
        this.state.backtracking--;
        this.state.failed=false;
        return success;
    },
    synpred48_Formula: function() {
        this.state.backtracking++;
        var start = this.input.mark();
        try {
            this.synpred48_Formula_fragment(); // can never throw exception
        } catch (re) {
            alert("impossible: "+re.toString());
        }
        var success = !this.state.failed;
        this.input.rewind(start);
        this.state.backtracking--;
        this.state.failed=false;
        return success;
    },
    synpred86_Formula: function() {
        this.state.backtracking++;
        var start = this.input.mark();
        try {
            this.synpred86_Formula_fragment(); // can never throw exception
        } catch (re) {
            alert("impossible: "+re.toString());
        }
        var success = !this.state.failed;
        this.input.rewind(start);
        this.state.backtracking--;
        this.state.failed=false;
        return success;
    },
    synpred9_Formula: function() {
        this.state.backtracking++;
        var start = this.input.mark();
        try {
            this.synpred9_Formula_fragment(); // can never throw exception
        } catch (re) {
            alert("impossible: "+re.toString());
        }
        var success = !this.state.failed;
        this.input.rewind(start);
        this.state.backtracking--;
        this.state.failed=false;
        return success;
    },
    synpred75_Formula: function() {
        this.state.backtracking++;
        var start = this.input.mark();
        try {
            this.synpred75_Formula_fragment(); // can never throw exception
        } catch (re) {
            alert("impossible: "+re.toString());
        }
        var success = !this.state.failed;
        this.input.rewind(start);
        this.state.backtracking--;
        this.state.failed=false;
        return success;
    },
    synpred96_Formula: function() {
        this.state.backtracking++;
        var start = this.input.mark();
        try {
            this.synpred96_Formula_fragment(); // can never throw exception
        } catch (re) {
            alert("impossible: "+re.toString());
        }
        var success = !this.state.failed;
        this.input.rewind(start);
        this.state.backtracking--;
        this.state.failed=false;
        return success;
    },
    synpred47_Formula: function() {
        this.state.backtracking++;
        var start = this.input.mark();
        try {
            this.synpred47_Formula_fragment(); // can never throw exception
        } catch (re) {
            alert("impossible: "+re.toString());
        }
        var success = !this.state.failed;
        this.input.rewind(start);
        this.state.backtracking--;
        this.state.failed=false;
        return success;
    },
    synpred8_Formula: function() {
        this.state.backtracking++;
        var start = this.input.mark();
        try {
            this.synpred8_Formula_fragment(); // can never throw exception
        } catch (re) {
            alert("impossible: "+re.toString());
        }
        var success = !this.state.failed;
        this.input.rewind(start);
        this.state.backtracking--;
        this.state.failed=false;
        return success;
    },
    synpred112_Formula: function() {
        this.state.backtracking++;
        var start = this.input.mark();
        try {
            this.synpred112_Formula_fragment(); // can never throw exception
        } catch (re) {
            alert("impossible: "+re.toString());
        }
        var success = !this.state.failed;
        this.input.rewind(start);
        this.state.backtracking--;
        this.state.failed=false;
        return success;
    },
    synpred6_Formula: function() {
        this.state.backtracking++;
        var start = this.input.mark();
        try {
            this.synpred6_Formula_fragment(); // can never throw exception
        } catch (re) {
            alert("impossible: "+re.toString());
        }
        var success = !this.state.failed;
        this.input.rewind(start);
        this.state.backtracking--;
        this.state.failed=false;
        return success;
    },
    synpred5_Formula: function() {
        this.state.backtracking++;
        var start = this.input.mark();
        try {
            this.synpred5_Formula_fragment(); // can never throw exception
        } catch (re) {
            alert("impossible: "+re.toString());
        }
        var success = !this.state.failed;
        this.input.rewind(start);
        this.state.backtracking--;
        this.state.failed=false;
        return success;
    },
    synpred60_Formula: function() {
        this.state.backtracking++;
        var start = this.input.mark();
        try {
            this.synpred60_Formula_fragment(); // can never throw exception
        } catch (re) {
            alert("impossible: "+re.toString());
        }
        var success = !this.state.failed;
        this.input.rewind(start);
        this.state.backtracking--;
        this.state.failed=false;
        return success;
    },
    synpred61_Formula: function() {
        this.state.backtracking++;
        var start = this.input.mark();
        try {
            this.synpred61_Formula_fragment(); // can never throw exception
        } catch (re) {
            alert("impossible: "+re.toString());
        }
        var success = !this.state.failed;
        this.input.rewind(start);
        this.state.backtracking--;
        this.state.failed=false;
        return success;
    },
    synpred108_Formula: function() {
        this.state.backtracking++;
        var start = this.input.mark();
        try {
            this.synpred108_Formula_fragment(); // can never throw exception
        } catch (re) {
            alert("impossible: "+re.toString());
        }
        var success = !this.state.failed;
        this.input.rewind(start);
        this.state.backtracking--;
        this.state.failed=false;
        return success;
    },
    synpred11_Formula: function() {
        this.state.backtracking++;
        var start = this.input.mark();
        try {
            this.synpred11_Formula_fragment(); // can never throw exception
        } catch (re) {
            alert("impossible: "+re.toString());
        }
        var success = !this.state.failed;
        this.input.rewind(start);
        this.state.backtracking--;
        this.state.failed=false;
        return success;
    },
    synpred78_Formula: function() {
        this.state.backtracking++;
        var start = this.input.mark();
        try {
            this.synpred78_Formula_fragment(); // can never throw exception
        } catch (re) {
            alert("impossible: "+re.toString());
        }
        var success = !this.state.failed;
        this.input.rewind(start);
        this.state.backtracking--;
        this.state.failed=false;
        return success;
    },
    synpred88_Formula: function() {
        this.state.backtracking++;
        var start = this.input.mark();
        try {
            this.synpred88_Formula_fragment(); // can never throw exception
        } catch (re) {
            alert("impossible: "+re.toString());
        }
        var success = !this.state.failed;
        this.input.rewind(start);
        this.state.backtracking--;
        this.state.failed=false;
        return success;
    }

}, true); // important to pass true to overwrite default implementations

org.antlr.lang.augmentObject(FormulaParser, {
    DFA5_eotS:
        "\u0017\uffff",
    DFA5_eofS:
        "\u0017\uffff",
    DFA5_minS:
        "\u0001\u0026\u0002\u0000\u0008\uffff\u0001\u0000\u0002\uffff\u0001"+
    "\u0000\u0008\uffff",
    DFA5_maxS:
        "\u0001\u0071\u0002\u0000\u0008\uffff\u0001\u0000\u0002\uffff\u0001"+
    "\u0000\u0008\uffff",
    DFA5_acceptS:
        "\u0003\uffff\u0001\u0002\u0009\uffff\u0001\u0003\u0001\uffff\u0001"+
    "\u0006\u0001\u0008\u0001\u0009\u0001\u000a\u0001\u0001\u0001\u0007\u0001"+
    "\u0004\u0001\u0005",
    DFA5_specialS:
        "\u0001\uffff\u0001\u0000\u0001\u0001\u0008\uffff\u0001\u0002\u0002"+
    "\uffff\u0001\u0003\u0008\uffff}>",
    DFA5_transitionS: [
            "\u0001\u000d\u0003\uffff\u0001\u000e\u000b\uffff\u0001\u000f"+
            "\u0005\uffff\u0001\u000b\u0002\uffff\u0001\u0010\u0001\u0003"+
            "\u0001\u0011\u0002\uffff\u0001\u0012\u0001\u0001\u0001\uffff"+
            "\u0001\u0002\u000a\uffff\u0001\u0003\u0005\uffff\u0002\u0003"+
            "\u0001\uffff\u0001\u0003\u0002\uffff\u0005\u0003\u000e\uffff"+
            "\u0001\u0003",
            "\u0001\uffff",
            "\u0001\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "\u0001\uffff",
            "",
            "",
            "\u0001\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
    ]
});

org.antlr.lang.augmentObject(FormulaParser, {
    DFA5_eot:
        org.antlr.runtime.DFA.unpackEncodedString(FormulaParser.DFA5_eotS),
    DFA5_eof:
        org.antlr.runtime.DFA.unpackEncodedString(FormulaParser.DFA5_eofS),
    DFA5_min:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(FormulaParser.DFA5_minS),
    DFA5_max:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(FormulaParser.DFA5_maxS),
    DFA5_accept:
        org.antlr.runtime.DFA.unpackEncodedString(FormulaParser.DFA5_acceptS),
    DFA5_special:
        org.antlr.runtime.DFA.unpackEncodedString(FormulaParser.DFA5_specialS),
    DFA5_transition: (function() {
        var a = [],
            i,
            numStates = FormulaParser.DFA5_transitionS.length;
        for (i=0; i<numStates; i++) {
            a.push(org.antlr.runtime.DFA.unpackEncodedString(FormulaParser.DFA5_transitionS[i]));
        }
        return a;
    })()
});

FormulaParser.DFA5 = function(recognizer) {
    this.recognizer = recognizer;
    this.decisionNumber = 5;
    this.eot = FormulaParser.DFA5_eot;
    this.eof = FormulaParser.DFA5_eof;
    this.min = FormulaParser.DFA5_min;
    this.max = FormulaParser.DFA5_max;
    this.accept = FormulaParser.DFA5_accept;
    this.special = FormulaParser.DFA5_special;
    this.transition = FormulaParser.DFA5_transition;
};

org.antlr.lang.extend(FormulaParser.DFA5, org.antlr.runtime.DFA, {
    getDescription: function() {
        return "120:1: expression : ( assignment | logicalExpression | whileLoop | forLoop | forInLoop | ifThenElse | functionDef | returnExp | tryCatch | throwExp );";
    },
    specialStateTransition: function(s, input) {
        var _s = s;
        /* bind to recognizer so semantic predicates can be evaluated */
        var retval = (function(s, input) {
            switch ( s ) {
                        case 0 : 
                            var LA5_1 = input.LA(1);

                             
                            var index5_1 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred5_Formula()) ) {s = 19;}

                            else if ( (this.synpred6_Formula()) ) {s = 3;}

                             
                            input.seek(index5_1);
                            if ( s>=0 ) return s;
                            break;
                        case 1 : 
                            var LA5_2 = input.LA(1);

                             
                            var index5_2 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred5_Formula()) ) {s = 19;}

                            else if ( (this.synpred6_Formula()) ) {s = 3;}

                             
                            input.seek(index5_2);
                            if ( s>=0 ) return s;
                            break;
                        case 2 : 
                            var LA5_11 = input.LA(1);

                             
                            var index5_11 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred6_Formula()) ) {s = 3;}

                            else if ( (this.synpred11_Formula()) ) {s = 20;}

                             
                            input.seek(index5_11);
                            if ( s>=0 ) return s;
                            break;
                        case 3 : 
                            var LA5_14 = input.LA(1);

                             
                            var index5_14 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred8_Formula()) ) {s = 21;}

                            else if ( (this.synpred9_Formula()) ) {s = 22;}

                             
                            input.seek(index5_14);
                            if ( s>=0 ) return s;
                            break;
            }
        }).call(this.recognizer, s, input);
        if (!org.antlr.lang.isUndefined(retval)) {
            return retval;
        }
        if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
        var nvae =
            new org.antlr.runtime.NoViableAltException(this.getDescription(), 5, _s, input);
        this.error(nvae);
        throw nvae;
    },
    dummy: null
});
org.antlr.lang.augmentObject(FormulaParser, {
    DFA57_eotS:
        "\u000b\uffff",
    DFA57_eofS:
        "\u000b\uffff",
    DFA57_minS:
        "\u0001\u003c\u0003\uffff\u0001\u0000\u0006\uffff",
    DFA57_maxS:
        "\u0001\u0062\u0003\uffff\u0001\u0000\u0006\uffff",
    DFA57_acceptS:
        "\u0001\uffff\u0001\u0001\u0001\u0002\u0001\u0003\u0001\uffff\u0001"+
    "\u0005\u0001\u0006\u0001\u0007\u0001\u0008\u0001\u0009\u0001\u0004",
    DFA57_specialS:
        "\u0004\uffff\u0001\u0000\u0006\uffff}>",
    DFA57_transitionS: [
            "\u0001\u0008\u0003\uffff\u0001\u0009\u0004\uffff\u0001\u0005"+
            "\u0001\uffff\u0001\u0006\u0011\uffff\u0001\u0007\u0001\uffff"+
            "\u0001\u0004\u0002\uffff\u0001\u0003\u0002\u0001\u0002\u0002",
            "",
            "",
            "",
            "\u0001\uffff",
            "",
            "",
            "",
            "",
            "",
            ""
    ]
});

org.antlr.lang.augmentObject(FormulaParser, {
    DFA57_eot:
        org.antlr.runtime.DFA.unpackEncodedString(FormulaParser.DFA57_eotS),
    DFA57_eof:
        org.antlr.runtime.DFA.unpackEncodedString(FormulaParser.DFA57_eofS),
    DFA57_min:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(FormulaParser.DFA57_minS),
    DFA57_max:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(FormulaParser.DFA57_maxS),
    DFA57_accept:
        org.antlr.runtime.DFA.unpackEncodedString(FormulaParser.DFA57_acceptS),
    DFA57_special:
        org.antlr.runtime.DFA.unpackEncodedString(FormulaParser.DFA57_specialS),
    DFA57_transition: (function() {
        var a = [],
            i,
            numStates = FormulaParser.DFA57_transitionS.length;
        for (i=0; i<numStates; i++) {
            a.push(org.antlr.runtime.DFA.unpackEncodedString(FormulaParser.DFA57_transitionS[i]));
        }
        return a;
    })()
});

FormulaParser.DFA57 = function(recognizer) {
    this.recognizer = recognizer;
    this.decisionNumber = 57;
    this.eot = FormulaParser.DFA57_eot;
    this.eof = FormulaParser.DFA57_eof;
    this.min = FormulaParser.DFA57_min;
    this.max = FormulaParser.DFA57_max;
    this.accept = FormulaParser.DFA57_accept;
    this.special = FormulaParser.DFA57_special;
    this.transition = FormulaParser.DFA57_transition;
};

org.antlr.lang.extend(FormulaParser.DFA57, org.antlr.runtime.DFA, {
    getDescription: function() {
        return "283:1: value : ( number | bool | string | material | IDENT | primitive | array | anonFunctionDef | newObject );";
    },
    specialStateTransition: function(s, input) {
        var _s = s;
        /* bind to recognizer so semantic predicates can be evaluated */
        var retval = (function(s, input) {
            switch ( s ) {
                        case 0 : 
                            var LA57_4 = input.LA(1);

                             
                            var index57_4 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred75_Formula()) ) {s = 10;}

                            else if ( (this.synpred78_Formula()) ) {s = 7;}

                             
                            input.seek(index57_4);
                            if ( s>=0 ) return s;
                            break;
            }
        }).call(this.recognizer, s, input);
        if (!org.antlr.lang.isUndefined(retval)) {
            return retval;
        }
        if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
        var nvae =
            new org.antlr.runtime.NoViableAltException(this.getDescription(), 57, _s, input);
        this.error(nvae);
        throw nvae;
    },
    dummy: null
});
org.antlr.lang.augmentObject(FormulaParser, {
    DFA58_eotS:
        "\u001a\uffff",
    DFA58_eofS:
        "\u0001\u0002\u0019\uffff",
    DFA58_minS:
        "\u0001\u0020\u0001\u0000\u0018\uffff",
    DFA58_maxS:
        "\u0001\u0074\u0001\u0000\u0018\uffff",
    DFA58_acceptS:
        "\u0002\uffff\u0001\u0002\u0016\uffff\u0001\u0001",
    DFA58_specialS:
        "\u0001\uffff\u0001\u0000\u0018\uffff}>",
    DFA58_transitionS: [
            "\u0001\u0002\u000f\uffff\u0001\u0002\u0002\uffff\u0001\u0002"+
            "\u0003\uffff\u0001\u0002\u000d\uffff\u0002\u0002\u0001\uffff"+
            "\u0002\u0002\u0001\uffff\u000d\u0002\u0001\uffff\u0005\u0002"+
            "\u0001\uffff\u0001\u0002\u0011\uffff\u0001\u0001\u0001\u0002"+
            "\u0001\uffff\u0001\u0002",
            "\u0001\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
    ]
});

org.antlr.lang.augmentObject(FormulaParser, {
    DFA58_eot:
        org.antlr.runtime.DFA.unpackEncodedString(FormulaParser.DFA58_eotS),
    DFA58_eof:
        org.antlr.runtime.DFA.unpackEncodedString(FormulaParser.DFA58_eofS),
    DFA58_min:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(FormulaParser.DFA58_minS),
    DFA58_max:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(FormulaParser.DFA58_maxS),
    DFA58_accept:
        org.antlr.runtime.DFA.unpackEncodedString(FormulaParser.DFA58_acceptS),
    DFA58_special:
        org.antlr.runtime.DFA.unpackEncodedString(FormulaParser.DFA58_specialS),
    DFA58_transition: (function() {
        var a = [],
            i,
            numStates = FormulaParser.DFA58_transitionS.length;
        for (i=0; i<numStates; i++) {
            a.push(org.antlr.runtime.DFA.unpackEncodedString(FormulaParser.DFA58_transitionS[i]));
        }
        return a;
    })()
});

FormulaParser.DFA58 = function(recognizer) {
    this.recognizer = recognizer;
    this.decisionNumber = 58;
    this.eot = FormulaParser.DFA58_eot;
    this.eof = FormulaParser.DFA58_eof;
    this.min = FormulaParser.DFA58_min;
    this.max = FormulaParser.DFA58_max;
    this.accept = FormulaParser.DFA58_accept;
    this.special = FormulaParser.DFA58_special;
    this.transition = FormulaParser.DFA58_transition;
};

org.antlr.lang.extend(FormulaParser.DFA58, org.antlr.runtime.DFA, {
    getDescription: function() {
        return "296:22: ( funCall )?";
    },
    specialStateTransition: function(s, input) {
        var _s = s;
        /* bind to recognizer so semantic predicates can be evaluated */
        var retval = (function(s, input) {
            switch ( s ) {
                        case 0 : 
                            var LA58_1 = input.LA(1);

                             
                            var index58_1 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred80_Formula()) ) {s = 25;}

                            else if ( ((( this.input.get(this.input.index()-1).getText()==" ")||( this.input.get(this.input.index()-1).getText()!=" "))) ) {s = 2;}

                             
                            input.seek(index58_1);
                            if ( s>=0 ) return s;
                            break;
            }
        }).call(this.recognizer, s, input);
        if (!org.antlr.lang.isUndefined(retval)) {
            return retval;
        }
        if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
        var nvae =
            new org.antlr.runtime.NoViableAltException(this.getDescription(), 58, _s, input);
        this.error(nvae);
        throw nvae;
    },
    dummy: null
});
org.antlr.lang.augmentObject(FormulaParser, {
    DFA65_eotS:
        "\u0004\uffff",
    DFA65_eofS:
        "\u0004\uffff",
    DFA65_minS:
        "\u0001\u0020\u0001\uffff\u0001\u0020\u0001\uffff",
    DFA65_maxS:
        "\u0001\u0071\u0001\uffff\u0001\u0071\u0001\uffff",
    DFA65_acceptS:
        "\u0001\uffff\u0001\u0001\u0001\uffff\u0001\u0002",
    DFA65_specialS:
        "\u0004\uffff}>",
    DFA65_transitionS: [
            "\u0001\u0002\u001b\uffff\u0001\u0001\u0003\uffff\u0001\u0001"+
            "\u0004\uffff\u0001\u0001\u0001\uffff\u0001\u0001\u000a\uffff"+
            "\u0002\u0001\u0004\uffff\u0002\u0001\u0001\u0003\u0001\u0001"+
            "\u0002\uffff\u0005\u0001\u000e\uffff\u0001\u0001",
            "",
            "\u0001\u0002\u001b\uffff\u0001\u0001\u0003\uffff\u0001\u0001"+
            "\u0004\uffff\u0001\u0001\u0001\uffff\u0001\u0001\u000a\uffff"+
            "\u0001\u0001\u0005\uffff\u0002\u0001\u0001\u0003\u0001\u0001"+
            "\u0002\uffff\u0005\u0001\u000e\uffff\u0001\u0001",
            ""
    ]
});

org.antlr.lang.augmentObject(FormulaParser, {
    DFA65_eot:
        org.antlr.runtime.DFA.unpackEncodedString(FormulaParser.DFA65_eotS),
    DFA65_eof:
        org.antlr.runtime.DFA.unpackEncodedString(FormulaParser.DFA65_eofS),
    DFA65_min:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(FormulaParser.DFA65_minS),
    DFA65_max:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(FormulaParser.DFA65_maxS),
    DFA65_accept:
        org.antlr.runtime.DFA.unpackEncodedString(FormulaParser.DFA65_acceptS),
    DFA65_special:
        org.antlr.runtime.DFA.unpackEncodedString(FormulaParser.DFA65_specialS),
    DFA65_transition: (function() {
        var a = [],
            i,
            numStates = FormulaParser.DFA65_transitionS.length;
        for (i=0; i<numStates; i++) {
            a.push(org.antlr.runtime.DFA.unpackEncodedString(FormulaParser.DFA65_transitionS[i]));
        }
        return a;
    })()
});

FormulaParser.DFA65 = function(recognizer) {
    this.recognizer = recognizer;
    this.decisionNumber = 65;
    this.eot = FormulaParser.DFA65_eot;
    this.eof = FormulaParser.DFA65_eof;
    this.min = FormulaParser.DFA65_min;
    this.max = FormulaParser.DFA65_max;
    this.accept = FormulaParser.DFA65_accept;
    this.special = FormulaParser.DFA65_special;
    this.transition = FormulaParser.DFA65_transition;
};

org.antlr.lang.extend(FormulaParser.DFA65, org.antlr.runtime.DFA, {
    getDescription: function() {
        return "309:16: ( label ( NEWLINE )* ( ',' ( NEWLINE )* label ( NEWLINE )* )* )?";
    },
    dummy: null
});
org.antlr.lang.augmentObject(FormulaParser, {
    DFA72_eotS:
        "\u0004\uffff",
    DFA72_eofS:
        "\u0004\uffff",
    DFA72_minS:
        "\u0001\u0020\u0001\uffff\u0001\u0020\u0001\uffff",
    DFA72_maxS:
        "\u0001\u0071\u0001\uffff\u0001\u0071\u0001\uffff",
    DFA72_acceptS:
        "\u0001\uffff\u0001\u0001\u0001\uffff\u0001\u0002",
    DFA72_specialS:
        "\u0004\uffff}>",
    DFA72_transitionS: [
            "\u0001\u0002\u001b\uffff\u0001\u0001\u0003\uffff\u0001\u0001"+
            "\u0004\uffff\u0001\u0001\u0001\uffff\u0001\u0001\u000a\uffff"+
            "\u0002\u0001\u0004\uffff\u0002\u0001\u0001\uffff\u0001\u0001"+
            "\u0001\u0003\u0001\uffff\u0005\u0001\u000e\uffff\u0001\u0001",
            "",
            "\u0001\u0002\u001b\uffff\u0001\u0001\u0003\uffff\u0001\u0001"+
            "\u0004\uffff\u0001\u0001\u0001\uffff\u0001\u0001\u000a\uffff"+
            "\u0001\u0001\u0005\uffff\u0002\u0001\u0001\uffff\u0001\u0001"+
            "\u0001\u0003\u0001\uffff\u0005\u0001\u000e\uffff\u0001\u0001",
            ""
    ]
});

org.antlr.lang.augmentObject(FormulaParser, {
    DFA72_eot:
        org.antlr.runtime.DFA.unpackEncodedString(FormulaParser.DFA72_eotS),
    DFA72_eof:
        org.antlr.runtime.DFA.unpackEncodedString(FormulaParser.DFA72_eofS),
    DFA72_min:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(FormulaParser.DFA72_minS),
    DFA72_max:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(FormulaParser.DFA72_maxS),
    DFA72_accept:
        org.antlr.runtime.DFA.unpackEncodedString(FormulaParser.DFA72_acceptS),
    DFA72_special:
        org.antlr.runtime.DFA.unpackEncodedString(FormulaParser.DFA72_specialS),
    DFA72_transition: (function() {
        var a = [],
            i,
            numStates = FormulaParser.DFA72_transitionS.length;
        for (i=0; i<numStates; i++) {
            a.push(org.antlr.runtime.DFA.unpackEncodedString(FormulaParser.DFA72_transitionS[i]));
        }
        return a;
    })()
});

FormulaParser.DFA72 = function(recognizer) {
    this.recognizer = recognizer;
    this.decisionNumber = 72;
    this.eot = FormulaParser.DFA72_eot;
    this.eof = FormulaParser.DFA72_eof;
    this.min = FormulaParser.DFA72_min;
    this.max = FormulaParser.DFA72_max;
    this.accept = FormulaParser.DFA72_accept;
    this.special = FormulaParser.DFA72_special;
    this.transition = FormulaParser.DFA72_transition;
};

org.antlr.lang.extend(FormulaParser.DFA72, org.antlr.runtime.DFA, {
    getDescription: function() {
        return "310:19: ( label ( NEWLINE )* ( ',' ( NEWLINE )* label ( NEWLINE )* )* )?";
    },
    dummy: null
});
org.antlr.lang.augmentObject(FormulaParser, {
    DFA85_eotS:
        "\u000f\uffff",
    DFA85_eofS:
        "\u000f\uffff",
    DFA85_minS:
        "\u0001\u0020\u0001\u0000\u0006\uffff\u0001\u0000\u0006\uffff",
    DFA85_maxS:
        "\u0001\u0071\u0001\u0000\u0006\uffff\u0001\u0000\u0006\uffff",
    DFA85_acceptS:
        "\u0002\uffff\u0001\u0002\u0007\uffff\u0001\u0001\u0004\uffff",
    DFA85_specialS:
        "\u0001\uffff\u0001\u0000\u0006\uffff\u0001\u0001\u0006\uffff}>",
    DFA85_transitionS: [
            "\u0001\u0002\u001b\uffff\u0001\u0002\u0003\uffff\u0001\u0002"+
            "\u0004\uffff\u0001\u0008\u0001\uffff\u0001\u0002\u000a\uffff"+
            "\u0001\u0002\u0001\u000a\u0004\uffff\u0002\u0002\u0001\uffff"+
            "\u0001\u0002\u0002\uffff\u0001\u0001\u0004\u0002\u000e\uffff"+
            "\u0001\u0002",
            "\u0001\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "\u0001\uffff",
            "",
            "",
            "",
            "",
            "",
            ""
    ]
});

org.antlr.lang.augmentObject(FormulaParser, {
    DFA85_eot:
        org.antlr.runtime.DFA.unpackEncodedString(FormulaParser.DFA85_eotS),
    DFA85_eof:
        org.antlr.runtime.DFA.unpackEncodedString(FormulaParser.DFA85_eofS),
    DFA85_min:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(FormulaParser.DFA85_minS),
    DFA85_max:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(FormulaParser.DFA85_maxS),
    DFA85_accept:
        org.antlr.runtime.DFA.unpackEncodedString(FormulaParser.DFA85_acceptS),
    DFA85_special:
        org.antlr.runtime.DFA.unpackEncodedString(FormulaParser.DFA85_specialS),
    DFA85_transition: (function() {
        var a = [],
            i,
            numStates = FormulaParser.DFA85_transitionS.length;
        for (i=0; i<numStates; i++) {
            a.push(org.antlr.runtime.DFA.unpackEncodedString(FormulaParser.DFA85_transitionS[i]));
        }
        return a;
    })()
});

FormulaParser.DFA85 = function(recognizer) {
    this.recognizer = recognizer;
    this.decisionNumber = 85;
    this.eot = FormulaParser.DFA85_eot;
    this.eof = FormulaParser.DFA85_eof;
    this.min = FormulaParser.DFA85_min;
    this.max = FormulaParser.DFA85_max;
    this.accept = FormulaParser.DFA85_accept;
    this.special = FormulaParser.DFA85_special;
    this.transition = FormulaParser.DFA85_transition;
};

org.antlr.lang.extend(FormulaParser.DFA85, org.antlr.runtime.DFA, {
    getDescription: function() {
        return "331:2: ( arrayName ( NEWLINE )* COLON )?";
    },
    specialStateTransition: function(s, input) {
        var _s = s;
        /* bind to recognizer so semantic predicates can be evaluated */
        var retval = (function(s, input) {
            switch ( s ) {
                        case 0 : 
                            var LA85_1 = input.LA(1);

                             
                            var index85_1 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred112_Formula()) ) {s = 10;}

                            else if ( (true) ) {s = 2;}

                             
                            input.seek(index85_1);
                            if ( s>=0 ) return s;
                            break;
                        case 1 : 
                            var LA85_8 = input.LA(1);

                             
                            var index85_8 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred112_Formula()) ) {s = 10;}

                            else if ( (true) ) {s = 2;}

                             
                            input.seek(index85_8);
                            if ( s>=0 ) return s;
                            break;
            }
        }).call(this.recognizer, s, input);
        if (!org.antlr.lang.isUndefined(retval)) {
            return retval;
        }
        if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
        var nvae =
            new org.antlr.runtime.NoViableAltException(this.getDescription(), 85, _s, input);
        this.error(nvae);
        throw nvae;
    },
    dummy: null
});
 

// public class variables
org.antlr.lang.augmentObject(FormulaParser, {
    tokenNames: ["<invalid>", "<EOR>", "<DOWN>", "<UP>", "NEGATE", "ASSIGN", "FUNCALL", "MATERIAL", "UNIT", "POWER", "DEFAULTS", "PARAMS", "UNITCLUMP", "ARRAY", "LINES", "WHILE", "IFTHENELSE", "ELSE", "FOR", "FORIN", "FUNCTION", "ANONFUNCTION", "NUMBER", "LABEL", "RANGE", "INNER", "ASSIGNED", "SELECTOR", "DOTSELECTOR", "NEW", "TRYCATCH", "THROW", "NEWLINE", "W", "H", "I", "L", "E", "WHILESTATEMENT", "F", "O", "R", "FORSTATEMENT", "M", "FROMSTATEMENT", "N", "INSTATEMENT", "T", "TOSTATEMENT", "B", "Y", "BYSTATEMENT", "P", "LOOPSTATEMENT", "IFSTATEMENT", "THENSTATEMENT", "S", "ELSESTATEMENT", "U", "C", "FUNCTIONSTATEMENT", "D", "ENDBLOCK", "RETURNSTATEMENT", "NEWSTATEMENT", "TRYSTATEMENT", "A", "CATCHSTATEMENT", "THROWSTATEMENT", "IDENT", "EQUALS", "PRIMITIVE", "OR", "XOR", "X", "AND", "NOTEQUALS", "LT", "LTEQ", "GT", "GTEQ", "PLUS", "MINUS", "MULT", "DIV", "MOD", "COLON", "POW", "NOT", "LARR", "RARR", "LCURL", "RCURL", "COMMA", "STRING", "INTEGER", "FLOAT", "TRUE", "FALSE", "PER", "CUBED", "SQUARED", "Q", "LBRACKET", "RBRACKET", "COMMENT", "LINE_COMMENT", "WS", "G", "J", "K", "V", "Z", "'('", "')'", "'<-'", "'.'"],
    FOLLOW_NEWLINE_in_lines160: new org.antlr.runtime.BitSet([0x00000000, 0x90400441,0xCB0400B3, 0x00020007]),
    FOLLOW_expression_in_lines164: new org.antlr.runtime.BitSet([0x00000000, 0x00000001]),
    FOLLOW_NEWLINE_in_lines168: new org.antlr.runtime.BitSet([0x00000000, 0x90400441,0xCB0400B3, 0x00020007]),
    FOLLOW_EOF_in_lines171: new org.antlr.runtime.BitSet([0x00000000, 0x90400440,0xCB0400B3, 0x00020007]),
    FOLLOW_EOF_in_lines176: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_assignment_in_expression508: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_logicalExpression_in_expression514: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_whileLoop_in_expression520: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_forLoop_in_expression526: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_forInLoop_in_expression532: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_ifThenElse_in_expression538: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_functionDef_in_expression544: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_returnExp_in_expression550: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_tryCatch_in_expression556: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_throwExp_in_expression562: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_RETURNSTATEMENT_in_returnExp574: new org.antlr.runtime.BitSet([0x00000000, 0x10000000,0xCB0400A1, 0x00020007]),
    FOLLOW_logicalExpression_in_returnExp577: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_expression_in_innerBlock590: new org.antlr.runtime.BitSet([0x00000000, 0x00000001]),
    FOLLOW_NEWLINE_in_innerBlock594: new org.antlr.runtime.BitSet([0x00000002, 0x90400441,0xCB0400B3, 0x00020007]),
    FOLLOW_WHILESTATEMENT_in_whileLoop619: new org.antlr.runtime.BitSet([0x00000000, 0x10000000,0xCB0400A1, 0x00020007]),
    FOLLOW_logicalExpression_in_whileLoop621: new org.antlr.runtime.BitSet([0x00000000, 0x00000001]),
    FOLLOW_NEWLINE_in_whileLoop623: new org.antlr.runtime.BitSet([0x00000000, 0xD0400441,0xCB0400B3, 0x00020007]),
    FOLLOW_innerBlock_in_whileLoop626: new org.antlr.runtime.BitSet([0x00000000, 0x40000000]),
    FOLLOW_ENDBLOCK_in_whileLoop629: new org.antlr.runtime.BitSet([0x00000000, 0x00200000]),
    FOLLOW_LOOPSTATEMENT_in_whileLoop631: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_FORSTATEMENT_in_forLoop652: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000020, 0x00000000]),
    FOLLOW_IDENT_in_forLoop654: new org.antlr.runtime.BitSet([0x00000000, 0x00001000]),
    FOLLOW_FROMSTATEMENT_in_forLoop656: new org.antlr.runtime.BitSet([0x00000000, 0x10000000,0xCB0400A1, 0x00020007]),
    FOLLOW_logicalExpression_in_forLoop658: new org.antlr.runtime.BitSet([0x00000000, 0x00010000]),
    FOLLOW_TOSTATEMENT_in_forLoop660: new org.antlr.runtime.BitSet([0x00000000, 0x10000000,0xCB0400A1, 0x00020007]),
    FOLLOW_logicalExpression_in_forLoop662: new org.antlr.runtime.BitSet([0x00000000, 0x00080001]),
    FOLLOW_BYSTATEMENT_in_forLoop665: new org.antlr.runtime.BitSet([0x00000000, 0x10000000,0xCB0400A1, 0x00020007]),
    FOLLOW_logicalExpression_in_forLoop667: new org.antlr.runtime.BitSet([0x00000000, 0x00000001]),
    FOLLOW_NEWLINE_in_forLoop671: new org.antlr.runtime.BitSet([0x00000000, 0xD0400441,0xCB0400B3, 0x00020007]),
    FOLLOW_innerBlock_in_forLoop674: new org.antlr.runtime.BitSet([0x00000000, 0x40000000]),
    FOLLOW_ENDBLOCK_in_forLoop677: new org.antlr.runtime.BitSet([0x00000000, 0x00200000]),
    FOLLOW_LOOPSTATEMENT_in_forLoop679: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_FORSTATEMENT_in_forInLoop707: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000020, 0x00000000]),
    FOLLOW_IDENT_in_forInLoop709: new org.antlr.runtime.BitSet([0x00000000, 0x00004000]),
    FOLLOW_INSTATEMENT_in_forInLoop711: new org.antlr.runtime.BitSet([0x00000000, 0x10000000,0xCB0400A1, 0x00020007]),
    FOLLOW_logicalExpression_in_forInLoop713: new org.antlr.runtime.BitSet([0x00000000, 0x00000001]),
    FOLLOW_NEWLINE_in_forInLoop715: new org.antlr.runtime.BitSet([0x00000000, 0xD0400441,0xCB0400B3, 0x00020007]),
    FOLLOW_innerBlock_in_forInLoop718: new org.antlr.runtime.BitSet([0x00000000, 0x40000000]),
    FOLLOW_ENDBLOCK_in_forInLoop721: new org.antlr.runtime.BitSet([0x00000000, 0x00200000]),
    FOLLOW_LOOPSTATEMENT_in_forInLoop723: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_IFSTATEMENT_in_ifThenElse748: new org.antlr.runtime.BitSet([0x00000000, 0x10000000,0xCB0400A1, 0x00020007]),
    FOLLOW_logicalExpression_in_ifThenElse750: new org.antlr.runtime.BitSet([0x00000000, 0x00800000]),
    FOLLOW_THENSTATEMENT_in_ifThenElse752: new org.antlr.runtime.BitSet([0x00000000, 0x00000001]),
    FOLLOW_NEWLINE_in_ifThenElse755: new org.antlr.runtime.BitSet([0x00000000, 0xD2400441,0xCB0400B3, 0x00020007]),
    FOLLOW_innerBlock_in_ifThenElse758: new org.antlr.runtime.BitSet([0x00000000, 0x42000000]),
    FOLLOW_ELSESTATEMENT_in_ifThenElse762: new org.antlr.runtime.BitSet([0x00000000, 0x00400000]),
    FOLLOW_IFSTATEMENT_in_ifThenElse764: new org.antlr.runtime.BitSet([0x00000000, 0x10000000,0xCB0400A1, 0x00020007]),
    FOLLOW_logicalExpression_in_ifThenElse766: new org.antlr.runtime.BitSet([0x00000000, 0x00800000]),
    FOLLOW_THENSTATEMENT_in_ifThenElse768: new org.antlr.runtime.BitSet([0x00000000, 0x00000001]),
    FOLLOW_NEWLINE_in_ifThenElse770: new org.antlr.runtime.BitSet([0x00000000, 0xD2400441,0xCB0400B3, 0x00020007]),
    FOLLOW_innerBlock_in_ifThenElse773: new org.antlr.runtime.BitSet([0x00000000, 0x42000000]),
    FOLLOW_ELSESTATEMENT_in_ifThenElse778: new org.antlr.runtime.BitSet([0x00000000, 0x00000001]),
    FOLLOW_NEWLINE_in_ifThenElse780: new org.antlr.runtime.BitSet([0x00000000, 0xD0400441,0xCB0400B3, 0x00020007]),
    FOLLOW_innerBlock_in_ifThenElse783: new org.antlr.runtime.BitSet([0x00000000, 0x40000000]),
    FOLLOW_ENDBLOCK_in_ifThenElse787: new org.antlr.runtime.BitSet([0x00000000, 0x00400000]),
    FOLLOW_IFSTATEMENT_in_ifThenElse789: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_FUNCTIONSTATEMENT_in_functionDef820: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000020, 0x00000000]),
    FOLLOW_IDENT_in_functionDef822: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00020000]),
    FOLLOW_113_in_functionDef824: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000020, 0x00040000]),
    FOLLOW_IDENT_in_functionDef827: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x20000040, 0x00040000]),
    FOLLOW_EQUALS_in_functionDef831: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xCA040000, 0x00000007]),
    FOLLOW_defaultValue_in_functionDef834: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x20000000, 0x00040000]),
    FOLLOW_COMMA_in_functionDef839: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000020, 0x00000000]),
    FOLLOW_IDENT_in_functionDef841: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x20000000, 0x00040000]),
    FOLLOW_COMMA_in_functionDef848: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000020, 0x00000000]),
    FOLLOW_IDENT_in_functionDef850: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000040, 0x00000000]),
    FOLLOW_EQUALS_in_functionDef852: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xCA040000, 0x00000007]),
    FOLLOW_defaultValue_in_functionDef854: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x20000000, 0x00040000]),
    FOLLOW_114_in_functionDef861: new org.antlr.runtime.BitSet([0x00000000, 0x00000001]),
    FOLLOW_NEWLINE_in_functionDef863: new org.antlr.runtime.BitSet([0x00000000, 0xD0400441,0xCB0400B3, 0x00020007]),
    FOLLOW_innerBlock_in_functionDef866: new org.antlr.runtime.BitSet([0x00000000, 0x40000000]),
    FOLLOW_ENDBLOCK_in_functionDef869: new org.antlr.runtime.BitSet([0x00000000, 0x10000000]),
    FOLLOW_FUNCTIONSTATEMENT_in_functionDef871: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_TRYSTATEMENT_in_tryCatch904: new org.antlr.runtime.BitSet([0x00000000, 0x00000001]),
    FOLLOW_NEWLINE_in_tryCatch906: new org.antlr.runtime.BitSet([0x00000000, 0x90400441,0xCB0400BB, 0x00020007]),
    FOLLOW_innerBlock_in_tryCatch909: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000008, 0x00000000]),
    FOLLOW_CATCHSTATEMENT_in_tryCatch911: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000020, 0x00000000]),
    FOLLOW_IDENT_in_tryCatch913: new org.antlr.runtime.BitSet([0x00000000, 0x00000001]),
    FOLLOW_NEWLINE_in_tryCatch915: new org.antlr.runtime.BitSet([0x00000000, 0xD0400441,0xCB0400B3, 0x00020007]),
    FOLLOW_innerBlock_in_tryCatch919: new org.antlr.runtime.BitSet([0x00000000, 0x40000000]),
    FOLLOW_ENDBLOCK_in_tryCatch921: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000002, 0x00000000]),
    FOLLOW_TRYSTATEMENT_in_tryCatch923: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_THROWSTATEMENT_in_throwExp945: new org.antlr.runtime.BitSet([0x00000000, 0x10000000,0xCB0400A1, 0x00020007]),
    FOLLOW_primaryExpression_in_throwExp947: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_FUNCTIONSTATEMENT_in_anonFunctionDef967: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00020000]),
    FOLLOW_113_in_anonFunctionDef970: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000020, 0x00040000]),
    FOLLOW_IDENT_in_anonFunctionDef973: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x20000040, 0x00040000]),
    FOLLOW_EQUALS_in_anonFunctionDef977: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xCA040000, 0x00000007]),
    FOLLOW_defaultValue_in_anonFunctionDef980: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x20000000, 0x00040000]),
    FOLLOW_COMMA_in_anonFunctionDef985: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000020, 0x00000000]),
    FOLLOW_IDENT_in_anonFunctionDef987: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x20000000, 0x00040000]),
    FOLLOW_COMMA_in_anonFunctionDef994: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000020, 0x00000000]),
    FOLLOW_IDENT_in_anonFunctionDef996: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000040, 0x00000000]),
    FOLLOW_EQUALS_in_anonFunctionDef998: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xCA040000, 0x00000007]),
    FOLLOW_defaultValue_in_anonFunctionDef1000: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x20000000, 0x00040000]),
    FOLLOW_114_in_anonFunctionDef1007: new org.antlr.runtime.BitSet([0x00000000, 0x90400441,0xCB0400B3, 0x00020007]),
    FOLLOW_NEWLINE_in_anonFunctionDef1012: new org.antlr.runtime.BitSet([0x00000000, 0xD0400441,0xCB0400B3, 0x00020007]),
    FOLLOW_innerBlock_in_anonFunctionDef1015: new org.antlr.runtime.BitSet([0x00000000, 0x40000000]),
    FOLLOW_ENDBLOCK_in_anonFunctionDef1018: new org.antlr.runtime.BitSet([0x00000000, 0x10000000]),
    FOLLOW_FUNCTIONSTATEMENT_in_anonFunctionDef1020: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_expression_in_anonFunctionDef1025: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_IDENT_in_assignment1067: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00020000]),
    FOLLOW_113_in_assignment1069: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000020, 0x00040000]),
    FOLLOW_IDENT_in_assignment1072: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x20000040, 0x00040000]),
    FOLLOW_EQUALS_in_assignment1076: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xCA040000, 0x00000007]),
    FOLLOW_defaultValue_in_assignment1078: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x20000000, 0x00040000]),
    FOLLOW_COMMA_in_assignment1083: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000020, 0x00000000]),
    FOLLOW_IDENT_in_assignment1085: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x20000000, 0x00040000]),
    FOLLOW_COMMA_in_assignment1092: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000020, 0x00000000]),
    FOLLOW_IDENT_in_assignment1094: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000040, 0x00000000]),
    FOLLOW_EQUALS_in_assignment1096: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xCA040000, 0x00000007]),
    FOLLOW_defaultValue_in_assignment1098: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x20000000, 0x00040000]),
    FOLLOW_114_in_assignment1105: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00080000]),
    FOLLOW_115_in_assignment1107: new org.antlr.runtime.BitSet([0x00000000, 0x10000000,0xCB0400A1, 0x00020007]),
    FOLLOW_logicalExpression_in_assignment1109: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_PRIMITIVE_in_assignment1137: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x20000000, 0x00080000]),
    FOLLOW_assigned_in_assignment1141: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x20000000, 0x00080000]),
    FOLLOW_COMMA_in_assignment1145: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x000000A0, 0x00000000]),
    FOLLOW_PRIMITIVE_in_assignment1148: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x20000000, 0x00080000]),
    FOLLOW_assigned_in_assignment1152: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x20000000, 0x00080000]),
    FOLLOW_115_in_assignment1158: new org.antlr.runtime.BitSet([0x00000000, 0x10000000,0xCB0400A1, 0x00020007]),
    FOLLOW_logicalExpression_in_assignment1160: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_IDENT_in_assigned1186: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x0A000000, 0x00100000]),
    FOLLOW_selector_in_assigned1188: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_booleanXORExpression_in_logicalExpression1214: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000100, 0x00000000]),
    FOLLOW_OR_in_logicalExpression1217: new org.antlr.runtime.BitSet([0x00000000, 0x10000000,0xCB0400A1, 0x00020007]),
    FOLLOW_booleanXORExpression_in_logicalExpression1220: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000100, 0x00000000]),
    FOLLOW_booleanAndExpression_in_booleanXORExpression1250: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000200, 0x00000000]),
    FOLLOW_XOR_in_booleanXORExpression1253: new org.antlr.runtime.BitSet([0x00000000, 0x10000000,0xCB0400A1, 0x00020007]),
    FOLLOW_booleanAndExpression_in_booleanXORExpression1256: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000200, 0x00000000]),
    FOLLOW_equalityExpression_in_booleanAndExpression1285: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000800, 0x00000000]),
    FOLLOW_AND_in_booleanAndExpression1288: new org.antlr.runtime.BitSet([0x00000000, 0x10000000,0xCB0400A1, 0x00020007]),
    FOLLOW_equalityExpression_in_booleanAndExpression1291: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000800, 0x00000000]),
    FOLLOW_relationalExpression_in_equalityExpression1322: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00001040, 0x00000000]),
    FOLLOW_set_in_equalityExpression1325: new org.antlr.runtime.BitSet([0x00000000, 0x10000000,0xCB0400A1, 0x00020007]),
    FOLLOW_relationalExpression_in_equalityExpression1332: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00001040, 0x00000000]),
    FOLLOW_additiveExpression_in_relationalExpression1374: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x0001E000, 0x00000000]),
    FOLLOW_set_in_relationalExpression1378: new org.antlr.runtime.BitSet([0x00000000, 0x10000000,0xCB0400A1, 0x00020007]),
    FOLLOW_additiveExpression_in_relationalExpression1389: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x0001E000, 0x00000000]),
    FOLLOW_multiplicativeExpression_in_additiveExpression1432: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00060000, 0x00000000]),
    FOLLOW_set_in_additiveExpression1436: new org.antlr.runtime.BitSet([0x00000000, 0x10000000,0xCB0400A1, 0x00020007]),
    FOLLOW_multiplicativeExpression_in_additiveExpression1443: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00060000, 0x00000000]),
    FOLLOW_arrayExpression_in_multiplicativeExpression1473: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00380000, 0x00000000]),
    FOLLOW_set_in_multiplicativeExpression1477: new org.antlr.runtime.BitSet([0x00000000, 0x10000000,0xCB0400A1, 0x00020007]),
    FOLLOW_arrayExpression_in_multiplicativeExpression1486: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00380000, 0x00000000]),
    FOLLOW_negationExpression_in_arrayExpression1532: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00400000, 0x00000000]),
    FOLLOW_COLON_in_arrayExpression1538: new org.antlr.runtime.BitSet([0x00000000, 0x10000000,0xCB0400A1, 0x00020007]),
    FOLLOW_negationExpression_in_arrayExpression1542: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00400000, 0x00000000]),
    FOLLOW_COLON_in_arrayExpression1551: new org.antlr.runtime.BitSet([0x00000000, 0x10000000,0xCB0400A1, 0x00020007]),
    FOLLOW_negationExpression_in_arrayExpression1555: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_MINUS_in_negationExpression1580: new org.antlr.runtime.BitSet([0x00000000, 0x10000000,0xCB0400A1, 0x00020007]),
    FOLLOW_powerExpression_in_negationExpression1582: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_powerExpression_in_negationExpression1596: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_unaryExpression_in_powerExpression1607: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00800000, 0x00000000]),
    FOLLOW_POW_in_powerExpression1610: new org.antlr.runtime.BitSet([0x00000000, 0x10000000,0xCB0400A1, 0x00020007]),
    FOLLOW_unaryOrNegate_in_powerExpression1612: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00800000, 0x00000000]),
    FOLLOW_unaryExpression_in_unaryOrNegate1639: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_MINUS_in_unaryOrNegate1645: new org.antlr.runtime.BitSet([0x00000000, 0x10000000,0xCB0400A1, 0x00020007]),
    FOLLOW_unaryExpression_in_unaryOrNegate1647: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_NOT_in_unaryExpression1675: new org.antlr.runtime.BitSet([0x00000000, 0x10000000,0xCB0400A1, 0x00020007]),
    FOLLOW_innerPrimaryExpression_in_unaryExpression1678: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_innerPrimaryExpression_in_unaryExpression1687: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_selectionExpression_in_innerPrimaryExpression1718: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_primaryExpression_in_selectionExpression1738: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x0A000000, 0x00120000]),
    FOLLOW_selector_in_selectionExpression1744: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x0A000000, 0x00120000]),
    FOLLOW_funCall_in_selectionExpression1746: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x0A000000, 0x00120000]),
    FOLLOW_113_in_funCall1761: new org.antlr.runtime.BitSet([0x00000000, 0x10000000,0xCB0400A1, 0x00060007]),
    FOLLOW_logicalExpression_in_funCall1765: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x20000000, 0x00040000]),
    FOLLOW_COMMA_in_funCall1768: new org.antlr.runtime.BitSet([0x00000000, 0x10000000,0xCB0400A1, 0x00020007]),
    FOLLOW_logicalExpression_in_funCall1770: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x20000000, 0x00040000]),
    FOLLOW_114_in_funCall1777: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_113_in_primaryExpression1798: new org.antlr.runtime.BitSet([0x00000000, 0x10000000,0xCB0400A1, 0x00020007]),
    FOLLOW_logicalExpression_in_primaryExpression1801: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00040000]),
    FOLLOW_114_in_primaryExpression1803: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_value_in_primaryExpression1809: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_number_in_value1823: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_bool_in_value1829: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_string_in_value1835: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_material_in_value1841: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_IDENT_in_value1846: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_primitive_in_value1851: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_array_in_value1856: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_anonFunctionDef_in_value1861: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_newObject_in_value1866: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_NEWSTATEMENT_in_newObject1876: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000020, 0x00000000]),
    FOLLOW_IDENT_in_newObject1878: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x0A000000, 0x00120000]),
    FOLLOW_funCall_in_newObject1880: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_negnumber_in_defaultValue1906: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_number_in_defaultValue1912: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_bool_in_defaultValue1918: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_string_in_defaultValue1924: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_array_in_defaultValue1930: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_LARR_in_array1944: new org.antlr.runtime.BitSet([0x00000000, 0x10000001,0xCF0C00A1, 0x00020007]),
    FOLLOW_NEWLINE_in_array1946: new org.antlr.runtime.BitSet([0x00000000, 0x10000001,0xCF0C00A1, 0x00020007]),
    FOLLOW_label_in_array1950: new org.antlr.runtime.BitSet([0x00000000, 0x00000001,0x24000000, 0x00000000]),
    FOLLOW_NEWLINE_in_array1952: new org.antlr.runtime.BitSet([0x00000000, 0x00000001,0x24000000, 0x00000000]),
    FOLLOW_COMMA_in_array1956: new org.antlr.runtime.BitSet([0x00000000, 0x10000001,0xCB0C00A1, 0x00020007]),
    FOLLOW_NEWLINE_in_array1958: new org.antlr.runtime.BitSet([0x00000000, 0x10000001,0xCB0C00A1, 0x00020007]),
    FOLLOW_label_in_array1961: new org.antlr.runtime.BitSet([0x00000000, 0x00000001,0x24000000, 0x00000000]),
    FOLLOW_NEWLINE_in_array1963: new org.antlr.runtime.BitSet([0x00000000, 0x00000001,0x24000000, 0x00000000]),
    FOLLOW_NEWLINE_in_array1970: new org.antlr.runtime.BitSet([0x00000000, 0x00000001,0x04000000, 0x00000000]),
    FOLLOW_RARR_in_array1973: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_LCURL_in_array1987: new org.antlr.runtime.BitSet([0x00000000, 0x10000001,0xDB0C00A1, 0x00020007]),
    FOLLOW_NEWLINE_in_array1989: new org.antlr.runtime.BitSet([0x00000000, 0x10000001,0xDB0C00A1, 0x00020007]),
    FOLLOW_label_in_array1993: new org.antlr.runtime.BitSet([0x00000000, 0x00000001,0x30000000, 0x00000000]),
    FOLLOW_NEWLINE_in_array1995: new org.antlr.runtime.BitSet([0x00000000, 0x00000001,0x30000000, 0x00000000]),
    FOLLOW_COMMA_in_array1998: new org.antlr.runtime.BitSet([0x00000000, 0x10000001,0xCB0C00A1, 0x00020007]),
    FOLLOW_NEWLINE_in_array2000: new org.antlr.runtime.BitSet([0x00000000, 0x10000001,0xCB0C00A1, 0x00020007]),
    FOLLOW_label_in_array2003: new org.antlr.runtime.BitSet([0x00000000, 0x00000001,0x30000000, 0x00000000]),
    FOLLOW_NEWLINE_in_array2005: new org.antlr.runtime.BitSet([0x00000000, 0x00000001,0x30000000, 0x00000000]),
    FOLLOW_NEWLINE_in_array2012: new org.antlr.runtime.BitSet([0x00000000, 0x00000001,0x10000000, 0x00000000]),
    FOLLOW_RCURL_in_array2015: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_minarray_in_selector2036: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_dotselector_in_selector2040: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_LARR_in_minarray2067: new org.antlr.runtime.BitSet([0x00000000, 0x10000000,0xCB0C00A1, 0x00020007]),
    FOLLOW_logicalExpression_in_minarray2072: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x24000000, 0x00000000]),
    FOLLOW_MULT_in_minarray2074: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x24000000, 0x00000000]),
    FOLLOW_COMMA_in_minarray2078: new org.antlr.runtime.BitSet([0x00000000, 0x10000000,0xCB0C00A1, 0x00020007]),
    FOLLOW_logicalExpression_in_minarray2082: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x24000000, 0x00000000]),
    FOLLOW_MULT_in_minarray2084: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x24000000, 0x00000000]),
    FOLLOW_RARR_in_minarray2091: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_LCURL_in_minarray2097: new org.antlr.runtime.BitSet([0x00000000, 0x10000000,0xCB0C00A1, 0x00020007]),
    FOLLOW_logicalExpression_in_minarray2102: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x30000000, 0x00000000]),
    FOLLOW_MULT_in_minarray2104: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x30000000, 0x00000000]),
    FOLLOW_COMMA_in_minarray2108: new org.antlr.runtime.BitSet([0x00000000, 0x10000000,0xCB0C00A1, 0x00020007]),
    FOLLOW_logicalExpression_in_minarray2112: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x30000000, 0x00000000]),
    FOLLOW_MULT_in_minarray2114: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x30000000, 0x00000000]),
    FOLLOW_RCURL_in_minarray2121: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_116_in_dotselector2133: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x40080020, 0x00000000]),
    FOLLOW_arrayName_in_dotselector2135: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00100000]),
    FOLLOW_set_in_arrayName0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_arrayName_in_label2173: new org.antlr.runtime.BitSet([0x00000000, 0x00000001,0x00400000, 0x00000000]),
    FOLLOW_NEWLINE_in_label2175: new org.antlr.runtime.BitSet([0x00000000, 0x00000001,0x00400000, 0x00000000]),
    FOLLOW_COLON_in_label2178: new org.antlr.runtime.BitSet([0x00000000, 0x10000001,0xCB0400A1, 0x00020007]),
    FOLLOW_NEWLINE_in_label2182: new org.antlr.runtime.BitSet([0x00000000, 0x10000001,0xCB0400A1, 0x00020007]),
    FOLLOW_logicalExpression_in_label2185: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_set_in_number0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_MINUS_in_negnumber2261: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x80000000, 0x00000001]),
    FOLLOW_number_in_negnumber2263: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_set_in_bool0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_LCURL_in_material2415: new org.antlr.runtime.BitSet([0x00000000, 0x10000000,0xCB0400A1, 0x00020007]),
    FOLLOW_additiveExpression_in_material2417: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x80000020, 0x00020000]),
    FOLLOW_unitMultiplicativeExpression_in_material2421: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x10000000, 0x00000000]),
    FOLLOW_RCURL_in_material2423: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_unitInnerMultiplicativeExpression_in_unitMultiplicativeExpression2460: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000008]),
    FOLLOW_PER_in_unitMultiplicativeExpression2464: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x80000020, 0x00020000]),
    FOLLOW_unitInnerMultiplicativeExpression_in_unitMultiplicativeExpression2467: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000008]),
    FOLLOW_unitClump_in_unitInnerMultiplicativeExpression2483: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00180000, 0x00000000]),
    FOLLOW_set_in_unitInnerMultiplicativeExpression2487: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x80000020, 0x00020000]),
    FOLLOW_unitClump_in_unitInnerMultiplicativeExpression2494: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00180000, 0x00000000]),
    FOLLOW_INTEGER_in_unitClump2510: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_DIV_in_unitClump2512: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x80000020, 0x00020000]),
    FOLLOW_unitPowerExpression_in_unitClump2515: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000030]),
    FOLLOW_CUBED_in_unitClump2517: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000020]),
    FOLLOW_SQUARED_in_unitClump2520: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_unitPowerExpression_in_unitClump2543: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000030]),
    FOLLOW_CUBED_in_unitClump2545: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000020]),
    FOLLOW_SQUARED_in_unitClump2548: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_unit_in_unitPowerExpression2610: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00800000, 0x00000000]),
    FOLLOW_POW_in_unitPowerExpression2614: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x80040000, 0x00000001]),
    FOLLOW_MINUS_in_unitPowerExpression2617: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x80000000, 0x00000001]),
    FOLLOW_set_in_unitPowerExpression2620: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00800000, 0x00000000]),
    FOLLOW_IDENT_in_unit2638: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000020, 0x00000000]),
    FOLLOW_IDENT_in_unit2641: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000020, 0x00000000]),
    FOLLOW_113_in_unit2658: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x80000020, 0x00020000]),
    FOLLOW_unitMultiplicativeExpression_in_unit2660: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00040000]),
    FOLLOW_114_in_unit2662: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_PRIMITIVE_in_primitive2731: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_STRING_in_string3200: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_assignment_in_synpred5_Formula508: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_logicalExpression_in_synpred6_Formula514: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_forLoop_in_synpred8_Formula526: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_forInLoop_in_synpred9_Formula532: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_functionDef_in_synpred11_Formula544: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_OR_in_synpred47_Formula1217: new org.antlr.runtime.BitSet([0x00000000, 0x10000000,0xCB0400A1, 0x00020007]),
    FOLLOW_booleanXORExpression_in_synpred47_Formula1220: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_XOR_in_synpred48_Formula1253: new org.antlr.runtime.BitSet([0x00000000, 0x10000000,0xCB0400A1, 0x00020007]),
    FOLLOW_booleanAndExpression_in_synpred48_Formula1256: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_AND_in_synpred49_Formula1288: new org.antlr.runtime.BitSet([0x00000000, 0x10000000,0xCB0400A1, 0x00020007]),
    FOLLOW_equalityExpression_in_synpred49_Formula1291: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_set_in_synpred51_Formula1325: new org.antlr.runtime.BitSet([0x00000000, 0x10000000,0xCB0400A1, 0x00020007]),
    FOLLOW_relationalExpression_in_synpred51_Formula1332: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_set_in_synpred55_Formula1378: new org.antlr.runtime.BitSet([0x00000000, 0x10000000,0xCB0400A1, 0x00020007]),
    FOLLOW_additiveExpression_in_synpred55_Formula1389: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_set_in_synpred57_Formula1436: new org.antlr.runtime.BitSet([0x00000000, 0x10000000,0xCB0400A1, 0x00020007]),
    FOLLOW_multiplicativeExpression_in_synpred57_Formula1443: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_set_in_synpred60_Formula1477: new org.antlr.runtime.BitSet([0x00000000, 0x10000000,0xCB0400A1, 0x00020007]),
    FOLLOW_arrayExpression_in_synpred60_Formula1486: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_COLON_in_synpred61_Formula1538: new org.antlr.runtime.BitSet([0x00000000, 0x10000000,0xCB0400A1, 0x00020007]),
    FOLLOW_negationExpression_in_synpred61_Formula1542: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_COLON_in_synpred62_Formula1551: new org.antlr.runtime.BitSet([0x00000000, 0x10000000,0xCB0400A1, 0x00020007]),
    FOLLOW_negationExpression_in_synpred62_Formula1555: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_POW_in_synpred64_Formula1610: new org.antlr.runtime.BitSet([0x00000000, 0x10000000,0xCB0400A1, 0x00020007]),
    FOLLOW_unaryOrNegate_in_synpred64_Formula1612: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_selector_in_synpred68_Formula1744: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_funCall_in_synpred68_Formula1746: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_material_in_synpred75_Formula1841: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_array_in_synpred78_Formula1856: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_funCall_in_synpred80_Formula1880: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_NEWLINE_in_synpred85_Formula1946: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_NEWLINE_in_synpred86_Formula1952: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_NEWLINE_in_synpred87_Formula1958: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_NEWLINE_in_synpred88_Formula1963: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_NEWLINE_in_synpred93_Formula1989: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_NEWLINE_in_synpred94_Formula1995: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_NEWLINE_in_synpred95_Formula2000: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_NEWLINE_in_synpred96_Formula2005: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_116_in_synpred108_Formula2133: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x40080020, 0x00000000]),
    FOLLOW_arrayName_in_synpred108_Formula2135: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_arrayName_in_synpred112_Formula2173: new org.antlr.runtime.BitSet([0x00000000, 0x00000001,0x00400000, 0x00000000]),
    FOLLOW_NEWLINE_in_synpred112_Formula2175: new org.antlr.runtime.BitSet([0x00000000, 0x00000001,0x00400000, 0x00000000]),
    FOLLOW_COLON_in_synpred112_Formula2178: new org.antlr.runtime.BitSet([0x00000002, 0x00000000])
});

})();

"use strict";
/*

Copyright 2010-2020 Scott Fortmann-Roe. All rights reserved.

This file may distributed and/or modified under the
terms of the Insight Maker Public License (https://InsightMaker.com/impl).

*/

function Simulator(config) {

	this.randLoc = -1;
	this.lastRandPos = -1;
	this.previousRandLists = [];
	this.valuedPrimitives = [];
	this.unitsToBases = {};

	this.distanceCache = {};


	this.sliders = {};

	this.ids = {};
	this.idCount = 0;

	this.stochastic = false;

}

Simulator.prototype.setup = function (config) {


	this.model = config.model;

	this.solversCompletedFirstPass = 0;

	this.timeStart = this.model.timeStart;
	this.timeLength = this.model.timeLength;
	this.timePause = this.model.timePause;
	this.timeEnd = plus(this.timeStart, this.timeLength);
	this.timeStep = this.model.solvers.base.timeStep;
	this.userTimeStep = this.model.solvers.base.userTimeStep;
	this.timeUnits = this.timeStart.units;
	this.timeUnits.addBase();

	this.oldAggregateSeries = [];
	this.distanceCache = {};
	this.tasks = new TaskQueue({
		start: this.timeStart,
		end: this.timeEnd
	});

}

Simulator.prototype.getID = function (x) {
	//console.log(x);
	if (!this.ids[x]) {
		this.idCount++;
		this.ids[x] = this.idCount;
	}
	//console.log(this.ids[x])
	return this.ids[x];
}

Simulator.prototype.time = function () {
	return this.tasks.time;
}

Simulator.prototype.timeProgressed = function () {
	return minus(this.time(), this.timeStart);
}

Simulator.prototype.frame = function (valued, displayed) {
	var l = valued.length;
	for (var i = 0; i < l; i++) {
		valued[i].storeValue();
	}

	this.printStates(displayed);
}

Simulator.prototype.step = function (solver) {
	if (!solver.completedFirstPass) {
		solver.completedFirstPass = true;
		this.solversCompletedFirstPass++;
		if (this.solversCompletedFirstPass == Object.keys(this.model.solvers).length) {
			if (this.config.onCompletedFirstPass) {
				this.config.onCompletedFirstPass();
			}
		}
	}

	if (solver.displayed.length > 0) {
		for (var i = this.results[solver.displayed[0].id].results.length; i < this.results.Time.length; i++) {
			for (var j = 0; j < solver.displayed.length; j++) {
				this.results[solver.displayed[j].id].results.push(this.results.data[i][solver.displayed[j].id])
			}
		}
	}

	if (this.config.onStep) {
		this.config.onStep(solver);
	}
}

Simulator.prototype.sleep = function (updateWindow) {
	var me = this;

	if (this.config) {
		if (!this.config.silent) {
			if (!window.storyConverter) {
				this.shouldSleep = true;
			} else {
				this.shouldSleep = false;
			}
			this.shouldUpdateScripter = updateWindow;
		} else {
			if (this.config.onPause) {

				this.shouldSleep = true;

			}
		}
	}

}

Simulator.prototype.resume = function () {

	try {
		this.run();
	} catch (err) {
		return checkErr(err, this.config);
	}

}

Simulator.prototype.completed = function () {
	return this.terminated || this.tasks.completed();
}

Simulator.prototype.terminate = function () {
	if (!this.terminated) {
		clearTimeout(this.timer);
		this.sleep();
		this.terminated = true;
		if (this.resultsWindow) {
			this.resultsWindow.scripter.finished();
		}
	}
}

Simulator.prototype.run = function (config) {
	var me = this;

	var addPause = function (time, repeat) {
		me.tasks.add(new Task({
			time: time,
			expires: 1,
			name: "Interval Pause",
			priority: 1,
			action: function () {
				me.sleep(true);
				if (repeat && lessThan(plus(time, me.timePause), me.timeEnd)) {
					addPause(plus(time, me.timePause), repeat);
				}
			}
		}));

		me.tasks.add(new Task({
			time: time,
			expires: 1,
			name: "Interval Pause",
			priority: 1,
			action: function () {
				if (me.valueChange) {
					simulate.valuedPrimitives = [];
					for (var s in me.model.solvers) {
						var solver = me.model.solvers[s];
						for (var i = 0; i < solver.valued.length; i++) {
							solver.valued[i].clearCached();
						}
						for (var i = 0; i < solver.flows.length; i++) {
							solver.flows[i].predict(true);
						}
					}
					me.valueChange = false;
				}
			}
		}));
	}

	if (config) {
		this.config = config;

		var solvers = Object.keys(this.model.solvers);
		for (var i = 0; i < solvers.length; i++) {
			this.createSolver(this.model.solvers[solvers[i]]);
		}

		if (this.timePause /*&& (! this.config.silent)*/ && (!window.storyConverter)) {
			addPause(plus(this.timeStart, this.timePause), true);
		}

		this.tasks.tasks.goMin();
	}

	this.wakeUpTime = (new Date()).getTime();

	try {
		while (!this.completed()) {
			this.tasks.step();

			if (this.shouldSleep) {
				for (let solver in this.model.solvers) {
					updateDisplayed(this.model.solvers[solver]);
				}
				if (this.shouldUpdateScripter) {
					this.resultsWindow.scripter.endMode = "pause";
					this.shouldUpdateScripter = false;
				}
				if (this.config.onPause) {
					setTimeout((function () {
						/*console.log(this);
						console.log(this.results);
						return;*/
						var res = formatSimResults(this.results);
						var l = res.data.length;
						var data = res.data[l - 1];
						for (var key in data) {
							if (res[key].results.length < l) {
								res[key].results.push(data[key]);
							}
						}

						res.resume = me.resume.bind(this);
						res.setValue = function (cell, value) {
							var val = simpleEquation("" + value, { "-parent": varBank });
							/*if(! this.sliders[cell.id]){
								throw "Primitive '" + getName(cell) + "' must have a slider defined for it to change its value.";
							}

							for (var i = 0; i < this.sliders[cell.id].length; i++) {
								this.sliders[cell.id][i].equation = val;
							}
							this.sliders[cell.id][0].dna.equation = val;*/
							this.valuedPrimitives.forEach(function (x) {
								if (x.id == cell.id) {
									if (val.fullClone) {
										x.dna.equation = val.fullClone();
										x.equation = val.fullClone();
									} else {
										x.dna.equation = val;
										x.equation = val;
									}
								}
							})
							this.valueChange = true;
						}.bind(this);

						me.config.onPause(res);
					}).bind(this), 10);
				}

				this.shouldSleep = false;
				return;
			}
		}

	} catch (err) {
		if (err.msg != "STOP") {
			throw err;
		}
	}


	this.results = formatSimResults(this.results);


	this.results.stochastic = this.stochastic;

	if (this.config.onSuccess) {
		this.config.onSuccess(this.results);
	}

	this.terminate();

	if (this.resultsWindow) {
		this.results.window = this.resultsWindow;
		for (let solver in this.model.solvers) {
			updateDisplayed(this.model.solvers[solver]);
		}
	}

	return this.results;
}

Simulator.prototype.progress = function () {
	return div(minus(this.time(), this.timeStart), this.timeLength).value;
}

Simulator.prototype.printStates = function (displayed) {
	var t = parseFloat(this.time().value.toPrecision(20));

	if (this.results.Time.indexOf(t) == -1) {
		for (var i = this.results.Time.length; i > 0; i--) {
			if (this.results.Time[i - 1] < t) {
				this.results.Time.splice(i, 0, t)
				this.results.data.splice(i, 0, {})
				break;
			}
		}
		if (i == 0) {
			this.results.Time.splice(0, 0, t)
			this.results.data.splice(0, 0, {})
		}
	}

	var data = this.results.data[this.results.Time.indexOf(t)];

	for (var i = 0; i < displayed.length; i++) {
		var v = displayed[i];

		if (!((v instanceof State) && isDefined(data[v.id]))) {
			if (v instanceof Agents) {
				this.results[v.id].dataMode = "agents";
				data[v.id] = { current: v.collectData() };
			} else {
				var x = v.value();

				if ((x instanceof Vector) && (!x.names)) {
					x.recurseApply((x) => {
						return this.adjustNum(v, x);
					});
					data[v.id] = x;
					this.results[v.id].dataMode = "auto";
				} else if (x instanceof Vector) {
					x.recurseApply((x) => {
						return this.adjustNum(v, x);
					});
					data[v.id] = x;
				} else if (x instanceof Agent) {
					data[v.id] = x;
					this.results[v.id].dataMode = "auto";
				} else {
					data[v.id] = this.adjustNum(v, x);
				}

			}
		}
	}
}

Simulator.prototype.unitsToBase = function (v, u, flow) {
	var i = v.id + "-" + (u ? u.id : "");

	if (i in this.unitsToBases) {
		return this.unitsToBases[i];
	}

	var x = 1;
	if (flow) {
		x = this.timeUnits.toBase;
	}
	var toBase = 1;
	if (u) {
		u.addBase();
		toBase = u.toBase;
	}
	this.unitsToBases[i] = fn["/"](fn["/"](sn("#e" + toBase), v.dna.toBase), sn("#e" + x));
	return this.unitsToBases[i];

}

Simulator.prototype.adjustNum = function (v, x) {
	if (v.unitless && x.units) {
		error(getText("The result of the calculation has units %s, but the primitive is unitless. Please set the units for the primitive so we can determine the proper output.", x.units.toString()), findID(v.id), true);
	}

	if ((v instanceof Flow) && (!v.dna.flowUnitless)) {
		x = mult(x, new Material(1, this.timeUnits));
	}

	if ((v instanceof State) || ((!x.units) && (!(v instanceof Flow)))) {
		if (typeof x === 'object' && 'value' in x) {
			return +x.value;
		}
		// string, boolean, ...
		return x;
	} else {
		x = fn["*"](x.value, this.unitsToBase(v, x.units, v instanceof Flow));
	}

	return +x;
}

Simulator.prototype.createSolver = function (solver) {
	var me = this;

	var stocks = solver.stocks;
	var flows = solver.flows;

	var actions = solver.actions;
	var transitions = solver.transitions;
	var valued = solver.valued;
	var displayed = solver.displayed;

	var id = solver.id;

	var timeStep = solver.timeStep;
	var RKOrder = solver.RKOrder;
	solver.RKPosition = 1;

	var ts = timeStep.value;
	ts = ts.toPrecision();
	if (ts.indexOf(".") == -1) {
		var timeStepDecimals = 0;
	} else {
		var timeStepDecimals = ts.length - ts.indexOf(".") - 1;
	}
	var timeStepScaled = parseFloat(ts.replace(".", ""));

	var index = 0;
	var times = [];
	var maxIndex = Math.ceil((me.timeEnd.value - me.timeStart.value) / timeStep.value)
	for (var i = 0; i <= maxIndex + 2; i++) {
		times.push(new Material(me.timeStart.value + i * timeStepScaled / Math.pow(10, timeStepDecimals), timeStep.units));
	}


	var l = actions.length;
	for (var i = 0; i < l; i++) {
		if (actions[i].dna.trigger !== "Condition") {
			updateTrigger.call(actions[i]);
		}
	}

	var l = transitions.length;
	for (var i = 0; i < l; i++) {
		updateTrigger.call(transitions[i]);
	}


	function addRK1Solver(time, repeat, clear) {
		me.tasks.add(new Task({
			time: time,
			expires: 1,
			name: "RK1 Solver - " + solver.id,
			action: function () {
				simulate.valuedPrimitives = [];
				if (clear) {
					var l = flows.length;
					for (var i = 0; i < l; i++) {
						flows[i].clean();
					}


					l = valued.length;
					for (var i = 0; i < l; i++) {
						valued[i].clearCached();
					}
				}

				me.frame(valued, displayed);

				var l = actions.length;
				for (var i = 0; i < l; i++) {
					if (actions[i].dna.recalculate && !actions[i].block) {
						updateTrigger.call(actions[i]);
					}
				}

				l = transitions.length;
				for (var i = 0; i < l; i++) {
					if (transitions[i].dna.recalculate) {
						updateTrigger.call(transitions[i]);
					}
				}
				//console.log("B")
				me.step(solver);


				if (repeat && index <= maxIndex) {
					index++;
					addRK1Solver(times[index], true, true)
				}

			}
		})
		);
	}

	function addRK4Solver(time, repeat) {
		/*

		1. (t=0) Calculate rates at t=0, move to t=0.5 (rollback restore stocks)
		2. (t=0.5) Calculate rates at t=0.5
		3. (t=0) Use rate of (t=0.5) to move to t=0.5 (rollback restores stocks)
		4. (t=0.5) Calculate rates at t=0.5
		5. (t=0) Use rates of (t=0.5 (2)) to move to t=1 (rollback restores stocks)
		6. (t=1) Calculate rates at t=1
		7. (t=0) Use average rates to move to t=0

		*/


		me.tasks.add(new Task({
			time: time,
			name: "RK4 Solver (Init)  - " + solver.id,
			priority: -10,
			expires: 1,
			blocker: id + " init",
			action: function () {


				var l = flows.length;
				for (var i = 0; i < l; i++) {
					flows[i].clean();
				}

				simulate.valuedPrimitives = [];

				l = valued.length;
				for (var i = 0; i < l; i++) {
					valued[i].clearCached();
				}

				solver.RKPosition = 1;

				this.unblock(id + " start");
				this.block();
			}
		})
		);
		me.tasks.add(new Task({
			time: time,
			name: "RK4 Solver (step 1) - " + solver.id,
			priority: -5,
			expires: 4,
			blocker: id + " start",
			action: function () {
				if (solver.RKPosition > 1) {
					simulate.valuedPrimitives = [];
					var l = valued.length;
					for (var i = 0; i < l; i++) {
						valued[i].clearCached();
						valued[i].pastValues.pop();
					}
				}

				me.frame(valued, displayed);

				if (solver.RKPosition == 4) {

					var l = actions.length;
					for (var i = 0; i < l; i++) {
						if (actions[i].dna.recalculate && !actions[i].block) {
							updateTrigger.call(actions[i]);
						}
					}

					l = transitions.length;
					for (var i = 0; i < l; i++) {
						if (transitions[i].dna.recalculate) {
							updateTrigger.call(transitions[i]);
						}
					}

					this.unblock(id + " init")

					if (repeat && index <= maxIndex) {
						index += 2;
						addRK4Solver(times[index], true)
					}

					me.step(solver);
				} else if (eq(simulate.time(), simulate.timeEnd)) {
					me.step(solver);
				} else {
					var l = stocks.length;
					for (var i = 0; i < l; i++) {
						stocks[i].preserveLevel();
					}
				}

				this.block();
				this.unblock(id + " mid")
			},
			rollback: function () {
				var l = stocks.length;
				for (var i = 0; i < l; i++) {
					stocks[i].restoreLevel();
				}

			}
		})
		);
		me.tasks.add(new Task({
			time: times[index + 1],
			name: "RK4 Solver (step 2,3) - " + solver.id,
			priority: -10,
			expires: 2,
			blocker: id + " mid",
			action: function () {

				simulate.valuedPrimitives = [];
				var l = valued.length;
				for (var i = 0; i < l; i++) {
					if (!(valued[i] instanceof State)) {
						valued[i].clearCached();
					}
				}


				solver.RKPosition++;

				l = flows.length;
				for (var i = 0; i < l; i++) {
					flows[i].rate = null;
					flows[i].predict();

				}

				this.unblock(id + " start");
				this.block();
			},
			timeShift: function () {

				me.tasks.moveTo(times[index]);
			}
		})
		);

		me.tasks.add(new Task({
			time: times[index + 2],
			name: "RK4 Solver (step 4) - " + solver.id,
			priority: -30,
			expires: 1,
			action: function () {

				simulate.valuedPrimitives = [];
				var l = valued.length;
				for (var i = 0; i < l; i++) {
					if (!(valued[i] instanceof State)) {
						valued[i].clearCached();
					}

				}

				solver.RKPosition++;

				l = flows.length;
				for (var i = 0; i < l; i++) {
					flows[i].rate = null;
					flows[i].predict();
				}

				this.unblock(id + " start");
			},
			timeShift: function () {

				me.tasks.moveTo(times[index]);
			}
		})
		);
	}

	function valMatches(val, fn) {
		if (val instanceof Vector) {
			var matches = false;
			val.recurseApply(function (x) {
				matches = matches || fn(x);
			});
			return matches;
		} else {
			return fn(val);
		}
	}

	function valHasNegative(val) {
		return val && valMatches(val.toNum(), function (x) { return (x instanceof Material) && x.value < 0 });
	}

	function valHasPositive(val) {
		return val && valMatches(val.toNum(), function (x) { return (x instanceof Material) && x.value > 0 });
	}

	function doFlows(timeChange, oldTime, newTime) {
		var l = flows.length;
		var post = [];
		for (var i = 0; i < l; i++) {
			if (flows[i].alpha && flows[i].alpha.dna.nonNegative && valHasPositive(flows[i].rate)) {
				post.push(flows[i]);
			} else if (flows[i].omega && flows[i].omega.dna.nonNegative && valHasNegative(flows[i].rate)) {
				post.push(flows[i]);
			} else {
				flows[i].apply(timeChange, oldTime, newTime);
			}
		}
		for (var i = 0; i < post.length; i++) {
			post[i].apply(timeChange, oldTime, newTime);
		}
	}


	if (RKOrder == 1) {
		this.tasks.addEvent(function (timeChange, oldTime, newTime) {
			doFlows.apply(null, arguments);
		})

		addRK1Solver(this.timeStart, true);
	} else if (RKOrder == 4) {

		this.tasks.addEvent(function (timeChange, oldTime, newTime) {
			if (timeChange.value > 0) {
				doFlows.apply(null, arguments);
			}
		});

		addRK4Solver(this.timeStart, true);

	} else {
		throw "Unknown solution algorithm."
	}
}


"use strict";
/*

Copyright 2010-2018 Scott Fortmann-Roe. All rights reserved.

This file may distributed and/or modified under the
terms of the Insight Maker Public License (https://InsightMaker.com/impl).

*/


var baseSources = ["Degree", "Radians?","Ampere","Gram","Second","Meter","(Meters? ?Squared?|Squared? ?Meters?)", "(Centimeters? ?Squared?|Squared? ?Centimeters?)", "(Centimeters? ?Cubed?|Cubic ?Centimeters?)", "(Meters? Cubed?|Cubic ?Meters?)", "(Kilometers? ?Cubed?|Cubic ?Kilometers?)", "(Inches? Squared?|Squared? ?Inches?)", "(Miles? ?Squared?|Squared? ?Miles?)", "(Kilometers? Squared?|Squared? ?Kilometers?)", "Acre? ?(Feet|Foot)", "Meters? ?per ?Seconds?", "Meters? ?per ?Seconds? ?Squared?", "(Foot|Feet) ?per ?Seconds?", "(Foot|Feet) ?per ?Seconds? ?Squared?", "Miles? ?per ?Hours?", "Miles? ?per ?Hours? ?Squared?", "Kilometers? ?per ?Hours?", "Kilometers? ?per ?Hours? ?Squared?", "Liters? ?per ?Seconds?", "(Cubic ?Meters?|Meters? ?Cubed?) ?per ?Seconds?", "(Squared? ?Yards?|Yards? ?Squared?)", "(Squared? ?(Feet|Foot)|(Feet|Foot) ?Squared?)", "(Squared? Millimeters?|Millimeters? ?Squared?)", "(Millimeters? ?Cubed?|Cubic ?Millimeters?)", "Gallons? ?per ?Seconds?", "Gallons? ?per ?Minutes?", "Pounds? ?per ?Seconds?", "Kilograms? ?per ?Seconds?", "Dollars? ?per ?Seconds?", "Dollars? ?per ?Hours?", "Dollars? ?per ?Days?", "Dollars? ?per ?Weeks?", "Dollars? ?per ?Months?", "Dollars? ?per ?Quarters?", "Dollars? ?per ?Years?", "Euros? ?per ?Seconds?", "Euros? ?per ?Hours?", "Euros? ?per ?Days?", "Euros? ?per ?Weeks?", "Euros? ?per ?Months?", "Euros? ?per ?Quarters?", "Euros? ?per ?Years?", "Centimeters?", "Millimeters?", "Kilometers?", "Inch(es)?", "(Foot|Feet)", "Yards?", "Miles?", "Acres?", "Hectares?", "Liters?", "Gallons?", "Quarts?", "Fluid ?Ounces?", "Years?", "Quarters?", "Months?", "Weeks?", "Days?", "Hours?", "Minutes?", "Kilograms?", "Milligrams?", "Ounces?", "Pounds?", "Tonnes?", "Tons?", "Watts?", "Kilowatts?", "Megawatts?", "Gigawatts?", "Calories?", "Kilocalories?", "(BTUs?|British ?Thermal ?units?)", "Kilojoules?", "Joules?", "Coulombs?", "Volts?", "Millivolts?", "Kilovolts?", "Newtons?", "Pounds? ?Force", "Atoms?", "Molecules?", "Farads?", "Pascals?", "Kilopascals?", "Bars?", "Atmospheres?", "Pounds? ?per ?Squared? ?Inch(es)?"];
var baseTargets = ["Degrees", "Degrees", "Amperes","Grams","Seconds","Meters","Meters^2", "Centimeters^2", "Centimeters^3", "Meters^3", "Kilometers^3", "Inches^2", "Miles^2", "Kilometers^2", "Acres,Feet", "Meters,Seconds^-1", "Meters,Seconds^-2", "Feet,Seconds^-1", "Feet,Seconds^-2", "Miles,Hours^-1", "Miles,Hours^-2", "Kilometers,Hours^-1", "Kilometers,Hours^-2", "Liters,Seconds^-1", "Meters^3,Seconds^-1", "Yards^2", "Feet^2", "Millimeters^2", "Millimeters^3", "Gallons,Seconds^-1", "Gallons,Minutes^-1", "Pounds,Seconds^-1", "Kilograms,Seconds^-1", "Dollars,Seconds^-1", "Dollars,Hours^-1", "Dollars,Days^-1", "Dollars,Weeks^-1", "Dollars,Months^-1", "Dollars,Quarters^-1", "Dollars,Years^-1", "Euros,Seconds^-1", "Euros,Hours^-1", "Euros,Days^-1", "Euros,Weeks^-1", "Euros,Months^-1", "Euros,Quarters^-1", "Euros,Years^-1", "Meters", "Meters", "Meters", "Meters", "Meters", "Meters", "Meters", "Meters^2", "Meters^2", "Meters^3", "Meters^3", "Meters^3", "Meters^3", "Seconds", "Seconds", "Seconds", "Seconds", "Seconds", "Seconds", "Seconds", "Grams", "Grams", "Grams", "Grams", "Grams", "Grams", "Joules,Seconds^-1", "Watts", "Watts", "Watts", "Joules", "Joules", "Joules", "Joules", "Newtons,Meters", "Amperes,Seconds", "Watts,Amperes^-1", "Volts", "Volts", "Kilograms,Meters,Seconds^-2", "Pounds,Feet per Second Squared", "Moles", "Moles", "Joules,Volts^-2", "Newton,Meters^-2", "Pascals", "Pascals", "Pascals", "Pascals"];
var baseScalings = [1, 180/Math.PI, 1, 1, 1, 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1, (0.01), (0.001), (1000), (0.0254), (0.3048), (0.9144), (1609.344), (4046.85642), (10000), (0.001), (0.003785), (0.000946), (0.00003), (31536000), (7884000), (2628000), (604800), (86400), (3600), (60), (1000), (0.001), (28.349523), (453.59237), (1000000), (907184.74),  1, (1000), (1000000), (1000000000), (4.184), (4184), (1055.05585), (1000),  1,  1,  1, (0.001), (1000),  1, (32.17405), (0.0), (0.0),  1,  1, (1000), (100000), (101325), (6894)];

var conScalings = [];
var conTargets = [];
var conSourceNames = [];
var conUnitTargets = [];
var conSourceRegEx = [];
function loadUnits(addedSources, addedTargets, addedScalings){
	conScalings = addedScalings;
	conTargets = addedTargets;
	conSourceNames = addedSources;
	for(var i = 0; i < baseSources.length; i++){
		conScalings.push(baseScalings[i]);
		conTargets.push(baseTargets[i]);
		conSourceNames.push(baseSources[i]);
	}
	
	conSourceRegEx = [];
	conUnitTargets= [];
	cachedUnits = {};
	unitsBank = {};
	for (var uk = 0; uk < conTargets.length; uk++) {
		conUnitTargets.push(unitsFromString(conTargets[uk].toLowerCase()));
  		conSourceRegEx.push(new RegExp("^"+conSourceNames[uk]+"$", "i"));
	}
}
loadUnits([], [], []);

var cachedUnits = {};

var findSourceIndex = function(name){
	if(name in cachedUnits){
		return cachedUnits[name];//memonization
	}
	for(var i = conSourceNames.length-1; i >= 0 ; i--){
		if(cachedUnits[i] != "" && conSourceRegEx[i].test(name)){
			cachedUnits[name] = i;
			return i;
		}
	}
	cachedUnits[name] = -1;
	return -1;
}

function Material(value, units) {
	this.value =  value;
  	this.units = units;
}

Material.prototype.toNum = function(){
	return this;
};

Material.prototype.toString = function(){
	if(this.units){
		return "<span class='markup'>{</span>"+this.value+"&nbsp"+this.units.toString()+"<span class='markup'>}</span>";
	}else{
		return this.value+"";
	}
}

Material.prototype.fullClone = function(){
	return new Material(this.value, this.units);
}

Material.prototype.forceUnits = function(newUnits){
	if(! this.units){
		this.units = newUnits;
	}else{
		var scale = convertUnits(this.units, newUnits);
		if (scale == 0) {
			unitAlert(this.units, newUnits, "forceUnits");
		} else {
			this.value = fn["*"](this.value, scale);
			this.units = newUnits;
		}
	}
	return this;
}


function unitAlert(lhs, rhs, type){
	throw "MSG: Incompatible units for the "+type+" of "+(lhs?lhs.toString():"unitless")+" and "+(rhs?rhs.toString():"unitless")+".";
}


"use strict";
/*

Copyright 2010-2020 Scott Fortmann-Roe. All rights reserved.

This file may distributed and/or modified under the
terms of the Insight Maker Public License (https://InsightMaker.com/impl).

*/

var unitsBank = {};

function sortAndCollapseUnits(names, exponents) {
	if (names.length <= 1) {
		if (names.length == 1) {
			names[0] = names[0].toLowerCase();
		}
	} else {
		var sorter = [];
		for (var i = 0; i < names.length; i++) {
			sorter.push({
				name: names[i].toLowerCase(),
				exponent: exponents[i]
			});
		}
		sorter.sort(function (a, b) {
			return a.name.localeCompare(b.name);
		});
		names = [];
		exponents = [];
		for (var i = 0; i < sorter.length; i++) {
			names.push(sorter[i].name);
			exponents.push(sorter[i].exponent);
		}
		for (var i = 0; i < names.length; i++) {
			for (var j = i + 1; j < names.length; j++) {
				if (names[i] === names[j]) {
					exponents[i] = exponents[i] + exponents[j];

					names.splice(j, 1);
					exponents.splice(j, 1);

					j--;
				}
			}

			if (exponents[i] == 0) {
				names.splice(i, 1);
				exponents.splice(i, 1)
				i--;
			}
		}
	}

	return { names: names, exponents: exponents };
}

function getUnitStore(names, exponents, checkNames) {
	if (checkNames) {
		var x = sortAndCollapseUnits(names, exponents);
		names = x.names;
		exponents = x.exponents;

	}

	if (names.length == 0) {
		return undefined;
	}

	var id = getUnitsId(names, exponents);

	if (!unitsBank[id]) {

		unitsBank[id] = new UnitStore(names, exponents);
	}

	return unitsBank[id];
}

function getUnitsId(names, exponents) {
	return names.join(",") + exponents.join(",");
}


function UnitStore(names, exponents) {
	this.names = names;
	this.exponents = exponents;
	this.toBase = null;
	this.baseUnits = null;
	this.multiples = {};
	this.id = getUnitsId(this.names, this.exponents);
}

UnitStore.prototype.addBase = function () {


	if (this.toBase) {
		return;
	}

	this.toBase = 1;


	var names = this.names.slice();
	var exponents = this.exponents.slice();

	var modified = true;
	while (modified) {
		modified = false;

		for (var i = names.length - 1; i >= 0; i--) {
			var j = findSourceIndex(names[i]);
			if (j !== -1 && !(conUnitTargets[j].names.length == 1 && conUnitTargets[j].names[0] == names[i])) {
				this.toBase = fn["*"](this.toBase, fn.expt(conScalings[j], exponents[i]));
				names = names.concat(conUnitTargets[j].names);
				names.splice(i, 1);
				exponents = exponents.concat(conUnitTargets[j].exponents.map(function (x) { return x * exponents[i] }))
				exponents.splice(i, 1);
				modified = true;
				break;
			}
		}
	}
	//console.log(names)
	//console.log(exponents)
	var x = sortAndCollapseUnits(names, exponents);

	this.baseUnits = getUnitStore(x.names, x.exponents);

}

UnitStore.prototype.power = function (exponent) {
	var names = this.names.slice();
	var exponents = this.exponents.slice();
	for (var i = 0; i < exponents.length; i++) {
		exponents[i] = exponents[i] * exponent;
	}
	return getUnitStore(names, exponents);
}


UnitStore.prototype.toStringShort = function () {
	var s = "";
	for (var i = 0; i < this.names.length; i++) {
		if (s != "") {
			s = s + ",";
		}
		s = s + this.names[i];
		if (this.exponents[i] != 1) {
			s = s + "^" + this.exponents[i];
		}
	}
	return s;
}

UnitStore.prototype.multiply = function (rhs, exponent) {
	var id = rhs.id + ";" + exponent;


	if (!this.multiples[id]) {
		if (!this.toBase) {
			this.addBase();
		}
		if (!rhs.toBase) {
			rhs.addBase();
		}

		if (this.baseUnits) {
			var names = this.baseUnits.names.slice();
			var exponents = this.baseUnits.exponents.slice();


			if (rhs.baseUnits) {
				for (var i = 0; i < rhs.baseUnits.names.length; i++) {
					var j = names.indexOf(rhs.baseUnits.names[i]);
					if (j != -1) {
						exponents[j] = exponents[j] + rhs.baseUnits.exponents[i] * exponent;
					} else {
						var found = false;
						for (var k = 0; k < names.length; k++) {
							if (rhs.baseUnits.names[i] < names[k]) {
								names.splice(k, 0, rhs.baseUnits.names[i]);
								exponents.splice(k, 0, rhs.baseUnits.exponents[i] * exponent)
								found = true;
								break;
							}
						}
						if (!found) {
							names.push(rhs.baseUnits.names[i]);
							exponents.push(rhs.baseUnits.exponents[i] * exponent);
						}
					}
				}

				for (var i = exponents.length - 1; i >= 0; i--) {
					if (exponents[i] == 0) {
						exponents.splice(i, 1);
						names.splice(i, 1);
					}
				}
			}
		} else {
			var names = rhs.baseUnits.names.slice();
			var exponents = rhs.baseUnits.exponents.slice();
		}
		this.multiples[id] = getUnitStore(names, exponents);
	}

	return this.multiples[id];
}

function unitsFromString(expandString) {
	var names = [];
	var exponents = [];
	if (expandString != "") {
		var expandItems = expandString.split(",");
		for (var j = 0; j < expandItems.length; j++) {
			names.push(expandItems[j].split("^")[0]);
			if (expandItems[j].indexOf("^") != -1) {
				exponents.push(parseFloat(expandItems[j].split("^")[1]));
			} else {
				exponents.push(1);
			}
		}
	}
	return getUnitStore(names, exponents, true);
}

var titleCaseReg = /\w\S*/g;
var titleCaseFunc = function (txt) {
	return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
};

function toTitleCase(str) {
	return str.replace(titleCaseReg, titleCaseFunc);
}
UnitStore.prototype.toString = function () {
	var n = "",
		den = "";
	var numItems = 0,
		denItems = 0;
	for (var i = 0; i < this.names.length; i++) {
		if (this.names[i] != "") {
			var item = "<span class=\"unit\">" + toTitleCase(this.names[i]) + "</span>";
			if (this.exponents[i] != 1 && this.exponents[i] != -1) {
				item = item + "<span class='markup'>^</span><sup>" + Math.abs(this.exponents[i]) + "</sup>";
			}
			if (this.exponents[i] > 0) {
				if (numItems > 0) {
					n = n + "<span class='markup'>*</span>";
				}
				n = n + item;
				numItems = numItems + 1;
			} else {
				if (denItems > 0) {
					den = den + "<span class='markup'>*</span>";
				}
				den = den + item;
				denItems = denItems + 1;
			}
		}
	}


	if (n == "") {
		n = "Unitless";
	}
	if (den == "") {
		return "<div class=\"units\">" + n + "</div>";
	} else {
		if (n == "Unitless") {
			n = "1";
		}
		return "<span class=\"units\">" + n + "<hr/><span class='markup'>/(</span>" + den + "<span class='markup'>)</span></span>";
	}
}


function convertUnits(source, target, loose) {
	if (source === target) {
		return 1;
	}
	if ((source && (!target)) || (target && (!source))) {
		if (loose) {
			return 1
		} else {
			return 0;
		}
	}

	if (!source.toBase) {
		source.addBase()
	}
	if (!target.toBase) {
		target.addBase()
	}

	if (source.baseUnits !== target.baseUnits) {
		return 0;
	}

	return fn["/"](source.toBase, target.toBase);
}



// Scheme numerical tower in JavaScript.  Described in README.
// Copyright (c) 2011 by John Tobey <John.Tobey@gmail.com>

/*
    File: schemeNumber.js

    Exports:

        <SchemeNumber>

    Depends:

        <biginteger.js> for <BigInteger>
 */

// Grab the BigInteger library.
var BigInteger;
if (typeof require !== "undefined")
    BigInteger = require("biginteger").BigInteger;
else
    BigInteger = this.BigInteger;

if (!BigInteger) {
    if (typeof load !== "undefined")
        load("biginteger.js");
    else if (this.readFile)
        eval(this.readFile("biginteger.js"));
    else
        throw new Error("BigInteger is not defined.");
}

/*
    Class: SchemeNumber
    A number object as <defined by the Scheme language at
    http://www.r6rs.org/>.

    Scheme supports *exact* arithmetic and mixing exact with standard
    (*inexact*) numbers.  Several basic operations, including
    addition, subtraction, multiplication, and division, when given
    only exact arguments, must return an exact, numerically correct
    result.

    These operations are allowed to fail due to running out of memory,
    but they are not allowed to return approximations the way
    ECMAScript operators may, unless given one or more inexact
    arguments.

    For example, adding exact *1/100* to exact *0* one hundred times
    produces exactly *1*, not 1.0000000000000007 as in JavaScript.
    Raising exact *2* to the power of exact *1024* returns a 308-digit
    integer with complete precision, not *Infinity* as in ECMAScript.

    This implementation provides all functions listed in the <R6RS
    Scheme specification at http://www.r6rs.org/>, Section 11.7, along
    with <eqv?> from Section 11.5.  (<eqv?> uses JavaScript's *===* to
    compare non-numbers.)

    Exact numbers support the standard ECMA Number formatting methods
    (toFixed, toExponential, and toPrecision) without a fixed upper
    limit to precision.

    The schemeNumber.js file exports an object <SchemeNumber>.  It
    contains a property <fn>, which in turn contains the functions
    implementing the numeric types.

    The <SchemeNumber> object is in fact a function that converts its
    argument to a Scheme number: similar to a constructor, but it may
    not always return an object, let alone a unique object.

    Parameters:

        obj - Object to be converted to a Scheme number.

    *obj* may have any of the following
    types:

        Scheme number - returned unchanged.
        String        - converted as if by *string->number*.
        Native ECMAScript number - treated as an inexact real.

    Returns:

        A Scheme number.

    Exceptions:

        If *obj* can not be parsed, <SchemeNumber> will <raise> an
        exception with condition type *&assertion*.

    See Also:

        <fn>, <raise>, <R6RS Chapter 3: Numbers at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-6.html#node_chap_3>
*/
var SchemeNumber = (function() {

function assert(x) { if (!x) throw new Error("assertion failed"); }

var abs      = Math.abs;
var floor    = Math.floor;
var ceil     = Math.ceil;
var round    = Math.round;
var pow      = Math.pow;
var sqrt     = Math.sqrt;
var atan2    = Math.atan2;
var log      = Math.log;
var exp      = Math.exp;
var atan     = Math.atan;
var cos      = Math.cos;
var sin      = Math.sin;
var tan      = Math.tan;
var LN2      = Math.LN2;
var LN10     = Math.LN10;
var _isFinite = isFinite;
var _isNaN    = isNaN;
var _parseInt = parseInt;
var _parseFloat = parseFloat;

function retFalse()   { return false; }
function retTrue()    { return true;  }
function retFirst(a)  { return a; }
function retThis()    { return this; }

function unimpl() {
    throw new Error("BUG: unimplemented");
}
function pureVirtual() {
    throw new Error("BUG: Abstract method not overridden for " + this);
}

function N() {}   N.prototype = new Number();  // Scheme numbers.
function C() {}   C.prototype = new N();       // Complex numbers.
function R() {}   R.prototype = new C();       // Reals.
function ER() {} ER.prototype = new R();       // Exact reals.
function EQ() {} EQ.prototype = new ER();      // Exact rationals.
function EI() {} EI.prototype = new EQ();      // Exact integers.

// How to split a rectangular literal into real and imaginary components:
var decimalComplex = /^(.*[^a-zA-Z]|)([-+].*)i$/;
var radixComplex = /^(.*)([-+].*)i$/;

var nanInfPattern = /^[-+](nan|inf)\.0$/;
var exponentMarkerPattern = /[eEsSfFdDlL]/;
var decimal10Pattern = /^([0-9]+\.?|[0-9]*\.[0-9]+)([eEsSfFdDlL][-+]?[0-9]+)?$/;

var uintegerPattern = {
    2: /^[01]+$/, 8: /^[0-7]+$/, 10: /^[0-9]+$/, 16: /^[0-9a-fA-F]+$/
};

function retZero()    { return ZERO; }
function retOne()     { return ONE; }

function divisionByExactZero() {
    raise("&assertion", "division by exact zero");
}

// Is the Flonum class simply the native Number?  In that case we will
// add methods to Number.prototype.

var Flonum;

// Users who wish to optimize the library by stripping support for
// Number.prototype cleanliness may simply replace "toFlonum("
// globally with "(" and change false to true here.

if (false) {  // XXX Should expose a way to choose this branch.
    // Flonum is Number.
    Flonum = Number;
}
else {
    // Flonum is a regular class in the hierarchy.
    Flonum = function(x) {
        this._ = x;
    };
}

var toFlonum, isNumber;
var flo = {};
var FLO_FUNCS = [[],
                 ["log", "floor", "ceil", "sqrt", "abs", "atan",
                  "cos", "sin", "tan", "exp"],
                 ["pow", "atan2"]];

if (Flonum === Number) {
    toFlonum = retFirst;

    isNumber = function(x) {
        return x instanceof Number || typeof x === "number";
    };
    FLO_FUNCS[1].concat(FLO_FUNCS[2]).forEach(function(name) {
            flo[name] = Math[name];
        });
}
else {
    Flonum.prototype = new R();

    (function() {
        var inexactZero = new Flonum(0);
        toFlonum = function(x) {
            //assert(typeof x === "number");
            return (x === 0 ? inexactZero : new Flonum(x));
        };
    })();

    isNumber = function(x) {
        return x instanceof N;
    };
    FLO_FUNCS[1].forEach(function(name) {
            var math = Math[name];
            flo[name] = function(a) {
                return toFlonum(math(a));
            };
        });
    FLO_FUNCS[2].forEach(function(name) {
            var math = Math[name];
            flo[name] = function(a, b) {
                return toFlonum(math(a, b));
            };
        });
    ["toFixed", "toExponential", "toPrecision"].forEach(function(name) {
            var number = Number.prototype[name];
            Flonum.prototype[name] = function(a) {
				//if(a==undefined){
					 return number.call(this._);
				//}else{
                //	return number.call(this._, Math.min(a,21));
				//}
            };
        });
    Flonum.prototype.valueOf = function() {
        return this._;
    };
}

/* Internal class hierarchy:

   Number
     ^
     N
     ^
     C  <----  Rectangular
                   |
                   `--  R  <----  Flonum[1]
                             |
                             `--  ER  <---  EQ  <----  EQFraction
                                                  |
                                                  `--  EI  <----  EINative
                                                             |
                                                             `--  EIBig

   [1] In some configurations, the Flonum class actually equals Number
   for reasons of efficiency.  Logically, Flonum should be a direct
   subclass of R.  Initialization code populates missing slots in
   Flonum.prototype as if that were the case.

   The concrete classes are:

   Flonum      - inexact real as a native number, possibly NaN or infinite.
   Rectangular - complex number as real and imaginary parts of same exactness.
   EQFraction  - exact rational as numerator and denominator in lowest terms.
   EINative    - exact integer as (wrapped) native number.
   EIBig       - exact integer as BigInteger.

   The abstract C, R, ER, EQ, and EI classes hold information about
   the respective number types (complex, real, exact real, exact
   rational, and exact integer) and stimulate thought about new
   concrete classes.

   Possible future classes:
   C <-- Polar - possibly exact complex number in polar coordinates;
   EQ <-- EQNative - exact rational as native number (power-of-2 denominator);
   EQ <-- EQDecimal - exact rational as BigInteger times a power of 10;
   R <-- BigFloat - inexact real of non-standard precision.
*/

// SN: private alias for the public SchemeNumber object.
function SN(obj) {
    if (obj instanceof N) {
        return obj;
    }

    var ret = obj;

    if (typeof ret !== "string") {
        if (typeof ret === "number") {
            return toFlonum(ret);
        }
        if (ret instanceof Number) {
            return toFlonum(+ret);
        }

        if (ret == null) {
            // XXX Rethink this.
            return (ret === null ? INEXACT_ZERO : NAN);
        }

        ret = ret.valueOf();
        if (typeof ret === "number") {
            return toFlonum(ret);
        }
        ret = String(ret);
    }
    ret = stringToNumber(ret);
    if (ret === false) {
        raise("&assertion", "not a number", obj);
    }
    return ret;
}
// For NaturalDocs:
var SchemeNumber = SN;

/*
    Property: VERSION
    Library version as an array of integers.

    For example, *[1,2,4]* corresponds to Version 1.2.4.
*/
SchemeNumber.VERSION = [1,1,4];

var floPow   = flo.pow;
var floLog   = flo.log;
var floFloor = flo.floor;
var floCeil  = flo.ceil;
var floSqrt  = flo.sqrt;
var floAtan2 = flo.atan2;
var floAbs   = flo.abs;
var floAtan  = flo.atan;
var floCos   = flo.cos;
var floSin   = flo.sin;
var floTan   = flo.tan;
var floExp   = flo.exp;

var HIERARCHY = {
    C: ["Rectangular", "R"],
    R: ["Flonum", "ER"],
    ER: ["EQ"],
    EQ: ["EQFraction", "EI"],
    EI: ["EINative", "EIBig"]
};

var CLASSES = {
    C:C, R:R, ER:ER, EQ:EQ, EI:EI,
    Rectangular:Rectangular, Flonum:Flonum,
    EQFraction:EQFraction, EINative:EINative, EIBig:EIBig
};

var DISP = {};
for (var className in CLASSES) {
    DISP[className] = {};  // Contents will go into class prototype.
}

//
// Input functions.
//

var PARSE_ERROR = new Object();

// Scheme number syntaxes, e.g. #e1.1@-2d19, 2/3
function stringToNumber(s, radix, exact) {
    function lose() {
        throw PARSE_ERROR;
    }
    function setExact(value) {
        if (exact !== undefined) lose();
        exact = value;
    }
    function setRadix(value) {
        if (radix) lose();
        radix = value;
    }
    function parseUinteger(s, sign) {
        if (!uintegerPattern[radix].test(s))
            lose();

        if (exact === false)
            return toFlonum(sign * _parseInt(s, radix));

        return parseEI(sign, s, radix);
    }
    function parseReal(s) {
        if (nanInfPattern.test(s)) {
            if (exact)
                lose();
            switch (s) {
            case "+inf.0": return INFINITY;
            case "-inf.0": return M_INFINITY;
            default: return NAN;
            }
        }

        var sign = 1;
        switch (s[0]) {
        case '-': sign = -1;  // fall through
        case '+': s = s.substring(1);
        }

        var slash = s.indexOf('/');
        if (slash != -1)
            return parseUinteger(s.substring(0, slash), sign)
                .SN_divide(parseUinteger(s.substring(slash + 1), 1));

        if (radix !== 10)
            lose();

        var pipe = s.indexOf('|');
        if (pipe !== -1) {

            // WHOA!!!  Explicit mantissa width!  Somebody really
            // cares about correctness.  However, I haven't got all
            // day, so execution speed loses.

            var afterPipe = s.substring(pipe + 1);
            if (!uintegerPattern[10].test(afterPipe))
                lose();

            s = s.substring(0, pipe);
            var precision = _parseInt(afterPipe, 10);

            if (precision === 0)
                s = "0.0";
            else if (precision < 53)
                return parseWithWidth(s, precision, exact);
        }

        // We have only one floating point width.
        s = s.replace(exponentMarkerPattern, 'e');

        var dot = s.indexOf('.');
        var e = s.indexOf('e');
        if (dot === -1 && e === -1)
            return parseUinteger(s, sign);

        if (!decimal10Pattern.test(s))
            lose();

        if (!exact)
            return toFlonum(sign * _parseFloat(s));

        var integer = s.substring(0, dot === -1 ? e : dot);
        var exponent = 0;
        var fraction;

        if (e === -1)
            fraction = s.substring(dot + 1);
        else {
            if (dot === -1)
                fraction = "";
            else
                fraction = s.substring(dot + 1, e);
            exponent = _parseInt(s.substring(e + 1), 10);
        }

        return parseDecimal(sign, integer + fraction,
                            exponent - fraction.length);
    }
    function parseComplex(s) {
        var a = s.indexOf('@');
        if (a !== -1) {
            var ret = makePolar(parseReal(s.substring(0, a)),
                                parseReal(s.substring(a + 1)));
            if (exact && ret.SN_isInexact())
                ret = ret.SN_toExact();  // XXX is this right?
            return ret;
        }

        if (s[s.length - 1] !== "i")
            return parseReal(s);

        if (s === "i") {
            if (exact === false)
                return inexactRectangular(INEXACT_ZERO, toFlonum(1));
            return I;
        }
        if (s === "-i") {
            if (exact === false)
                return inexactRectangular(INEXACT_ZERO, toFlonum(-1));
            return M_I;
        }

        var match = (radix === 10 ? decimalComplex : radixComplex).exec(s);
        var x, y;
        if (match) {
            x = match[1];
            y = match[2];
            x = (x ? parseReal(x) : (exact === false ? INEXACT_ZERO : ZERO));
            y = (y === "+" ? ONE : (y === "-" ? M_ONE : parseReal(y)));
        }
        else {
            // Could be "3i" for example.
            x = (exact === false ? INEXACT_ZERO : ZERO);
            y = parseReal(s.substring(0, s.length - 1));
        }

        return makeRectangular(x, y);
    }

    // Parse a real that had a |p attached.
    // See the second half of R6RS Section 4.2.8 and also
    // http://www.mail-archive.com/r6rs-discuss@lists.r6rs.org/msg01676.html.
    function parseWithWidth(s, precision) {

        // First, parse it as exact.
        var x = stringToNumber(s, radix, true);
        if (x === false || !x.SN_isReal())
            lose();

        if (!x.SN_isZero()) {
            var xabs = x.SN_abs();

            var shift = precision - floor(xabs.SN_log() / LN2) - 1;
            var scale = TWO.SN_expt(toEINative(abs(shift)));
            if (shift < 0)
                scale = scale.SN_reciprocal();
            var shifted = xabs.SN_multiply(scale);

            // Correct for log() imprecision.
            var denom = TWO.SN_expt(toEINative(precision));
            while (shifted.SN_ge(denom)) {
                shifted = shifted.SN_divide(TWO);
                scale = scale.SN_divide(TWO);
            }
            for (var twiceShifted = shifted.SN_add(shifted);
                 twiceShifted.SN_lt(denom);
                 twiceShifted = shifted.SN_add(shifted)) {
                shifted = twiceShifted;
                scale = scale.SN_add(scale);
            }

            // 0.5 <= shifted/denom < 1.
            var rounded = shifted.SN_round().SN_divide(scale);
            if (x.SN_isNegative())
                rounded = rounded.SN_negate();
            x = rounded;
        }

        // Then make it inexact unless there is #e.
        if (!exact)
            x = x.SN_toInexact();

        return x;
    }

    // Common cases first.
    if (!radix || radix == 10) {
        if (/^-?[0-9]{1,15}$/.test(s)) {
            if (exact === false)
                return toFlonum(_parseInt(s, 10));
            return toEINative(_parseInt(s, 10));
        }
        radix = 10;
    }

    var i = 0;

    try {
        while (s[i] === "#") {
            switch (s[i+1]) {
            case 'i': case 'I': setExact(false); break;
            case 'e': case 'E': setExact(true ); break;
            case 'b': case 'B': setRadix( 2); break;
            case 'o': case 'O': setRadix( 8); break;
            case 'd': case 'D': setRadix(10); break;
            case 'x': case 'X': setRadix(16); break;
            default: return false;
            }
            i += 2;
        }
        return parseComplex(s.substring(i));
    }
    catch (e) {
        if (e === PARSE_ERROR)
            return false;
        if (s == undefined)
            raise("&assertion", "missing argument");
        throw e;
    }
}

function makeRectangular(x, y) {
    if (x.SN_isExact() && y.SN_isExact())
        return exactRectangular(x, y);
    return inexactRectangular(x.SN_toInexact(), y.SN_toInexact());
}

function makePolar(r, theta) {
    return inexactRectangular(r.SN_multiply(theta.SN_cos()),
                              r.SN_multiply(theta.SN_sin()));
}

function assertReal(x) {
    if (!x.SN_isReal())
        raise("&assertion", "not a real number", x);
    return x;
}

function toReal(x) {
    x = SN(x);
    x.SN_isReal() || assertReal(x);
    return x;
}

function assertInteger(n) {
    n = SN(n);
    if (!n.SN_isInteger())
        raise("&assertion", "not an integer", n);
    return n;
}

function toInteger(n) {
    n = SN(n);
    n.SN_isInteger() || assertInteger(n);
    return n;
}

function assertRational(q) {
    if (!q.SN_isRational())
        raise("&assertion", "not a rational number", q);
    return q;
}

function assertNonNegative(n) {
    if (n.SN_isNegative())
        raise("&assertion", "negative number", n);
    return n;
}

function assertExact(z) {
    if (z.SN_isInexact())
        raise("&assertion", "inexact number", z);
    return z;
}

/*
    Property: raise
    Function that translates a Scheme exception to ECMAScript.

    When a library function encounters a situation where the Scheme
    specification requires it to raise an exception with a certain
    condition type, the function calls <SchemeNumber.raise>.

    Programs may assign a custom function to <SchemeNumber.raise> to
    intercept such exceptions.

    Parameters:

        conditionType - The specified condition, for example, "&assertion".
        message       - A string describing the error.
        irritants...  - Zero or more erroneous data arguments.

    Returns:

        The default <SchemeNumber.raise> function simply throws an
        *Error*.

    See Also:

        <fn>, <SchemeNumber>
*/
SchemeNumber.raise = defaultRaise;

function defaultRaise(conditionType, message, irritant) {
    var msg = "SchemeNumber: " + conditionType + ": " + message;
    if (arguments.length > 2) {
        if (isNumber(irritant))
            irritant = irritant.SN_numberToString();
        msg += ": " + irritant;
    }
    throw new Error(msg);
}

function raise() {
    var len = arguments.length;
    var args = new Array(len);
    while (len--)
        args[len] = arguments[len];

    // Call the exception hook.
    SN.raise.apply(SN, args);

    // Oops, it returned.  Fall back to our known good raiser.
    defaultRaise.apply(this, args);
}

/*
    Property: maxIntegerDigits
    Maximum size of integers created by the <fn.expt(z1, z2)>
    function.

    To avoid using up all system memory, exact results of a call to
    <fn.expt(z1, z2)> are capped at a configurable number of digits,
    by default one million.  <SchemeNumber.maxIntegerDigits> holds
    this limit.

    The size limit does *not* currently protect against other means of
    creating large exact integers.  For example, when passed
    "#e1e9999999", the <SchemeNumber> function tries to allocate 10
    million digits, regardless of <maxIntegerDigits>.

    In a future release, cases such as the preceeding example may be
    checked.  If there is any possibility of legitimately creating
    such large integers, either as number objects or components
    thereof, code should increase <maxIntegerDigits>.

    Default Value:

        - 1000000 (1e6 or 1 million)
*/

// Configurable maximum integer magnitude.
SN.maxIntegerDigits = 1e6;  // 1 million digits.

/*
    Method: toString(radix)
    Converts this Scheme number to a string.

    The *toString* method converts inexact numbers as in JavaScript
    and exact numbers as if by <fn["number->string"](z, radix)>.

    Method: toFixed(fractionDigits)
    Returns this Scheme number as a string with *fractionDigits*
    digits after the decimal point.

    Examples:

    > SchemeNumber("#e1.2").toFixed(2)  // "1.20"
    > SchemeNumber("1/7").toFixed(24)   // "0.142857142857142857142857"

    Specified by: <ECMA-262, 5th edition at http://www.ecma-international.org/publications/standards/Ecma-262.htm>

    Method: toExponential(fractionDigits)
    Converts this Scheme number to scientific "e" notation with
    *fractionDigits* digits after the decimal point.

    Examples:

    > SchemeNumber("1/11").toExponential(3)  // "9.091e-2"
    > SchemeNumber("1/2").toExponential(2)   // "5.00e-1"

    Specified by: <ECMA-262, 5th edition at http://www.ecma-international.org/publications/standards/Ecma-262.htm>

    Method: toPrecision(precision)
    Converts this Scheme number to decimal (possibly "e" notation)
    with *precision* significant digits.

    Examples:

    > SchemeNumber("12300").toPrecision(2)  // "1.2e+4"
    > SchemeNumber("12300").toPrecision(4)  // "1.230e+4"
    > SchemeNumber("12300").toPrecision(5)  // "12300"
    > SchemeNumber("12300").toPrecision(6)  // "12300.0"

    Specified by: <ECMA-262, 5th edition at http://www.ecma-international.org/publications/standards/Ecma-262.htm>
 */

/*
    Property: fn
    Container of <Scheme functions>.

    The <SchemeNumber> object contains a property, <SchemeNumber.fn>,
    which in turn contains the functions implementing the Scheme
    numeric types.

    These functions are stored in <fn> under their Scheme names, so
    ["quotation"] is needed where the names contain characters that
    are incompatible with dot.notation.  (In JavaScript, *X.Y* and
    *X["Y"]* are equivalent expressions where Y is a valid identifier.
    Not all Scheme function names are valid JavaScript identifiers, so
    one needs the second syntax to extract them from <fn>.)

    You may find it convenient to copy <SchemeNumber>, <fn>, and the
    output function <number->string> into short-named variables, by
    convention *sn*, *fn*, and *ns*.  The rest of this section assumes
    you have done this:

    > var sn = SchemeNumber;
    > var fn = sn.fn;
    > var ns = fn["number->string"];

    Functions that require a Scheme number argument automatically
    filter the argument through <SchemeNumber>.

    For example, *"2"* (string) would be exact (parsed as Scheme) but
    *2* (equal to *2.0*) would be inexact, as demonstrated:

    > a1 = fn["exact?"]("2");       // a1 === true
    > a1 = fn["exact?"](sn("2"));   // same
    > 
    > a2 = fn["exact?"](2);         // a2 === false
    > a2 = fn["exact?"]("2.0");     // same
    > a2 = fn["exact?"](sn("2.0")); // same

    Note that the following functions accept arguments of any type and
    therefore do not apply <SchemeNumber> to their arguments:

    - <eqv?>
    - <number?>
    - <complex?>
    - <real?>
    - <rational?>
    - <integer?>
    - <real-valued?>
    - <rational-valued?>
    - <integer-valued?>

    Here, for example, is 2 to the 1,024th power, as a decimal
    string:

    > a3 = ns(fn.expt("2", "1024"));

    Fractional
    arithmetic:

    > a4 = fn["+"]("1/3", "4/5");  // 17/15

    Numerator and denominator of a floating-point value,
    hexadecimal:

    > a5 = ns(fn.numerator(1/3), "16");    // "#i15555555555555"
    > a6 = ns(fn.denominator(1/3), "16");  // "#i40000000000000"

    The *#i* prefix denotes an inexact number, as detailed in <R6RS at
    http://www.r6rs.org/>.  Since 1/3 is a native JavaScript number,
    the library regards it as inexact, and operations such as
    numerator yield inexact integer results.  If we used *"1/3"*
    (quoted) instead of *1/3*, the numerator and denominator would be
    the mathematically correct 1 and 3.

    Functions specified to return two values (such as <div-and-mod>
    and <exact-integer-sqrt>) return a two-element array as per
    JavaScript conventions.

    Caveats:

      o Arcane features such as explicit mantissa widths or complex
        transcendental functions, while believed complete, are
        unoptimized.

      o The library exhibits other visible behaviors besides those
        described herein.  However, they are not part of its public
        API and may change or disappear from one release to the next.

      o In particular, Scheme numbers' *toString* property sometimes
        produces output that is incorrect in the Scheme sense.  (This
        stems from the decision to represent inexact reals as
        unadorned native numbers.)

    To serialize numbers as Scheme would, use
    <SchemeNumber.fn["number->string"]>.

    > "" + SchemeNumber(2);                  // "2"
    > SchemeNumber.fn["number->string"](2);  // "2."

    To test a Scheme number for numerical equality with another Scheme
    number or a native value, use <fn["="]>.  Likewise for <fn[">"]>
    etc.

    See Also:

        <Scheme functions>
*/
SchemeNumber.fn = {

/*
    About: Function list

    All <Scheme functions> are specified by <R6RS at
    http://www.r6rs.org/>.  In the list below, argument names indicate
    applicable types as follows:

    obj - any value
    z - any Scheme number
    x - a real number
    y - a real number
    q - a rational number (excludes infinities and NaN)
    n - an integer
    k - an exact, non-negative integer
    radix - an exact integer, either 2, 8, 10, or 16
    precision - an exact, positive integer

    Functions: Scheme functions
    Elements of <fn>.

    Refer to the argument type key under <Function list>.

    fn["number?"](obj)   - Returns true if *obj* is a Scheme number.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_440>.

    fn["complex?"](obj)  - Returns true if *obj* is a Scheme complex number.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_442>.

    fn["real?"](obj)     - Returns true if *obj* is a Scheme real number.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_444>.

    fn["rational?"](obj) - Returns true if *obj* is a Scheme rational number.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_446>.

    fn["integer?"](obj)  - Returns true if *obj* is a Scheme integer.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_448>.

    fn["real-valued?"](obj) - Returns true if *obj* is a Scheme complex number
                              and *fn["imag-part"](obj)* is zero.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_450>.

    fn["rational-valued?"](obj) - Returns true if *obj* is real-valued and
                                  *fn["real-part"](obj)* is rational.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_452>.

    fn["integer-valued?"](obj)  - Returns true if *obj* is real-valued and
                                  *fn["real-part"](obj)* is an integer.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_454>.

    fn["exact?"](z)   - Returns true if *z* is exact.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_456>.

    fn["inexact?"](z) - Returns true if *z* is inexact.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_458>.

    fn.inexact(z) - Returns an inexact number equal to *z*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_460>.

    fn.exact(z)   - Returns an exact number equal to *z*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_462>.

    fn["eqv?"](obj1, obj2) - Returns true if *obj1 === obj2* or both arguments
                             are Scheme numbers and behave identically.
                             Specified by <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_428>.

    fn["="](z, z, z...) - Returns true if all arguments are mathematically
                          equal, though perhaps differing in exactness.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_464>.

    fn["<"](x, x, x...) - Returns true if arguments increase monotonically.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_466>.

    fn[">"](x, x, x...) - Returns true if arguments decrease monotonically.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_468>.

    fn["<="](x, x, x...) - Returns true if arguments are monotonically
                           nondecreasing.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_470>.

    fn[">="](x, x, x...) - Returns true if arguments are monotonically
                           nonincreasing.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_472>.

    fn["zero?"](z)      - Returns true if *z* equals zero.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_474>.

    fn["positive?"](x)  - Returns true if *x* is positive.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_476>.

    fn["negative?"](x)  - Returns true if *x* is negative.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_478>.

    fn["odd?"](n)       - Returns true if *n* is odd.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_480>.

    fn["even?"](n)      - Returns true if *n* is even.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_482>.

    fn["finite?"](x)    - Returns true if *x* is finite.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_484>.

    fn["infinite?"](x)  - Returns true if *x* is plus or minus infinity.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_486>.

    fn["nan?"](x)       - Returns true if *x* is a NaN.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_488>.

    fn.max(x, x...)     - Returns the greatest argument.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_490>.

    fn.min(x, x...)     - Returns the least argument.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_492>.

    fn["+"](z...)       - Returns the sum of the arguments.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_494>.

    fn["*"](z...)       - Returns the product of the arguments.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_496>.

    fn["-"](z)          - Returns the negation of *z* (-*z*).
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_498>.

    fn["-"](z1, z2...)  - Returns *z1* minus the sum of the number(s) *z2*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_500>.

    fn["/"](z)          - Returns the reciprocal of *z* (1 / *z*).
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_502>.

    fn["/"](z1, z2...)  - Returns *z1* divided by the product of the number(s)
    *z2*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_504>.

    fn.abs(x)           - Returns the absolute value of *x*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_506>.

    fn["div-and-mod"](x, y) - Returns *fn.div(x, y)* and *fn.mod(x, y)*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_508>.

    fn.div(x, y)        - Returns the greatest integer less than or equal to
                          *x* / *y*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_510>.

    fn.mod(x, y)        - Returns *x* - (*y* * fn.div(*x*, *y*)).
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_512>.

    fn["div0-and-mod0"](x, y) - Returns *fn.div0(x, y)* and *fn.mod0(x, y)*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_514>.

    fn.div0(x, y)       - Returns the integer nearest *x* / *y*, ties go lower.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_516>.

    fn.mod0(x, y)       - Returns *x* - (*y* * fn.div0(*x*, *y*)).
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_518>.

    fn.gcd(n...) - Returns the arguments' greatest common non-negative divisor.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_520>.

    fn.lcm(n...) - Returns the arguments' least common positive multiple.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_522>.

    fn.numerator(q)     - Returns *q* * *fn.denominator(q)*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_524>.

    fn.denominator(q)   - Returns the smallest positive integer which when
                          multiplied by *q* yields an integer.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_526>.

    fn.floor(x)         - Returns the greatest integer not greater than *x*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_528>.

    fn.ceiling(x)       - Returns the least integer not less than *x*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_530>.

    fn.truncate(x)      - Returns the closest integer between 0 and *x*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_532>.

    fn.round(x)         - Returns the closest integer to *x*, ties go even.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_534>.

    fn.rationalize(x, y) - Returns the simplest fraction within *y* of *x*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_536>.

    fn.exp(z)           - Returns e to the *z*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_540>.

    fn.log(z)           - Returns the natural logarithm of *z*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_542>.

    fn.log(z1, z2)      - Returns the base-*z2* logarithm of *z1*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_544>.

    fn.sin(z)           - Returns the sine of *z*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_546>.

    fn.cos(z)           - Returns the cosine of *z*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_548>.

    fn.tan(z)           - Returns the tangent of *z*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_550>.

    fn.asin(z)          - Returns a number whose sine is *z*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_552>.

    fn.acos(z)          - Returns a number whose cosine is *z*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_554>.

    fn.atan(z)          - Returns a number whose tangent is *z*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_556>.

    fn.atan(y, x)       - Returns the angle that passes through *(x,y)*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_558>.

    fn.sqrt(z)          - Returns the square root of *z*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_560>.

    fn["exact-integer-sqrt"](k) - Returns maximal exact s and non-negative r
                                  such that s*s + r = *k*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_562>.

    fn.expt(z1, z2) - Returns *z1* to the power *z2*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_564>.

    fn["make-rectangular"](x, y) - Returns the complex number *x + iy*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_566>.

    fn["make-polar"](r, theta) - Returns the complex number with magnitude *r*
                                 and angle *theta*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_568>.

    fn["real-part"](z) - Returns x such that *z* = x + iy.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_570>.

    fn["imag-part"](z) - Returns y such that *z* = x + iy.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_572>.

    fn.magnitude(z)    - Returns the magnitude of *z*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_574>.

    fn.angle(z)        - Returns *fn.atan(y,x)* where *z* = x + iy.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_576>.

    Function: fn["number->string"](z)
    Converts *z* to a string, base 10.

    For exact *z*, *number->string* retains full precision.  Exact
    fractions are expressed as numerator + "/" + denominator.
    Examples:

    > fn["number->string"](fn["string->number"]("#e1.2"))  // "6/5"
    > fn["number->string"](fn["/"]("12", "-8"))            // "-3/2"

    Infinities are "+inf.0" and "-inf.0".  NaN is "+nan.0".

    The result always yields a number equal to *z* (in the sense of
    <fn["eqv?"](obj1, obj2)>) when passed to
    <fn["string->number"](string)>.

    Specified by: <R6RS at
    http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_578>

    See Also: <fn["string->number"](string)>.

    Function: fn["number->string"](z, radix)
    Converts *z* to a string, base *radix*.
    *radix* must be exact 2, 8, 10, or 16.

    The output never contains an explicit radix prefix.

    The result always yields a value equal to *z* (in the sense of
    <fn["eqv?"](obj1, obj2)>) when converted back to a number by
    <fn["string->number"](string, radix)>.

    Specified by: <R6RS at
    http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_580>

    See Also: <fn["string->number"](string, radix)>.

    Function: fn["number->string"](z, radix, precision)
    Converts and suffixes *z* with a count of significant bits.

    Appends "|p" to each inexact real component of *z* where p is the
    smallest mantissa width not less than *precision* needed to
    represent the component exactly.

    Specified by: <R6RS at
    http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_582>

    Function: fn["string->number"](string)
    Parses *string* as a Scheme number.  Returns *false* if unable.

    Examples:

    > "1"       - exact 1.
    > "1."      - inexact 1, same as "1.0".
    > "1/2"     - exact one-half, same as "2/4" etc.
    > "0.5"     - inexact 0.5.
    > "12e3"    - inexact 12000.
    > "i"       - the imaginary unit.
    > "-2+1/2i" - exact complex number.
    > "2.@1"    - complex in polar coordinates, r=2.0, theta=1.0.
    > "+inf.0"  - positive infinity.
    > "-inf.0"  - negative infinity.
    > "+nan.0"  - IEEE NaN (not-a-number).
    > "#e0.5"   - exact one-half, forced exact by prefix #e.
    > "#i1/2"   - 0.5, inexact by prefix #i.
    > "#x22"    - exact 34; prefix #x hexadecimal.
    > "#o177"   - exact 127; prefix #o octal.
    > "#b101"   - exact 5; prefix #b binary.
    > "#i#b101" - inexact 5.0.
    > "#b#i101" - same.
    > "1.2345678|24" - rounded as if to single-precision (about 1.23456776).

    Specified by: <R6RS at
    http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_584>

    See Also: <fn["number->string"](z)>, <R6RS section 4.2.8: Lexical
    syntax: Numbers at
    http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-7.html#node_sec_4.2.8>

    Function: fn["string->number"](string, radix)
    Parses *string* as a Scheme number using *radix* as default radix.

    *radix* must be exact 2, 8, 10, or 16.  If *string* contains a
    radix prefix, the prefix takes precedence over *radix*.

    Specified by: <R6RS at
    http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_586>

    See Also: <fn["number->string"](z, radix)>.
*/

    "eqv?"      : fn_isEqv,
    "number?"   : fn_isNumber,
    "complex?"  : fn_isComplex,
    "real?"     : fn_isReal,
    "rational?" : fn_isRational,
    "integer?"  : fn_isInteger,
    "real-valued?"     : fn_isRealValued,
    "rational-valued?" : fn_isRationalValued,
    "integer-valued?"  : fn_isIntegerValued,

    "exact?"   : makeUnary("SN_isExact"),
    "inexact?" : makeUnary("SN_isInexact"),

    inexact : makeUnary("SN_toInexact"),
    exact   : makeUnary("SN_toExact"),

    "="  : fn_equals,
    "<"  : makeComparator("SN_lt"),
    ">"  : makeComparator("SN_gt"),
    "<=" : makeComparator("SN_le"),
    ">=" : makeComparator("SN_ge"),

    "zero?"     : makeUnary("SN_isZero"),
    "positive?" : makeUnary("SN_isPositive"),
    "negative?" : makeUnary("SN_isNegative"),
    "odd?"      : makeUnary("SN_isOdd"),
    "even?"     : makeUnary("SN_isEven"),
    "finite?"   : makeUnary("SN_isFinite"),
    "infinite?" : makeUnary("SN_isInfinite"),
    "nan?"      : makeUnary("SN_isNaN"),

    max : makeMaxMin("SN_gt"),
    min : makeMaxMin("SN_lt"),

    "+" : function() {
        var ret = ZERO;
        var len = arguments.length;
        var i = 0;
        while (i < len)
            ret = ret.SN_add(SN(arguments[i++]));
        return ret;
    },

    "*" : function() {
        var ret = ONE;
        var len = arguments.length;
        var i = 0;
        while (i < len)
            ret = ret.SN_multiply(SN(arguments[i++]));
        return ret;
    },

    "-" : function(a) {
        var len = arguments.length;

        switch (len) {
        case 0: args1plus(arguments);
        case 1: return SN(a).SN_negate();
        }
        var ret = SN(a);
        var i = 1;
        while (i < len)
            ret = ret.SN_subtract(SN(arguments[i++]));
        return ret;
    },

    "/" : function(a) {
        var len = arguments.length;

        switch (len) {
        case 0: args1plus(arguments);
        case 1: return SN(a).SN_reciprocal();
        case 2: return SN(a).SN_divide(SN(arguments[1]));
        }
        var product = ONE;
        var i = 1;
        while (i < len)
            product = product.SN_multiply(SN(arguments[i++]));
        return SN(a).SN_divide(product);
    },

    abs             : makeUnary("SN_abs"),
    "div-and-mod"   : makeDivMod(false, 2),
    div             : makeDivMod(false, 0),
    mod             : makeDivMod(false, 1),
    "div0-and-mod0" : makeDivMod(true, 2),
    div0            : makeDivMod(true, 0),
    mod0            : makeDivMod(true, 1),

    gcd : function(x) {
        var ret = ZERO;
        var len = x.length;
        var exact = true;
        for (var i = 0; i < len; i++) {
            var arg = toInteger(x[i]);
            exact = exact && arg.SN_isExact();
            ret = gcdNonneg(ret, arg.SN_abs().SN_toExact());
        }
        ret = ret.SN_abs();
        return (exact ? ret : ret.SN_toInexact());
    },

    lcm : function(x) {
        var ret = ONE;
        var len = x.length;
        var exact = true;
        for (var i = 0; i < len; i++) {
            var arg = toInteger(x[i]);
            exact = exact && arg.SN_isExact();
            arg = arg.SN_abs().SN_toExact();
            ret = ret.SN_multiply(arg).SN_divide(gcdNonneg(ret, arg.SN_abs()));
        }
        return (exact ? ret : ret.SN_toInexact());
    },

    numerator   : makeUnary("SN_numerator"),
    denominator : makeUnary("SN_denominator"),
    floor       : makeUnary("SN_floor"),
    ceiling     : makeUnary("SN_ceiling"),
    truncate    : makeUnary("SN_truncate"),
    round       : makeUnary("SN_round"),
    rationalize : rationalize,
    exp         : makeUnary("SN_exp"),

    log : function(z, base) {
        var ret = SN(z).SN_log();
        switch (arguments.length) {
        case 2: 
			ret = ret.SN_divide(SN(base).SN_log());  // fall through //SFR
			ret._ = parseFloat(ret._.toPrecision(15));
        case 1:
			return ret;
        default: wrongArgCount("1-2", arguments);
        }
    },

    sin  : makeUnary("SN_sin"),
    cos  : makeUnary("SN_cos"),
    tan  : makeUnary("SN_tan"),
    asin : makeUnary("SN_asin"),
    acos : makeUnary("SN_acos"),

    atan : function(y, x) {
        switch (arguments.length) {
        case 1: return SN(y).SN_atan();
        case 2: return toReal(y).SN_atan2(toReal(x));
        default: wrongArgCount("1-2", arguments);
        }
    },

    sqrt : makeUnary("SN_sqrt"),
    "exact-integer-sqrt" : makeUnary("SN_exactIntegerSqrt"),
    expt : makeBinary("SN_expt"),

    "make-rectangular" : function(x, y) {
        arguments.length === 2 || args2(arguments);
        return makeRectangular(toReal(x), toReal(y));
    },

    "make-polar" : function(r, theta) {
        arguments.length === 2 || args2(arguments);
        return makePolar(toReal(r), toReal(theta));
    },

    "real-part" : makeUnary("SN_realPart"),
    "imag-part" : makeUnary("SN_imagPart"),
    magnitude   : makeUnary("SN_magnitude"),
    angle       : makeUnary("SN_angle"),

    "number->string" : function(z, radix, precision) {
        var r = radix;
        switch (arguments.length) {
        case 3:
            precision = toInteger(precision);
            assertExact(precision);
            // fall through
        case 2:
            r = assertExact(toInteger(r)).valueOf();
            if (!uintegerPattern[r])
                raise("&assertion", "invalid radix", radix);
            // fall through
        case 1: break;
        default: wrongArgCount("1-3", arguments);
        }
        return SN(z).SN_numberToString(r, precision);
    },

    "string->number" : function(s, radix) {
        switch (arguments.length) {
        case 1:
        case 2: return stringToNumber(String(s), radix);
        default: wrongArgCount("1-2", arguments);
        }
    }
};

// Scheme function helpers.

function wrongArgCount(expected, a) {
    var msg = "Function"

    for (name in fn) {
        if (fn[name] === a.callee) {
            msg += " '" + name + "'";
            break;
        }
    }
    raise("&assertion", msg + " expected " + expected +
          " argument" + (expected == "1" ? "" : "s") + ", got " + a.length);
}

function args1(a) { a.length === 1 || wrongArgCount(1, a); }
function args2(a) { a.length === 2 || wrongArgCount(2, a); }

function args1plus(a) { a.length > 0 || wrongArgCount("1 or more", a); }
function args2plus(a) { a.length > 1 || wrongArgCount("2 or more", a); }

function fn_isEqv(a, b) {
    arguments.length === 2 || args2(arguments);
    if (a === b)
        return true;
    a = SN(a);
    b = SN(b);
    return (a.SN_eq(b) && a.SN_isExact() === b.SN_isExact());
}

function fn_isNumber(x) {
    arguments.length === 1 || args1(arguments);
    return isNumber(x);
}

function fn_isComplex(x) {
    arguments.length === 1 || args1(arguments);
    return isNumber(x) && x.SN_isComplex();
}

function fn_isReal(x) {
    arguments.length === 1 || args1(arguments);
    return isNumber(x) && x.SN_isReal();
}

function fn_isRational(x) {
    arguments.length === 1 || args1(arguments);
    return isNumber(x) && x.SN_isRational();
}

function fn_isInteger(x) {
    arguments.length === 1 || args1(arguments);
    return isNumber(x) && x.SN_isInteger();
}

function fn_isRealValued(x) {
    arguments.length === 1 || args1(arguments);
    return isNumber(x) && x.SN_imagPart().SN_isZero();
}

function fn_isRationalValued(x) {
    arguments.length === 1 || args1(arguments);
    return fn_isRealValued(x) && x.SN_realPart().SN_isRational();
}

function fn_isIntegerValued(x) {
    arguments.length === 1 || args1(arguments);
    return fn_isRealValued(x) && x.SN_realPart().SN_isInteger();
}

function fn_equals(a, b) {
    var len = arguments.length;
    len > 1 || args2plus(arguments);
    a = SN(a);
    for (var i = 1; i < len; i++) {
        if (!a.SN_eq(SN(arguments[i])))
            return false;
    }
    return true;
}

function makeUnary(method) {
    function unary(a) {
        arguments.length === 1 || args1(arguments);
        return SN(a)[method]();
    }
    return unary;
}

function makeBinary(method) {
    function binary(a, b) {
        arguments.length === 2 || args2(arguments);
        return SN(a)[method](SN(b));
    }
    return binary;
}

function makeComparator(cmp) {
    function comparator(a, b) {
        var len = arguments.length;
        len > 1 || args2plus(arguments);
        b = toReal(b);
        if (!toReal(a)[cmp](b))
            return false;
        for (var i = 2; i < len; i++) {
            var c = toReal(arguments[i]);
            if (!b[cmp](c))
                return false;
            b = c;
        }
        return true;
    }
    return comparator;
}

function makeMaxMin(cmp) {
    function maxMin(a) {
        var len = arguments.length;
        len > 0 || args1plus(arguments);

        var ret = toReal(a);
        var exact = ret.SN_isExact();

        for (var i = 1; i < len; i++) {
            var x = toReal(arguments[i]);
            if (x.SN_isNaN())
                return x;
            if (exact) {
                exact = x.SN_isExact();
                if (!exact)
                    ret = ret.SN_toInexact();  // XXX Cheaper comparisons?
            }
            if (x[cmp](ret) !== false) {
                ret = x;
            }
        }
        return exact ? ret : ret.SN_toInexact();
    }
    return maxMin;
}

function divModArg2Zero(arg) {
    raise("&assertion", "div/mod second argument is zero", arg);
}

function makeDivMod(is0, which) {
    function divMod(x, y) {
        arguments.length === 2 || args2(arguments);
        x = toReal(x);
        y = toReal(y);

        if (!x.SN_isFinite())
            raise("&assertion", "div/mod first argument is not finite", x);
        if (y.SN_isZero())
            divModArg2Zero(y);

        if (!is0) {
            switch (which) {
            case 0: return x.SN_div(y);
            case 1: return x.SN_mod(y);
            case 2: default: return x.SN_divAndMod(y);
            }
        }

        var dm = x.SN_divAndMod(y);
        var m = dm[1];
        var yabs = y.SN_abs();

        if (m.SN_add(m).SN_ge(yabs)) {
            switch (which) {
            case 0: return dm[0].SN_add(y.SN_isNegative() ? M_ONE : ONE);
            case 1: return m.SN_subtract(yabs);
            case 2: default: return [dm[0].SN_add(y.SN_isNegative() ?
                                                  M_ONE : ONE),
                                     m.SN_subtract(yabs)];
            }
        }
        switch (which) {
        case 0: return dm[0];
        case 1: return m;
        case 2: default: return dm;
        }
    }
    return divMod;
}

function rationalize(x, delta) {
    args2(arguments);
    x = SN(x);
    delta = SN(delta);

    // Handle weird cases first.
    if (!x.SN_isFinite() || !delta.SN_isFinite()) {
        assertReal(x);
        assertReal(delta);
        if (delta.SN_isInfinite())
            return (x.SN_isFinite() ? INEXACT_ZERO : NAN);
        if (delta.SN_isNaN())
            return delta;
        return x;
    }

    if (delta.SN_isZero())
        return x;

    delta = delta.SN_abs();  // It's what PLT and Mosh seem to do.

    var x0 = x.SN_subtract(delta);
    var x1 = x.SN_add(delta);
    var a = x0.SN_floor();
    var b = x1.SN_floor();

    if (a.SN_ne(b)) {
        var negative = a.SN_isNegative();
        if (b.SN_isNegative() != negative)
            return (a.SN_isExact() ? ZERO : INEXACT_ZERO);
        return (negative ? b : x0.SN_ceiling());
    }
    var cf = [];  // Continued fraction, b implied.

    while (true) {
        x0 = x0.SN_subtract(a);
        if (x0.SN_isZero())
            break;
        x1 = x1.SN_subtract(a);
        if (x1.SN_isZero())
            break;

        x0 = x0.SN_reciprocal();
        x1 = x1.SN_reciprocal();
        a = x0.SN_floor();

        switch (a.SN_compare(x1.SN_floor())) {
        case -1: cf.push(x0.SN_ceiling()); break;
        case  1: cf.push(x1.SN_ceiling()); break;
        case 0: default:
            cf.push(a);
            continue;
        }
        break;
    }
    var ret = ZERO;
    var i = cf.length;
    while (i--)
        ret = ret.SN_add(cf[i]).SN_reciprocal();
    return ret.SN_add(b);
}

//
// Flonum: Inexact real as a native number.
//

DISP.Flonum.SN_isExact    = retFalse;
DISP.Flonum.SN_isInexact  = retTrue;
DISP.Flonum.SN_isComplex  = retTrue;
DISP.Flonum.SN_isReal     = retTrue;

DISP.Flonum.SN_debug = function() {
    return "Flonum(" + this.SN_numberToString() + ")";
};

// Return a string of "0" and "1" characters, possibly including a "."
// and possibly a leading "-", that in base 2 equals x.  This works by
// calling Number.prototype.toString with a radix of 2.  Specification
// ECMA-262 Edition 5 (December 2009) does not strongly assert that
// this works.  As an alternative, should this prove non-portable,
// nativeDenominator could instead do:
// for (d = 1; x !== floor(x); d *= 2) { x *= 2; } return d;
function numberToBinary(x) {
    return x.toString(2);
}

function nativeDenominatorLog2(x) {
    //assert(typeof x === "number");
    //assert(_isFinite(x));
    var s = numberToBinary(abs(x));
    var i = s.indexOf(".");
    if (i === -1)
        return 0;
    return s.length - i - 1;
}

function nativeDenominator(x) {
    // Get the "denominator" of a floating point value.
    // The result will be a power of 2.
    //assert(_isFinite(x));
    return pow(2, nativeDenominatorLog2(x));
}

DISP.Flonum.SN_numberToString = function(radix, precision) {
	
    if (radix && radix != 10 && _isFinite(this))
        return "#i" + this.SN_toExact().SN_numberToString(radix);

    if (!_isFinite(this)) {
        if (_isNaN(this))
            return("+nan.0");
        return (this > 0 ? "+inf.0" : "-inf.0");
    }

    var s = (+this).toString();

    if (s.indexOf('.') === -1) {
        // Force the result to contain a decimal point as per R6RS.
        var e = s.indexOf('e');
        if (e === -1)
            s += ".";
        else
            s = s.substring(0, e) + "." + s.substring(e);
    }

    if (precision != undefined) {
        if (precision < 53) {
            var bits = numberToBinary(+this).replace(/[-+.]/g, "")
                .replace(/^0+/, "").replace(/0+$/, "").length;
            if (precision < bits)
                precision = bits;
        }
        s += "|" + precision;
    }

    return s;
};

DISP.Flonum.SN_realPart = retThis;

DISP.Flonum.SN_imagPart = function() {
    return ZERO;
};

DISP.Flonum.SN_denominator = function() {
    return floPow(2, nativeDenominatorLog2(+assertRational(this)));
};

DISP.Flonum.SN_numerator = function() {
    return toFlonum(this * nativeDenominator(+assertRational(this)));
};

DISP.Flonum.SN_isInteger = function() {
    return _isFinite(this) && this == floor(this);
};

DISP.Flonum.SN_isFinite = function() {
    return _isFinite(this);
};
DISP.Flonum.SN_isRational = DISP.Flonum.SN_isFinite;

DISP.Flonum.SN_isZero = function() {
    return this == 0;
};

DISP.Flonum.SN_isPositive = function() {
    return this > 0;
};

DISP.Flonum.SN_isNegative = function() {
    return this < 0;
};

DISP.Flonum.SN_sign = function() {
    return (this == 0 ? 0 : (this > 0 ? 1 : -1));
};

// XXX I think we can do without SN_isUnit.
DISP.Flonum.SN_isUnit = function() {
    return this == 1 || this == -1;
};

DISP.Flonum.SN_isInfinite = function() {
    return !_isFinite(this) && !_isNaN(this);
};

DISP.Flonum.SN_isNaN = function() {
    return _isNaN(this);
};

DISP.Flonum.SN_isEven = function() {
    //assert(this == floor(this));
    return (this & 1) === 0;
};

DISP.Flonum.SN_isOdd = function() {
    //assert(this == floor(this));
    return (this & 1) === 1;
};

DISP.Flonum.SN_eq = function(z) { return z.SN__eq_Flonum(this); };
DISP.Flonum.SN_ne = function(z) { return z.SN__ne_Flonum(this); };
DISP.Flonum.SN_gt = function(x) { return assertReal(x).SN__gt_Flonum(this); };
DISP.Flonum.SN_lt = function(x) { return assertReal(x).SN__lt_Flonum(this); };
DISP.Flonum.SN_ge = function(x) { return assertReal(x).SN__ge_Flonum(this); };
DISP.Flonum.SN_le = function(x) { return assertReal(x).SN__le_Flonum(this); };

// XXX I think we can do without SN_compare and SN__compare_*.
DISP.Flonum.SN_compare = function(x) {
    return assertReal(x).SN__compare_Flonum(this);
};

// Note operand order!
DISP.Flonum.SN__eq_R = function(x) { return +x == this; };
DISP.Flonum.SN__ne_R = function(x) { return +x != this; };
DISP.Flonum.SN__gt_R = function(x) { return x > this; };
DISP.Flonum.SN__lt_R = function(x) { return x < this; };
DISP.Flonum.SN__ge_R = function(x) { return x >= this; };
DISP.Flonum.SN__le_R = function(x) { return x <= this; };

DISP.Flonum.SN__compare_R = function(x) {
    if (+x == this) return 0;
    if (x < this) return -1;
    if (x > this) return 1;
    return NaN;
};

function numberToEI(n) {
    if (n < 9007199254740992 && n > -9007199254740992)
        return toEINative(n);
    return new EIBig(numberToBigInteger(n));
}

function nativeToExact(x) {
    if (!_isFinite(x))
        raise("&implementation-violation",
              "inexact argument has no reasonably close exact equivalent", x);

    var d = nativeDenominator(x);
    var n;

    if (d === 1)
        return numberToEI(x);

    if (_isFinite(d)) {
        n = x * d;
        d = numberToEI(d);
    }
    else {
        // Denormal x.
        var dl2 = nativeDenominatorLog2(x);
        n = x * 9007199254740992;
        n *= pow(2, dl2 - 53);
        d = TWO.SN_expt(toEINative(dl2));
    }
    //assert(_isFinite(n));
    return canonicalEQ(numberToEI(n), d);
}

DISP.Flonum.SN_toExact = function() {
    return nativeToExact(+this);
};

DISP.Flonum.SN_toInexact = retThis;

DISP.Flonum.SN_add = function(z) {
    return z.SN__add_Flonum(this);
};
DISP.Flonum.SN_subtract = function(z) {
    return z.SN__subtract_Flonum(this);
};
DISP.Flonum.SN_multiply = function(z) {
    return z.SN__multiply_Flonum(this);
};
DISP.Flonum.SN_divide = function(z) {
    return z.SN__divide_Flonum(this);
};

DISP.Flonum.SN__add_R = function(x) {
    return toFlonum(x + this);
};
DISP.Flonum.SN__subtract_R = function(x) {
    return toFlonum(x - this);
};
DISP.Flonum.SN__multiply_R = function(x) {
    return toFlonum(x * this);
};
DISP.Flonum.SN__divide_R = function(x) {
    return toFlonum(x / this);
};

DISP.Flonum.SN_negate = function() {
    return toFlonum(-this);
};

DISP.Flonum.SN_abs = function() {
    return (this < 0 ? toFlonum(-this) : this);
};

DISP.Flonum.SN_reciprocal = function() {
    return toFlonum(1 / this);
};

function div_Flonum_R(x, y) {
    if (y > 0)
        return floor(x / y);
    if (y < 0)
        return ceil(x / y);
    if (y == 0)
        divModArg2Zero(toFlonum(y));
    return NaN;
}
DISP.Flonum.SN_divAndMod = function(x) {
    x = +x;
    var div = div_Flonum_R(this, x);
    return [toFlonum(div), toFlonum(this - (x * div))];
};
DISP.Flonum.SN_div = function(x) {
    return toFlonum(div_Flonum_R(this, x));
};
DISP.Flonum.SN_mod = function(x) {
    return toFlonum(this - x * div_Flonum_R(this, x));
};

DISP.Flonum.SN_square = function() {
    return toFlonum(this * this);
};

DISP.Flonum.SN_round = function() {
    var ret = floor(this);
    var diff = this - ret;
    if (diff < 0.5) return toFlonum(ret);
    if (diff > 0.5) return toFlonum(ret + 1);
    return toFlonum(2 * round(this / 2));
};

DISP.Flonum.SN_truncate = function() {
    return this < 0 ? floCeil(this) : floFloor(this);
};

DISP.Flonum.SN_ceiling = function() {
    return floCeil(this);
};

function funcToMeth(fn) {
    return function() {
        return fn(this);
    };
}
DISP.Flonum.SN_abs   = funcToMeth(floAbs);
DISP.Flonum.SN_atan  = funcToMeth(floAtan);
DISP.Flonum.SN_cos   = function(){
	return sn(floCos(this)._.toFixed(15));
};// SFR funcToMeth(floCos);
DISP.Flonum.SN_exp   = funcToMeth(floExp);
DISP.Flonum.SN_floor = funcToMeth(floFloor);
DISP.Flonum.SN_sin   =   function(){
	return sn(floSin(this)._.toFixed(15));
};//funcToMeth(floSin);
DISP.Flonum.SN_tan   = function(){
	return sn(floTan(this)._.toFixed(15));
};// SFR funcToMeth(floCos);

function cplxFuncToMeth(mathFunc, complexFunc) {
    return function() {
        var ret = mathFunc(this);
        if (_isNaN(ret))
            return complexFunc(this);
        return toFlonum(ret);
    };
}
DISP.Flonum.SN_acos = cplxFuncToMeth(Math.acos, complexAcos);
DISP.Flonum.SN_asin = cplxFuncToMeth(Math.asin, complexAsin);

DISP.Flonum.SN_log = function() {
    if (this < 0)
        return complexLog(this);
    return floLog(this);
};

DISP.Flonum.SN_sqrt = function() {
    if (this >= 0)
        return toFlonum(sqrt(this));
    if (_isNaN(this))
        return this;
    return inexactRectangular(INEXACT_ZERO, floSqrt(-this));
};

DISP.Flonum.SN_atan2 = function(x) {
    return floAtan2(this, x);
};

DISP.Flonum.SN_expt = function(z) {
    return z.SN__expt_Flonum(this);
};

// Some famous flonums:

var INEXACT_ZERO = toFlonum(0);

var INFINITY     = toFlonum(Number.POSITIVE_INFINITY);
var M_INFINITY   = toFlonum(Number.NEGATIVE_INFINITY);
var NAN          = toFlonum(Number.NaN);

var PI           = toFlonum(Math.PI);

//
// C: Complex abstract base class.
//

DISP.C.SN_isReal     = retFalse;
DISP.C.SN_isRational = retFalse;
DISP.C.SN_isInteger  = retFalse;
DISP.C.SN_isZero     = retFalse;
DISP.C.SN_isUnit     = retFalse;

DISP.C.SN_isComplex  = retTrue;

DISP.C.SN_numberToString = pureVirtual;

DISP.C.toString = function(radix) {
    return this.SN_numberToString(radix);
};
DISP.C.valueOf = function() {
    if (this.SN_imagPart().SN_isZero())
        return this.SN_realPart().valueOf();
    return NaN;
};

DISP.C.toFixed = pureVirtual;
DISP.C.toExponential = pureVirtual;
DISP.C.toPrecision = pureVirtual;

DISP.C.toLocaleString = function() {
    return this.toString();
};

DISP.C.SN_debug = function() { return "C"; };

// vvvv You shouldn't need this if you use only real numbers. vvvv

DISP.C.SN_sqrt = function() {
    return makePolar(this.SN_magnitude().SN_sqrt(),
                     this.SN_angle().SN_divide(TWO));
};

// Complex transcendental functions here for completeness, not optimized.

function complexLog(z) {
    return makeRectangular(z.SN_magnitude().SN_log(), z.SN_angle());
};

function complexAsin(z) {
    return M_I.SN_multiply(I.SN_multiply(z)
                           .SN_add(ONE.SN_subtract(z.SN_square()).SN_sqrt())
                           .SN_log());
}

function complexAcos(z) {
    return PI.SN_divide(TWO).SN_subtract(complexAsin(z));
}

function complexAtan(z) {
    var iz = I.SN_multiply(z);
    return ONE.SN_add(iz).SN_log().SN_subtract(ONE.SN_subtract(iz).SN_log())
        .SN_divide(TWO).SN_divide(I);
}

DISP.C.SN_log  = function() { return complexLog (this); };
DISP.C.SN_asin = function() { return complexAsin(this); };
DISP.C.SN_acos = function() { return complexAcos(this); };
DISP.C.SN_atan = function() { return complexAtan(this); };

DISP.C.SN_sin = function() {
    var iz = I.SN_multiply(this);
    return iz.SN_exp().SN_subtract(iz.SN_negate().SN_exp())
        .SN_divide(TWO).SN_divide(I);
};

DISP.C.SN_cos = function() {
    var iz = I.SN_multiply(this);
    return iz.SN_exp().SN_add(iz.SN_negate().SN_exp()).SN_divide(TWO);
};

DISP.C.SN_tan = function() {
    return this.SN_sin().SN_divide(this.SN_cos());
};

// ^^^^ You shouldn't need this if you use only real numbers. ^^^^

//
// R: Real abstract base class.
//

DISP.R.SN_isReal = retTrue;

DISP.R.SN_debug = function() { return "R"; };

DISP.R.SN_realPart = retThis;

// Methods implemented generically using more basic operations.

DISP.R.SN_magnitude = function() {
    return this.SN_abs();
};

DISP.R.SN_angle = function() {
    return this.SN_isNegative() ? PI : ZERO;
};

// Commented because they are always overridden.
// DISP.R.SN_isPositive = function() {
//     return this.SN_sign() > 0;
// };
// DISP.R.SN_isNegative = function() {
//     return this.SN_sign() < 0;
// };
// DISP.R.SN_sign = function() {
//     return this.SN_compare(ZERO);
// };

// Dispatches.

DISP.R.SN__eq_Flonum = DISP.Flonum.SN__eq_R;
DISP.R.SN__ne_Flonum = DISP.Flonum.SN__ne_R;

DISP.R.SN__eq_Rectangular = function(z) {
    return z._y.SN_isZero() && z._x.SN_eq(this);
};
DISP.R.SN__ne_Rectangular = function(z) {
    return !z._y.SN_isZero() || z._x.SN_ne(this);
};

DISP.R.SN__gt_Flonum = DISP.Flonum.SN__gt_R;
DISP.R.SN__lt_Flonum = DISP.Flonum.SN__lt_R;
DISP.R.SN__ge_Flonum = DISP.Flonum.SN__ge_R;
DISP.R.SN__le_Flonum = DISP.Flonum.SN__le_R;
DISP.R.SN__compare_Flonum = DISP.Flonum.SN__compare_R;

DISP.R.SN_compare = pureVirtual;
DISP.R.SN_gt = function(x) { return this.SN_compare(x) > 0; };
DISP.R.SN_lt = function(x) { return this.SN_compare(x) < 0; };
DISP.R.SN_ge = function(x) { return this.SN_compare(x) >= 0; };
DISP.R.SN_le = function(x) { return this.SN_compare(x) <= 0; };

DISP.R.SN_add = function(z) {
    return z.SN__add_R(this);
};
DISP.R.SN__add_Flonum = DISP.Flonum.SN__add_R;

DISP.R.SN_subtract = function(z) {
    return z.SN__subtract_R(this);
};
DISP.R.SN__subtract_Flonum = DISP.Flonum.SN__subtract_R;

DISP.R.SN_multiply = function(z) {
    return z.SN__multiply_R(this);
};
DISP.R.SN__multiply_Flonum = DISP.Flonum.SN__multiply_R;

DISP.R.SN_divide = function(z) {
    return z.SN__divide_R(this);
};
DISP.R.SN__divide_Flonum = DISP.Flonum.SN__divide_R;

function complexExpt(b, p) {
    if (b.SN_isZero()) {
        if (p.SN_isZero())
            return toFlonum(1);
        if (p.SN_realPart().SN_isPositive())
            return INEXACT_ZERO;
        raise("&implementation-restriction", "invalid power for zero expt", p);
    }
    return b.SN_log().SN_multiply(p).SN_exp();
}

DISP.R.SN__expt_R = function(x) {
    // Return x to the power of this number.
    if (x.SN_isNegative())
        return complexExpt(x, this);
    return floPow(x, this);
};

DISP.R.SN__expt_EI = DISP.R.SN__expt_R;

DISP.R.SN__expt_EQ = function(q) {
    // Return q to the power of this number.
    if (q.SN_isNegative())
        return complexExpt(q, this);
    var num = q.SN_numerator().SN_expt(this);
    var den = q.SN_denominator().SN_expt(this);

    if (num.SN_isExact() && num.SN_isInteger() &&
        den.SN_isExact() && den.SN_isInteger())
        return new EQFraction(num, den);  // Known to be in lowest terms.

    return num.SN_divide(den);
};

function divAndMod_R_R(x, y) {
    var div = div_R_R(x, y);
    return [div, x.SN_subtract(div.SN_multiply(y))];
}
function div_R_R(x, y) {
    return (y.SN_isNegative()
            ? x.SN_divide(y).SN_ceiling()
            : x.SN_divide(y).SN_floor());
}
function mod_R_R(x, y) {
    return x.SN_subtract(div_R_R(x, y).SN_multiply(y));
}

DISP.R.SN_divAndMod = function(x) {
    return divAndMod_R_R(this, x);
};
DISP.R.SN_div = function(x) {
    return div_R_R(this, x);
};
DISP.R.SN_mod = function(x) {
    return mod_R_R(this, x);
};

DISP.R.SN__divAndMod_R = function(x) {
    return divAndMod_R_R(x, this);
};
DISP.R.SN__div_R = function(x) {
    return div_R_R(x, this);
};
DISP.R.SN__mod_R = function(x) {
    return mod_R_R(x, this);
};

// These functions are always allowed to return inexact.  We, however,
// override a few of these in ZERO and ONE.
["sqrt", "exp", "log", "sin", "cos", "tan", "asin", "acos", "atan", "atan2"]
.forEach(function(name) { DISP.R["SN_" + name] = DISP.Flonum["SN_" + name]; });

// vvvv You shouldn't need this if you use only real numbers. vvvv

//
// Rectangular: Complex numbers as xy-coordinate pairs.
//

function exactRectangular(x, y) {
    //assert(x.SN_isExact());
    //assert(y.SN_isExact());
    if (y.SN_isZero())
        return x;
    if (x.SN_isZero() && y.SN_isUnit())
        return (y.SN_isPositive() ? I : M_I);
    return new Rectangular(x, y);
}

function inexactRectangular(x, y) {
    //assert(x.SN_isInexact());
    //assert(y.SN_isInexact());
    return new Rectangular(x, y);
}

function toRectangular(x, y) {
    //assert(x.SN_isExact() === y.SN_isExact())
    if (x.SN_isExact())
        return exactRectangular(x, y);
    return new Rectangular(x, y);
}

function Rectangular(x, y) {
    this._x = x;
    this._y = y;
}

Rectangular.prototype = new C();

function xyToString(xString, yString) {
    if (yString[0] === '-' || yString[0] === '+')
        return xString + yString + "i";
    return xString + "+" + yString + "i";
}

DISP.Rectangular.SN_numberToString = function(radix, precision) {
    return xyToString(this._x.SN_numberToString(radix, precision),
                      this._y.SN_numberToString(radix, precision));
};

DISP.Rectangular.toString = function(radix) {
    radix = radix || 10;
    return xyToString(this._x.toString(radix), this._y.toString(radix));
};

DISP.Rectangular.SN_debug = function() {
    return "Rectangular(" + this._x.SN_debug()
        + ", " + this._y.SN_debug() + ")";
};

DISP.Rectangular.toFixed = function(dig) {
    return xyToString(this._x.toFixed(dig), this._y.toFixed(dig));
};
DISP.Rectangular.toExponential = function(dig) {
    return xyToString(this._x.toExponential(dig), this._y.toExponential(dig));
};
DISP.Rectangular.toPrecision = function(prec) {
	//return ns(this);
    return xyToString(this._x.toPrecision(prec), this._y.toPrecision(prec));
};

DISP.Rectangular.SN_realPart = function() { return this._x; };
DISP.Rectangular.SN_imagPart = function() { return this._y; };

DISP.Rectangular.SN_isExact   = function() { return this._x.SN_isExact(); };
DISP.Rectangular.SN_isInexact = function() { return this._x.SN_isInexact(); };

DISP.Rectangular.SN_toInexact = function() {
    if (this._x.SN_isInexact())
        return this;
    return inexactRectangular(this._x.SN_toInexact(), this._y.SN_toInexact());
};

DISP.Rectangular.SN_toExact = function() {
    if (this._x.SN_isExact())
        return this;
    return exactRectangular(this._x.SN_toExact(), this._y.SN_toExact());
};

DISP.Rectangular.SN_isZero = function() {
    return this._x.SN_isZero() && this._y.SN_isZero();
};

function rectMagnitude2(z) {
    return z._x.SN_square().SN_add(z._y.SN_square());
}

DISP.Rectangular.SN_isUnit = function() {
    return rectMagnitude2(this).SN_eq(ONE);
};

DISP.Rectangular.SN_magnitude = function() {
    if (this._x.SN_isZero())
        return this._y.SN_abs();
    return rectMagnitude2(this).SN_sqrt();
};

DISP.Rectangular.SN_angle = function() {
    return this._y.SN_atan2(this._x);
};

DISP.C.SN__eq_Rectangular = pureVirtual;
DISP.Rectangular.SN_eq = function(z) {
    return z.SN__eq_Rectangular(this);
};
DISP.Rectangular.SN__eq_Rectangular = function(z) {
    return z._x.SN_eq(this._x) && z._y.SN_eq(this._y);
};
DISP.Rectangular.SN__eq_R = function(x) {
    return this._y.SN_isZero() && x.SN_eq(this._x);
};

DISP.C.SN__ne_Rectangular = pureVirtual;
DISP.Rectangular.SN_ne = function(z) {
    return z.SN__ne_Rectangular(this);
};
DISP.Rectangular.SN__ne_Rectangular = function(z) {
    return z._x.SN_ne(this._x) || z._y.SN_ne(this._y);
};
DISP.Rectangular.SN__ne_R = function(x) {
    return !this._y.SN_isZero() || x.SN_ne(this._x);
};

// Arithmetic where the left operand is Rectangular and the right is
// this Flonum.

DISP.Flonum.SN__add_Rectangular = function(z) {
    return inexactRectangular(toFlonum(z._x + this), z._y.SN_toInexact());
};
DISP.Flonum.SN__subtract_Rectangular = function(z) {
    return inexactRectangular(toFlonum(z._x - this), z._y.SN_toInexact());
};
DISP.Flonum.SN__multiply_Rectangular = function(z) {
    return inexactRectangular(toFlonum(z._x * this), toFlonum(z._y * this));
};
DISP.Flonum.SN__divide_Rectangular = function(z) {
    return inexactRectangular(toFlonum(z._x / this), toFlonum(z._y / this));
};
DISP.Flonum.SN__expt_Rectangular = function(z) {
    // XXX Is this any cheaper than complexExpt??
    return makePolar(floPow(rectMagnitude2(z), this / 2),
                     toFlonum(atan2(z._y, z._x) * this));
};

// Arithmetic where the left operand is Rectangular and the right is
// this real number.

DISP.R.SN__add_Rectangular = function(z) {
    return makeRectangular(z._x.SN_add(this), z._y);
};

DISP.R.SN__subtract_Rectangular = function(z) {
    return makeRectangular(z._x.SN_subtract(this), z._y);
};

DISP.R.SN__multiply_Rectangular = function(z) {
    return toRectangular(z._x.SN_multiply(this), z._y.SN_multiply(this));
};

DISP.R.SN__divide_Rectangular = function(z) {
    return toRectangular(z._x.SN_divide(this), z._y.SN_divide(this));
};

DISP.C.SN__add_Rectangular = pureVirtual;
DISP.Rectangular.SN_add = function(z) {
    return z.SN__add_Rectangular(this);
};
DISP.Rectangular.SN__add_R = function(x) {
    return makeRectangular(x.SN_add(this._x), this._y);
};
DISP.Rectangular.SN__add_Rectangular = function(z) {
    var x = z._x.SN_add(this._x);
    var y = z._y.SN_add(this._y);
    return (x.SN_isExact() ? exactRectangular : inexactRectangular)(x, y);
};

DISP.Rectangular.SN_negate = function() {
    return toRectangular(this._x.SN_negate(), this._y.SN_negate());
};

DISP.C.SN__subtract_Rectangular = pureVirtual;
DISP.Rectangular.SN_subtract = function(z) {
    return z.SN__subtract_Rectangular(this);
};
DISP.Rectangular.SN__subtract_R = function(x) {
    return makeRectangular(x.SN_subtract(this._x), this._y.SN_negate());
};
DISP.Rectangular.SN__subtract_Rectangular = function(z) {
    var x = z._x.SN_subtract(this._x);
    var y = z._y.SN_subtract(this._y);
    return (x.SN_isExact() ? exactRectangular : inexactRectangular)(x, y);
};

DISP.C.SN__multiply_Rectangular = pureVirtual;
DISP.Rectangular.SN_multiply = function(z) {
    return z.SN__multiply_Rectangular(this);
};
DISP.Rectangular.SN__multiply_R = function(x) {
    return toRectangular(x.SN_multiply(this._x), x.SN_multiply(this._y));
};
function complexMultiply(ax, ay, bx, by) {
    return toRectangular(ax.SN_multiply(bx).SN_subtract(ay.SN_multiply(by)),
                         ax.SN_multiply(by).SN_add(ay.SN_multiply(bx)));
}
DISP.Rectangular.SN__multiply_Rectangular = function(z) {
    return complexMultiply(z._x, z._y, this._x, this._y);
};

DISP.Rectangular.SN_square = function() {
    return toRectangular(this._x.SN_square().SN_subtract(this._y.SN_square()),
                         this._x.SN_multiply(this._y).SN_multiply(TWO));
};

DISP.Rectangular.SN_reciprocal = function() {
    var m2 = rectMagnitude2(this);
    return toRectangular(this._x.SN_divide(m2),
                         this._y.SN_divide(m2).SN_negate());
};

DISP.C.SN__divide_Rectangular = pureVirtual;
DISP.Rectangular.SN_divide = function(z) {
    return z.SN__divide_Rectangular(this);
};
function complexDivide(x, y, z) {  // returns (x + iy) / z
    var m2 = rectMagnitude2(z);
    return complexMultiply(x, y,
                           z._x.SN_divide(m2),
                           z._y.SN_divide(m2).SN_negate());
}
DISP.Rectangular.SN__divide_R = function(x) {
    return complexDivide(x, x.SN_isExact() ? ZERO : INEXACT_ZERO, this);
};
DISP.Rectangular.SN__divide_Rectangular = function(z) {
    return complexDivide(z._x, z._y, this);
};

DISP.Rectangular.SN_expt = function(z) {
    return z.SN__expt_Rectangular(this);
};
DISP.Rectangular.SN__expt_C = function(z) {
    return complexExpt(z, this);
};
DISP.C.SN__expt_Rectangular = DISP.Rectangular.SN__expt_C;

DISP.Rectangular.SN_exp = function() {
    return makePolar(this._x.SN_exp(), this._y);
};

// ^^^^ You shouldn't need this if you use only real numbers. ^^^^

//
// ER: Exact real abstract base class.
//

DISP.ER.SN_isExact    = retTrue;
DISP.ER.SN_isInexact  = retFalse;

DISP.ER.SN_toExact    = retThis;
DISP.ER.SN_toInexact  = function() { return toFlonum(+this); };

DISP.ER.SN_isNaN      = retFalse;
DISP.ER.SN_isFinite   = retTrue;
DISP.ER.SN_isInfinite = retFalse;

DISP.ER.SN_imagPart   = retZero;

function zeroes(count) {
    var ret = "000000000000000".substring(0, count & 15);
    if (count > 15)
        ret += new Array((count >> 4) + 1).join("0000000000000000");
    return ret;
}

// Specified by ECMA-262, 5th edition, 15.7.4.5.
DISP.ER.toFixed = function(fractionDigits) {
    var f = (fractionDigits === undefined ? 20 : _parseInt(fractionDigits, 10));
    if (f > SN.maxIntegerDigits)
        throw new RangeError("fractionDigits exceeds " +
                             "SchemeNumber.maxIntegerDigits: " +
                             fractionDigits);

    var x = this;
    var s = "";
    if (x.SN_isNegative()) {
        x = x.SN_negate();
        s = "-";
    }

    var p = ONE.SN__exp10(-f);
    var dm = x.SN_divAndMod(p);
    var n = dm[0];
    if (dm[1].SN_add(dm[1]).SN_ge(p))
        n = ONE.SN_add(n);
    if (n.SN_isZero())
        return s + "0" +
            (fractionDigits > 0 ? "." + zeroes(fractionDigits) : "");
    n = n.SN_numberToString();
    if (f === 0)
        return s + n;

    var z = f - n.length;
    if (f > 0) {
        if (z >= 0)
            n = zeroes(z + 1) + n;
        var point = n.length - f;
        return s + n.substring(0, point) + "." + n.substring(point);
    }
    return s + n + zeroes(-f);
};

DISP.ER.toExponential = function(fractionDigits) {
    var f = (fractionDigits === undefined ? 20 : _parseInt(fractionDigits));
    if (f < 0)
        throw new RangeError("SchemeNumber toExponential: negative " +
                             "argument: " + f);
    if (f > SN.maxIntegerDigits)
        throw new RangeError("fractionDigits exceeds " +
                             "SchemeNumber.maxIntegerDigits: " +
                             fractionDigits);

    var x = this;
    var s = "";
    if (x.SN_isNegative()) {
        x = x.SN_negate();
        s = "-";
    }
    else if (x.SN_isZero())
        return "0" + (fractionDigits > 0 ? "." + zeroes(f) : "") + "e+0";

    var e = floor(x.SN_log() / LN10);
    var p = ONE.SN__exp10(e - f);
    var dm = x.SN_divAndMod(p);
    var n = dm[0];
    if (dm[1].SN_add(dm[1]).SN_ge(p))
        n = ONE.SN_add(n);
    n = n.SN_numberToString();

    // Adjust for inaccuracy in log().
    if (n.length != f + 1) {
        //print("Guessed wrong length: " + n.length + " != " + (f + 1));
        e += n.length - (f + 1);
        p = ONE.SN__exp10(e - f);
        dm = x.SN_divAndMod(p);
        n = dm[0];
        if (dm[1].SN_add(dm[1]).SN_ge(p))
            n = ONE.SN_add(n);
        n = n.SN_numberToString();
        if (n.length != f + 1)
            throw new Error("Can not format as exponential: "
                            + this.SN_numberToString());
    }

    if (fractionDigits === undefined)
        n = n.replace(/(\d)0+$/, "$1");
    if (n.length > 1)
        n = n[0] + "." + n.substring(1);
    return s + n + "e" + (e < 0 ? "" : "+") + e;
};

DISP.ER.toPrecision = function(precision) {
    var p, x;
	
    if (precision === undefined) {
        x = this.SN_toInexact();
        if (x.SN_isFinite())
            return (+x).toString();
        p = 21;
    }
    else {
        p = _parseInt(precision, 10);
        if (p < 1)
            throw new RangeError("SchemeNumber toPrecision: expected a " +
                                 "positive precision, got: " + precision);
        if (p > SN.maxIntegerDigits)
            throw new RangeError("precision exceeds " +
                                 "SchemeNumber.maxIntegerDigits: " +
                                 precision);
    }

    x = this;
    var s = "";
    if (x.SN_isNegative()) {
        x = x.SN_negate();
        s = "-";
    }
    else if (x.SN_isZero())
        return "0" + (p > 1 ? "."  : ""); //SFR

    var ret = x.toExponential(p - 1);
    var eIndex = ret.indexOf('e');
    var exponent = _parseInt(ret.substring(eIndex + 1), 10);
    if (exponent >= -6 && exponent < p) {
        if (exponent === 0)
            ret = ret.substring(0, eIndex);
        else {
            ret = ret.substring(0, 1)
                + (ret.indexOf('.') === -1 ? "" : ret.substring(2, eIndex));
            if (exponent < 0)
                ret = "0." + zeroes(-1 - exponent) + ret;
            else if (exponent < p - 1)
                ret = ret.substring(0, exponent + 1) + "." +
                    ret.substring(exponent + 1);
        }
    }
    else if (precision === undefined) {
        ret = ret.substring(0, eIndex).replace(/\.?0+/, "")
            + ret.substring(eIndex);
    }
	
   // ret = ret.substring(0, eIndex).replace(/\.?0+/, "")
    //    + ret.substring(eIndex);
	
	var res = s + ret;
	res = res.replace(/(\.\d*?)0+(e|\+|\-|$)/g,"$1$2"); // SFR
	//console.log("---");
    return res;
};

//
// EQ: Exact rational abstract base class.
//

function parseDecimal(sign, significand, exponent) {
    return parseEI(sign, significand).SN__exp10(exponent);
}

DISP.EQ.SN_isRational = retTrue;

DISP.EQ.SN_eq = function(z) {
    return z.SN__eq_EQ(this);
};
DISP.EQ.SN__eq_EQ = pureVirtual;

DISP.EQ.SN_ne = function(z) {
    return z.SN__ne_EQ(this);
};
DISP.EQ.SN__ne_EQ = pureVirtual;

DISP.EQ.SN_compare = function(x) {
    return x.SN__compare_EQ(this);
};
DISP.EQ.SN__compare_EQ = pureVirtual;

DISP.EQ.SN_add = function(z) {
    return z.SN__add_EQ(this);
};
DISP.EQ.SN__add_EQ = pureVirtual;

DISP.EQ.SN_subtract = function(z) {
    return z.SN__subtract_EQ(this);
};
DISP.EQ.SN__subtract_EQ = pureVirtual;

DISP.EQ.SN_multiply = function(z) {
    return z.SN__multiply_EQ(this);
};
DISP.EQ.SN__multiply_EQ = pureVirtual;

DISP.EQ.SN_divide = function(z) {
    return z.SN__divide_EQ(this);
};
DISP.EQ.SN__divide_EQ = pureVirtual;

DISP.EQ.SN_expt = function(z) {
    return z.SN__expt_EQ(this);
};

function reduceEQ(n, d) {
    if (d.SN_isZero())
        divisionByExactZero();

    var g = gcdNonneg(n.SN_abs(), d.SN_abs());

    n = n.SN_div(g);
    d = d.SN_div(g);

    if (d.SN_isNegative())
        return canonicalEQ(n.SN_negate(), d.SN_negate());
    return canonicalEQ(n, d);
}

function canonicalEQ(n, d) {
    return (d === ONE ? n : new EQFraction(n, d));
}

//
// EQFraction: Exact rational as numerator (exact integer) and
// denominator (exact positive integer) with no factors in common.
//

function EQFraction(n, d) {
    //assert(d.SN_gt(ONE));
    //assert(gcdNonneg(n.SN_abs(), d).SN_eq(ONE));
    this._n = n;
    this._d = d;
}

EQFraction.prototype = new EQ();

DISP.EQFraction.SN_numberToString = function(radix, precision) {
    return (this._n.SN_numberToString(radix) +
            "/" + this._d.SN_numberToString(radix));
};

DISP.EQFraction.valueOf = function() {
    var n = this._n;
    var d = this._d;
    var ret = n / d;
    if (!_isNaN(ret))
        return ret;
    if (n.SN_isNegative())
        return -exp(n.SN_negate().SN_log() - d.SN_log());
    return exp(n.SN_log() - d.SN_log());
};

DISP.EQFraction.SN_debug = function() {
    return "EQFraction(" + this._n.SN_debug()
        + " / " + this._d.SN_debug() + ")";
};

DISP.EQFraction.SN_numerator = function () {
    return this._n;
};

DISP.EQFraction.SN_denominator = function() {
    return this._d;
};

DISP.EQFraction.SN_isPositive = function() {
    return this._n.SN_isPositive();
};

DISP.EQFraction.SN_isNegative = function() {
    return this._n.SN_isNegative();
};

DISP.EQFraction.SN__eq_EQ = function(q) {
    return (q.SN_numerator().SN_eq(this._n) &&
            q.SN_denominator().SN_eq(this._d));
};

DISP.EQFraction.SN__ne_EQ = function(q) {
    return (q.SN_numerator().SN_ne(this._n) ||
            q.SN_denominator().SN_ne(this._d));
};

DISP.EQFraction.SN__compare_EQ = function(q) {
    var qn = q.SN_numerator();
    var signDiff = q.SN_sign() - this._n.SN_sign();
    if (signDiff !== 0)
        return (signDiff > 0 ? 1 : -1);
    var qd = q.SN_denominator();
    if (qd === this._d)
        return qn.SN_compare(this._n);
    return qn.SN_multiply(this._d).SN_compare(qd.SN_multiply(this._n));
};

DISP.EQFraction.SN_negate = function() {
    return new EQFraction(this._n.SN_negate(), this._d);
};

DISP.EQFraction.SN_square = function() {
    return new EQFraction(this._n.SN_square(), this._d.SN_square());
};

DISP.EQFraction.SN_reciprocal = function() {
    switch (this._n.SN_sign()) {
    case -1: return canonicalEQ(this._d.SN_negate(), this._n.SN_negate());
    case 1: return canonicalEQ(this._d, this._n);
    case 0: default: divisionByExactZero();
    }
};

DISP.EQFraction.SN_floor = function() {
    return this._n.SN_div(this._d);
};

DISP.EQFraction.SN_ceiling = function() {
    //assert(this._d.SN_gt(ONE));
    return this._n.SN_div(this._d).SN_add(ONE);
};

DISP.EQFraction.SN_round = function() {
    if (this._d.SN_eq(TWO)) {
        var ret = this._n.SN_div(TWO);
        return ret.SN_isEven() ? ret : ret.SN_add(ONE);
    }
    var dm = this._n.SN_divAndMod(this._d);
    var mod = dm[1];
    if (mod.SN_add(mod).SN_lt(this._d))
        return dm[0];
    return dm[0].SN_add(ONE);
};

DISP.EQFraction.SN_truncate = function() {
    if (this._n.SN_isPositive())
        return this._n.SN_div(this._d);
    return this._d.SN_isUnit() ? this._n : this._n.SN_div(this._d).SN_add(ONE);
};

DISP.EQFraction.SN_sign = function() {
    return this._n.SN_sign();
};

DISP.EQFraction.SN_abs = function() {
    if (this._n.SN_sign() >= 0)
        return this;
    return this.SN_negate();
};

DISP.EQFraction.SN__add_EQ = function(q) {
    var n1 = q.SN_numerator();
    var d1 = q.SN_denominator();
    var n2 = this._n;
    var d2 = this._d;
    return reduceEQ(n1.SN_multiply(d2).SN_add(n2.SN_multiply(d1)),
                    d1.SN_multiply(d2));
};

DISP.EQFraction.SN__subtract_EQ = function(q) {
    var n1 = q.SN_numerator();
    var d1 = q.SN_denominator();
    var n2 = this._n;
    var d2 = this._d;
    return reduceEQ(n1.SN_multiply(d2).SN_subtract(n2.SN_multiply(d1)),
                    d1.SN_multiply(d2));
};

DISP.EQFraction.SN__multiply_EQ = function(q) {
    return reduceEQ(q.SN_numerator().SN_multiply(this._n),
                    q.SN_denominator().SN_multiply(this._d));
};

DISP.EQFraction.SN__divide_EQ = function(q) {
    return reduceEQ(q.SN_numerator().SN_multiply(this._d),
                    q.SN_denominator().SN_multiply(this._n));
};

DISP.EQFraction.SN__add_EI = function(n) {
    return canonicalEQ(n.SN_multiply(this._d).SN_add(this._n), this._d);
};

DISP.EQFraction.SN__subtract_EI = function(n) {
    return canonicalEQ(n.SN_multiply(this._d).SN_subtract(this._n), this._d);
};

DISP.EQFraction.SN__multiply_EI = function(n) {
    return reduceEQ(n.SN_multiply(this._n), this._d);
};

DISP.EQFraction.SN__divide_EI = function(n) {
    return reduceEQ(n.SN_multiply(this._d), this._n);
};

DISP.EQFraction.SN_sqrt = function() {
    // This EQ may be too big for toValue(), but its square root may not be.
    return this._n.SN_sqrt().SN_divide(this._d.SN_sqrt());
};

DISP.EQFraction.SN_log = function() {
    return this._n.SN_log().SN_subtract(this._d.SN_log());
};

//
// EI: Exact integer abstract base class.
//

function parseEI(sign, string, radix) {
    var n = _parseInt(string, radix || 10);

    if (n < 9007199254740992)
        return toEINative(sign * n);

    return parseEIBig(string, sign, radix);
}

DISP.EI.SN_isInteger = retTrue;

DISP.EI.SN_debug = function() { return "EI"; };

DISP.EI.SN_numerator   = retThis;
DISP.EI.SN_denominator = function() { return ONE; };
DISP.EI.SN_floor       = retThis;
DISP.EI.SN_ceiling     = retThis;
DISP.EI.SN_round       = retThis;
DISP.EI.SN_truncate    = retThis;

DISP.EI.SN__toBigInteger = pureVirtual;

DISP.EI.SN_eq = function(z) {
    return z.SN__eq_EI(this);
};
DISP.EI.SN__eq_EI = function(n) {
    return n.SN__toBigInteger().compare(this.SN__toBigInteger()) === 0;
};
DISP.EI.SN__eq_EQ = function(q) {
    return q.SN_numerator().SN_eq(this) && q.SN_denominator().SN_eq(ONE);
};

DISP.EI.SN_ne = function(z) {
    return z.SN__ne_EI(this);
};
DISP.EI.SN__ne_EI = function(n) {
    return n.SN__toBigInteger().compare(this.SN__toBigInteger()) !== 0;
};
DISP.EI.SN__ne_EQ = function(q) {
    return q.SN_numerator().SN_ne(this) || q.SN_denominator().SN_ne(ONE);
};

DISP.EI.SN_compare = function(x) {
    return x.SN__compare_EI(this);
};
DISP.EI.SN__compare_EQ = function(q) {
    return q.SN_numerator().SN_compare(q.SN_denominator().SN_multiply(this));
};
DISP.EI.SN__compare_EI = function(n) {
    return n.SN__toBigInteger().compare(this.SN__toBigInteger());
};

DISP.EI.SN_add = function(z) {
    return z.SN__add_EI(this);
};
DISP.EI.SN_subtract = function(z) {
    return z.SN__subtract_EI(this);
};
DISP.EI.SN_multiply = function(z) {
    return z.SN__multiply_EI(this);
};
//DISP.EI.SN_divide = function(z) {
//    return z.SN__divide_EI(this);
//};

DISP.EI.SN_reciprocal = function() {
    if (this.SN_isNegative())
        return canonicalEQ(M_ONE, this.SN_negate());
    return canonicalEQ(ONE, this);
};

DISP.EI.SN_divAndMod = function(x) {
    return x.SN__divAndMod_EI(this);
};
DISP.EI.SN_div = function(x) {
    return x.SN__div_EI(this);
};
DISP.EI.SN_mod = function(x) {
    return x.SN__mod_EI(this);
};

DISP.EI.SN__add_EI = function(n) {
    return reduceBigInteger(n.SN__toBigInteger()
                            .add(this.SN__toBigInteger()));
};
DISP.EI.SN__subtract_EI = function(n) {
    return reduceBigInteger(n.SN__toBigInteger()
                            .subtract(this.SN__toBigInteger()));
};
DISP.EI.SN__multiply_EI = function(n) {
    return reduceBigInteger(n.SN__toBigInteger()
                            .multiply(this.SN__toBigInteger()));
};
DISP.EI.SN__divAndMod_EI = function(n) {
    var t = this.SN__toBigInteger();
    var dm = n.SN__toBigInteger().divRem(t);
    var div = dm[0];
    var mod = dm[1];

    if (mod.isNegative()) {
        mod = mod.add(t);
        div = div.prev();
    }
    return [reduceBigInteger(div), reduceBigInteger(mod)];
};
DISP.EI.SN__div_EI = function(n) {
    return this.SN__divAndMod_EI(n)[0];
};
DISP.EI.SN__mod_EI = function(n) {
    return this.SN__divAndMod_EI(n)[1];
};

DISP.EI.SN__add_EQ = function(q) {
    var d = q.SN_denominator();
    return canonicalEQ(q.SN_numerator().SN_add(d.SN_multiply(this)), d);
};

DISP.EI.SN__subtract_EQ = function(q) {
    var d = q.SN_denominator();
    return canonicalEQ(q.SN_numerator().SN_subtract(d.SN_multiply(this)), d);
};

DISP.EI.SN__multiply_EQ = function(q) {
    return reduceEQ(q.SN_numerator().SN_multiply(this), q.SN_denominator());
};

DISP.EI.SN__divide_EQ = function(q) {
    return reduceEQ(q.SN_numerator(), q.SN_denominator().SN_multiply(this));
};

DISP.EI.SN_expt = function(z) {
    return z.SN__expt_EI(this);
};

DISP.EI.SN__expt_EI = function(n) {
    // Return n to the power of this integer.

    var s = this.SN_sign();
    var p = this.SN_abs().valueOf();

    // If p != this due to inexactness, our result would exhaust memory,
    // since |n| is at least 2.  (expt is specialized for -1, 0, and 1.)
    //assert(n.SN_abs().SN_ge(2));

    var result = pow(n, p);
    var a;
    if (result > -9007199254740992 && result < 9007199254740992) {
        a = toEINative(result);
    }
    else {
        var newLog = n.SN_log() * p;
        if (newLog > SN.maxIntegerDigits * LN10)
            raise("&implementation-restriction",
                  "exact integer would exceed limit of " +
                  (+SN.maxIntegerDigits) +
                  " digits; adjust SchemeNumber.maxIntegerDigits",
                  newLog / LN10);

        a = new EIBig(n.SN__toBigInteger().pow(p));
    }
    return (s > 0 ? a : a.SN_reciprocal());
};

function expt_E_EI(z, n) {
    // Return z raised to the power of this integer.
    // We don't get here if either z or this is 0, 1, or -1.
    //assert(this.SN_abs().SN_gt(ONE));
    //assert(z.SN_magnitude().SN_gt(ONE) || !z.SN_isInteger());
    var bits = n.SN_abs();
    var squarer = z;
    var ret = ONE;
    while (bits.SN_isPositive()) {
        if (bits.SN_isOdd())
            ret = ret.SN_multiply(squarer);
        squarer = squarer.SN_square();
        bits = bits.SN_div(TWO);
    }
    return (n.SN_isNegative() ? ret.SN_reciprocal() : ret);
}

DISP.EI.SN__expt_ER = function(x) {
    return expt_E_EI(x, this);
};

DISP.EI.SN__expt_C = function(z) {
    if (z.SN_isExact())
        return expt_E_EI(z, this);
    return complexExpt(z, this);
};

//
// EINative: Exact integers as native numbers.
//

function EINative(x) {
    //assert(x === floor(x));
    this._ = x;
}

EINative.prototype = new EI();

var ZERO  = SN.ZERO  = new EINative(0);
var ONE   = SN.ONE   = new EINative(1);
var M_ONE = SN.M_ONE = new EINative(-1);
var TWO   = SN.TWO   = new EINative(2);

var EINativeSmall    = [ ZERO, ONE, TWO ];

var I     = SN.I   = new Rectangular(ZERO, ONE);
var M_I   = SN.M_I = new Rectangular(ZERO, M_ONE);

function toEINative(n) {
    //assert(floor(n) === n);
    return EINativeSmall[n] || (n == -1 ? M_ONE : new EINative(n));
}

ZERO.SN_isZero     = retTrue;
ZERO.SN_isPositive = retFalse;
ZERO.SN_isNegative = retFalse;

ZERO.SN_compare = function(x) {
    return -x.SN_sign();
};

ZERO.SN_add        = SN;
ZERO.SN_negate     = retThis;
ZERO.SN_abs        = retThis;
ZERO.SN_multiply   = retThis;
ZERO.SN_square     = retThis;
ZERO.SN_reciprocal = divisionByExactZero;

ZERO.SN_subtract = function(z) {
    return z.SN_negate();
};

ZERO.SN_divide   = function(z) {
    if (z.SN_isZero() && z.SN_isExact())
        divisionByExactZero();
    return this;
};

ZERO.SN_expt = function(z) {
    switch (z.SN_realPart().SN_sign()) {
    case 1: return this;
    case 0: return ONE;
    case -1: default: divisionByExactZero();
    }
};

ZERO.SN_sqrt = retThis;
ZERO.SN_exp = retOne;
ZERO.SN_sin = retThis;
ZERO.SN_cos = retOne;
ZERO.SN_tan = retThis;
ZERO.SN_asin = retThis;
ZERO.SN_atan = retThis;

ONE.SN_isUnit     = retTrue;
ONE.SN_abs        = retThis;
ONE.SN_multiply   = SN;
ONE.SN_reciprocal = retThis;
ONE.SN_square     = retThis;
ONE.SN_expt       = ZERO.SN_multiply;
ONE.SN_sqrt       = retThis;
ONE.SN_log        = retZero;
ONE.SN_acos       = retZero;

M_ONE.SN_isUnit     = retTrue;
M_ONE.SN_abs        = retOne;
M_ONE.SN_multiply   = ZERO.SN_subtract;
M_ONE.SN_reciprocal = retThis;
M_ONE.SN_square     = retOne;
M_ONE.SN_sqrt       = function() { return I; };

M_ONE.SN_expt = function(z) {
    if (!z.SN_isInteger())
        return complexExpt(this, z);
    var ret = (z.SN_isEven() ? ONE : M_ONE);
    if (z.SN_isExact())
        return ret;
    return ret.SN_toInexact();
}

function negate(z) {
    return z.SN_negate();
}
function reciprocal(z) {
    return z.SN_reciprocal();
}

for (className in CLASSES) {
    ZERO["SN__add_"      + className] = retFirst;
    ZERO["SN__subtract_" + className] = retFirst;
    ZERO["SN__multiply_" + className] = retThis;
    ZERO["SN__divide_"   + className] = divisionByExactZero;
    ZERO["SN__expt_"     + className] = retOne;
    ONE["SN__multiply_" + className] = retFirst;
    ONE["SN__divide_"   + className] = retFirst;
    ONE["SN__expt_"     + className] = retFirst;
    M_ONE["SN__multiply_" + className] = negate;
    M_ONE["SN__divide_"   + className] = negate;
    M_ONE["SN__expt_"     + className] = reciprocal;
}

DISP.EINative.valueOf = function() {
    return this._;
};

DISP.EINative.SN_numberToString = function(radix, precision) {
    return this._.toString(radix || 10);
};

DISP.EINative.SN_debug = function() {
    return "EINative(" + this._ + ")";
};

DISP.EINative.SN__toBigInteger = function() {
    return BigInteger(this._);
};

DISP.EINative.SN_isPositive = function() {
    return this._ > 0;
};

DISP.EINative.SN_isNegative = function() {
    return this._ < 0;
};

DISP.EINative.SN_sign = function() {
    return (this._ > 0 ? 1 : (this._ == 0 ? 0 : -1));
};

DISP.EINative.SN_isEven = function() {
    return (this._ & 1) === 0;
};

DISP.EINative.SN_isOdd = function() {
    return (this._ & 1) === 1;
};

DISP.EINative.SN_eq = function(z) {
    return z.SN__eq_EINative(this);
};
DISP.EINative.SN__eq_EINative = function(n) {
    return n._ === this._;
};

DISP.EINative.SN_ne = function(z) {
    return z.SN__ne_EINative(this);
};
DISP.EINative.SN__ne_EINative = function(n) {
    return n._ !== this._;
};

DISP.EINative.SN_compare = function(x) {
    return x.SN__compare_EINative(this);
};
DISP.EINative.SN__compare_EINative = function(n) {
    return (n._ === this._ ? 0 : (n._ > this._ ? 1 : -1));
};

function add_EINative_EINative(a, b) {
    var ret = a + b;
    if (ret > -9007199254740992 && ret < 9007199254740992)
        return toEINative(ret);
    return new EIBig(BigInteger.add(a, b));
}

DISP.EINative.SN_add = function(z) {
    return z.SN__add_EINative(this);
};
DISP.EINative.SN__add_EINative = function(n) {
    return add_EINative_EINative(n._, this._);
};

DISP.EINative.SN_negate = function() {
    return toEINative(-this._);
};

DISP.EINative.SN_abs = function() {
    return (this._ < 0 ? toEINative(-this._) : this);
};

DISP.EINative.SN_subtract = function(z) {
    return z.SN__subtract_EINative(this);
};
DISP.EINative.SN__subtract_EINative = function(n) {
    return add_EINative_EINative(n._, -this._);
};

DISP.EINative.SN_multiply = function(z) {
    return z.SN__multiply_EINative(this);
};
DISP.EINative.SN__multiply_EINative = function(n) {
    var ret = n._ * this._;
    if (ret > -9007199254740992 && ret < 9007199254740992)
        return toEINative(ret);
    return new EIBig(BigInteger(n._).multiply(this._));
};

DISP.EINative.SN_square = function() {
    var ret = this._ * this._;
    if (ret < 9007199254740992)
        return toEINative(ret);
    return new EIBig(BigInteger(this._).square());
};

DISP.EINative.SN_reciprocal = function() {
    var x = this._;
    assert(x !== 0);
    /*
    if (x === 0)  // Removed this check, since ZERO overrides.
        throw divisionByExactZero();
    if (x === 1 || x === -1)  // Removed this optimization, similar reason.
        return this;
    */
    if (x < 0)
        return canonicalEQ(M_ONE, toEINative(-x));
    return canonicalEQ(ONE, this);
};

function divAndMod_EINative(t, x, which) {
    if (x === 0)
        divisionByExactZero();

    var div = (x > 0 ? floor(t / x) : ceil(t / x));
    if (which === 0)
        return toEINative(div);

    var tmp = x * div;
    var mod;

    if (tmp > -9007199254740992)
        mod = t - tmp;
    else if (div > 0)
        mod = (t - x) - (x * (div - 1));
    else
        mod = (t + x) - (x * (div + 1));

    mod = toEINative(mod);
    if (which === 1)
        return mod;

    return [toEINative(div), mod];
};

DISP.EINative.SN_div = function(x) {
    return x.SN__div_EINative(this);
};
DISP.EINative.SN__div_EINative = function(n) {
    return divAndMod_EINative(n._, this._, 0);
};

DISP.EINative.SN_mod = function(x) {
    return x.SN__mod_EINative(this);
};
DISP.EINative.SN__mod_EINative = function(n) {
    return divAndMod_EINative(n._, this._, 1);
};

DISP.EINative.SN_divAndMod = function(x) {
    return x.SN__divAndMod_EINative(this);
};
DISP.EINative.SN__divAndMod_EINative = function(n) {
    return divAndMod_EINative(n._, this._, 2);
};

DISP.EINative.SN__exp10 = function(n) {
    if (this._ === 0 || n === 0)
        return this;

    if (n < 0) {
        var num = String(this._);
        var i = num.length - 1;

        if (num[i] === '0') {
            while (num[i] === '0' && n < 0) {
                n += 1;
                i -= 1;
            }
            num = toEINative(Number(num.substring(0, i + 1)));
            if (n === 0)
                return num;
        }
        else {
            num = this;
        }

        var den;
        if (n < -15)
            den = new EIBig(BigInteger.ONE.exp10(-n));
        else
            // Could make this an array lookup.
            den = toEINative(Number("1000000000000000".substring(0, 1 - n)));
        return reduceEQ(num, den);
    }
    if (n < 16) {
        // Could make substring+parseInt an array lookup.
        var result = _parseInt("1000000000000000".substring(0, n + 1)) * this._;
        if (result > -9007199254740992 && result < 9007199254740992)
            return toEINative(result);
    }
    return new EIBig(BigInteger(this._).exp10(n));
};

DISP.EINative.SN_exactIntegerSqrt = function() {
    var n = floor(sqrt(assertNonNegative(this)._));
    return [toEINative(n), toEINative(this._ - n * n)];
};

//
// EIBig: Exact integer as a BigInteger.
//

// 2 to the power 53, top of the range of consecutive integers
// representable exactly as native numbers.
var FIRST_BIG_INTEGER = BigInteger(9007199254740992);

function reduceBigInteger(n) {
    if (n.compareAbs(FIRST_BIG_INTEGER) >= 0)
        return new EIBig(n);
    return toEINative(n.toJSValue());
}

function EIBig(n) {
    this._ = n;
}

EIBig.prototype = new EI();

function parseEIBig(s, sign, radix) {
    n = BigInteger.parse(s, radix);
    if (sign < 0)
        n = n.negate();
    return new EIBig(n);
}

DISP.EIBig.SN_numberToString = function(radix) {
    return this._.toString(radix);
};

DISP.EIBig.valueOf = function() {
    return this._.valueOf();
};

["isZero", "isEven", "isOdd", "sign", "isUnit", "isPositive", "isNegative"]
    .forEach(function(fn) {
            DISP.EIBig["SN_" + fn] = function() {
                return this._[fn]();
            };
        });

DISP.EIBig.SN_log = function() {
    var x = toFlonum(this._.abs().log());
    return this._.isPositive() ? x : inexactRectangular(x, PI);
};

DISP.EIBig.SN_debug = function() {
    return "EIBig(" + this._.toString() + ")";
};

DISP.EIBig.SN__toBigInteger = function() {
    return this._;
};

DISP.EIBig.SN_add = function(z) {
    return z.SN__add_EIBig(this);
};

DISP.EIBig.SN_negate = function() {
    return new EIBig(this._.negate());
};

DISP.EIBig.SN_abs = function() {
    return new EIBig(this._.abs());
};

DISP.EIBig.SN_subtract = function(z) {
    return z.SN__subtract_EIBig(this);
};

DISP.EIBig.SN_multiply = function(z) {
    return z.SN__multiply_EIBig(this);
};

DISP.EIBig.SN_square = function() {
    return new EIBig(this._.square());
};

DISP.EIBig.SN__exp10 = function(n) {
    //assert(n === floor(n));
    if (n === 0)
        return this;
    if (n > 0)
        return new EIBig(this._.exp10(n));
    return reduceEQ(this, ONE.SN__exp10(-n));
};

DISP.EIBig.SN_sqrt = function() {
    //assert(!this.SN_isZero());
    var mag = toFlonum(exp(this._.abs().log() / 2));
    return (this._.isNegative() ? inexactRectangular(INEXACT_ZERO, mag) : mag);
};

DISP.EIBig.SN_exactIntegerSqrt = function() {

    // I know of no use cases for this.  Be stupid.  Be correct.

    //assert(this._.compareAbs(FIRST_BIG_INTEGER) >= 0);

    function doit(n, a) {
        while (true) {
            var dm = n.divRem(a);
            var b = dm[0];
            var diff = a.subtract(b); // n == b*b + b*diff + dm[1], dm[1] < b+1

            if (diff.isZero())
                return [ b, dm[1] ]; // n == b*b + dm[1]

            if (diff.isUnit()) {
                if (diff.isPositive())
                    // n == b*b + b + dm[1], dm[1] < b+1
                    return [ b, b.add(dm[1]) ];

                // n == b*b - b + dm[1] == (b-1)^2 + b - 1 + dm[1]
                return [ a, a.add(dm[1]) ];
            }

            a = b.add(diff.quotient(2));
        }
    }

    var l = assertNonNegative(this)._.log() / 2 / LN10;
    var a = BigInteger(pow(10, l - floor(l)).toString()
                       + "e" + floor(l));
    return doit(this._, a).map(reduceBigInteger);
};

function gcdNative(a, b) {
    //assert(a >= 0 && b >= 0)
    var c;
    while (a !== 0) {
        c = a;
        a = b % a;
        b = c;
    }
    return toEINative(b);
}

// a and b must be nonnegative, exact integers.
function gcdNonneg(a, b) {
    //assert(!a.SN_isNegative());
    //assert(!b.SN_isNegative());
    //assert(a instanceof EI);
    //assert(b instanceof EI);
    if (a instanceof EINative && b instanceof EINative)
        return gcdNative(a.valueOf(), b.valueOf());

    a = a.SN__toBigInteger();
    if (a.isZero())
        return b;

    b = b.SN__toBigInteger();
    var c;

    while (true) {
        c = a;
        a = b.remainder(a);
        if (a.isZero())
            return new EIBig(c);
        b = c;
        if (b.compareAbs(FIRST_BIG_INTEGER) < 0)
            return gcdNative(a.valueOf(), b.valueOf());
    }
}

function numberToBigInteger(n) {
    return BigInteger.parse(n.toString(16), 16);
}

//
// Inheritance plumbing.
//

/*
function showMethodClasses() {
    var map = {};
    for (var className in DISP)
        for (var methName in DISP[className])
            (map[methName] = map[methName] || {})[className] = DISP[className][methName];
    for (var methName in map)
        for (var className in map[methName])
            print(className + "." + methName + (map[methName][className] === pureVirtual ? " =0" : ""));
}
showMethodClasses();
*/

function resolveOverload(className) {
    var proto = DISP[className];
    var newMethods = {};

    function resolve(subclasses, prefix, method) {
        function resolveSub(subclass) {
            if (proto[prefix + subclass])
                return;
            //print(className + "." + prefix + subclass + " -> " + oldName);
            newMethods[prefix + subclass] = method;
            resolve(HIERARCHY[subclass], prefix, method);
        }
        if (subclasses)
            subclasses.forEach(resolveSub);
    }

    for (var oldName in proto) {
        if (!/^SN_/.test(oldName))
            continue;

        var underscore = oldName.lastIndexOf("_");
        if (underscore === -1)
            continue;

        var oldMethod = proto[oldName];
        if (!oldMethod) {
            //print("Bogus " + className + ".prototype." + oldName);
            continue;
        }

        var oldClass = oldName.substring(underscore + 1);

        resolve(HIERARCHY[oldClass],
                oldName.substring(0, underscore + 1),
                oldMethod);
    }

    for (var methodName in newMethods) {
        proto[methodName] = newMethods[methodName];
    }
}

for (var className in CLASSES)
    resolveOverload(className);

if (Flonum === Number) {
    // Workaround for Flonum not inheriting from R.
    for (var methodName in DISP.R) {
        if (/^SN_/.test(methodName) && !DISP.Flonum[methodName])
            DISP.Flonum[methodName] = DISP.R[methodName];
    }

    // Workaround for Flonum not inheriting from C.
    for (var methodName in DISP.C) {
        if (/^SN_/.test(methodName) && !DISP.Flonum[methodName])
            DISP.Flonum[methodName] = DISP.C[methodName];
    }

    // Workaround for C inheriting from Flonum.
    for (var methodName in DISP.Flonum) {
        if (!DISP.C[methodName])
            DISP.C[methodName] = unimpl;
    }
}

// Install methods.
for (var className in CLASSES) {
    for (var methodName in DISP[className]) {
        CLASSES[className].prototype[methodName] = DISP[className][methodName];
    }
}

function checkPureVirtual(handler) {
    var e = "";
    for (var className in CLASSES) {
        if (!/[a-z]/.test(className)) {
            // Not a concrete class.
            continue;
        }
        var proto = CLASSES[className].prototype;
        for (methodName in proto) {
            if (proto[methodName] === pureVirtual)
                e += "Pure virtual: " + className + "." + methodName + "\n";
        }
    }
    if (e) {
        handler(e);
    }
}
checkPureVirtual(this.alert || this.print || function(e) {throw e;});

SN.pluginApi = {
    N:N, C:C, R:R, ER:ER, EQ:EQ, EI:EI, pureVirtual:pureVirtual, raise:raise
};
SN._bogusApi = {
    Flonum:Flonum, Rectangular:Rectangular, EQFraction:EQFraction,
    EINative:EINative, EIBig:EIBig
};

return SN;

})();

if (typeof exports !== "undefined") {
    exports.SchemeNumber = SchemeNumber;
    for (var name in SchemeNumber.fn)
        exports[name] = SchemeNumber.fn[name];
}

// load for testing: load("biginteger.js");load("schemeNumber.js");sn=SchemeNumber;fn=sn.fn;ns=fn["number->string"];1

/*
  Export to plugins:
  * N C R ER EQ EI pureVirtual raise
  * everything supplied by plugins
  * some way to "install" binary operators

  Get from plugins:
  toFlonum parseEI toEINative parseDecimal
  exactRectangular inexactRectangular makePolar
 */


"use strict";
/*

Copyright 2010-2018 Scott Fortmann-Roe. All rights reserved.

This file may distributed and/or modified under the
terms of the Insight Maker Public License (https://InsightMaker.com/impl).

*/

if(! sn){
	var sn = SchemeNumber;
	var fn = sn.fn;
	var ns = fn["number->string"];

	sn.raise = function(conditionType, message){
		if (message == "division by exact zero"){
			throw "MSG: You cannot divide by 0."
		}else{
			throw "BigNum Error: "+message;
		}
	}
}

var varBank = {};
var functionBank = varBank;

var functionLoaders = [];

function bootCalc(){
	varBank = {};
	functionBank = varBank;
	
	varBank["-parent"] = null;
	varBank["e"] = new Material(2.71828182845904523536);
	varBank["pi"] = new Material(3.14159265358979323846264338);
	varBank["phi"] = new Material(1.61803399);
	for(var i=0; i< functionLoaders.length; i++){
		functionLoaders[i]();
	}
	
	varBank["stringbase"] = StringBase;
	varBank["vectorbase"] = VectorBase;
	if(window.ObjectBase){
		varBank["objectbase"] = ObjectBase;
	}
	if(window.AgentBase){
		varBank["agentbase"] = AgentBase;
	}
}


if(! Agent){
	var Agent = function(){}
}
if(! Agents){
	var Agents = function(){}
}

var PrimitiveStore = function(primitive, type){
	this.primitive = primitive;
	this.type = type; // "value", "totalValue", "object"
}

/*

var Primitive = function(value){
	this.val = value;
}
Primitive.prototype.value = function(){
	return this.val;
}
primitiveBank["x"] = new Primitive(10);
primitiveBank["xy"] = new Primitive(5);*/

Boolean.prototype.toNum = function(){
	return this.valueOf();
}
String.prototype.toNum = function(){
	return this.valueOf();
}
Number.prototype.toNum = function(){
	return this.valueOf();
}
Function.prototype.toNum = function(){
	return this([]);
}

function UserFunction(){
	
}
UserFunction.prototype.toNum = function(){
	if(!this.fn){
		return this([]);
	}else{
		return this.fn([]);
	}
}

var StringObject = {};
var StringBase;
var VectorObject = {};
var VectorBase = {};
var Vector = function(items, names, parent){
	this.parent = parent?parent:VectorBase;
	this.items = items;
	this.names = names;
	this.namesLC = undefined;
	if(names){
		this.namesLC = [];
		for(var i = 0; i < names.length; i++){
			if(names[i]){
				this.namesLC.push(names[i].toLowerCase())  
			}else{
				this.namesLC.push(undefined);
			}
		}
	}
	
}

Vector.prototype.toNum = function(){
	if(this.isNum){
		return this;
	}

	var v = this.fullClone();
	for(var i=0; i<v.items.length; i++){
		v.items[i] = v.items[i].toNum();
	}
	v.isNum = true;
	return v;
};
Vector.prototype.toString = function(){
	//console.log(this.names);
	var items = [];
	for(var i=0; i<this.items.length; i++){
		var str = prepareDisplay(this.items[i].toNum().toString())
		if(this.names && this.names[i]){
			str = this.names[i]+": "+str; 
		}
		items.push(str);
	}
	return '{'+items.join(", ")+'}';
};
Vector.prototype.length = function(){
	return this.items.length;
};
Vector.prototype.cloneCombine = function(other, operation, rhs, noswitch){
	return this.fullClone().combine(other, operation, rhs, noswitch);
}
Vector.prototype.combine = function(other, operation, rhs, noswitch){	
	if(other instanceof Vector){
		if((this.length() != other.length()) && (! this.names) && (! other.names)){
			throw "MSG: Vectors must have equal length when combined.";
		}
	}
	if((other instanceof Vector) && this.names && other.names){
		if((! noswitch) && other.depth() > this.depth()){
			return other.combine(this, operation, ! rhs);
		}
		if(! this.keysMatch(other.namesLC)){
			if(this.items[0] instanceof Vector){
				for(var i=0; i< this.items.length; i++){
					this.items[i].combine(other, operation, rhs, true)
				}
				return this;
			}else{
				throw "MSG: Keys do not match for vector operation."
			}
		}
	}
	for(var i=0; i< this.length(); i++){
		var x;
		if(other instanceof Vector){
			if(this.names && other.names){
				var index = other.namesLC.indexOf(this.namesLC[i]);
				if(this.names=="*"){
					index = -2;
				}
				if(isUndefined(index) || index == -1){
					index = other.names.indexOf("*");
				}
				if(isUndefined(index) || index == -1){
					throw "MSG: Mismatched keys for vector operation."
				}
				if( index == -2){
					x = undefined;
				}else{
					x = other.items[index];
				}
			}else{
				x = other.items[i];
			}
		}else{
			x = other;
		}
		if(isDefined(x)){
			if(rhs){
				this.items[i] = operation(x, this.items[i]);
			}else{
				this.items[i] = operation(this.items[i], x);
			}
		}
	}
	if(this.names && this.names.indexOf("*") > -1 && (other instanceof Vector) && other.names){
		var starred = this.items[this.names.indexOf("*")]
		for(var i = 0; i < other.names.length; i++){
			if(other.names[i] && (this.namesLC.indexOf(other.namesLC[i]) == -1 || other.names == "*")){

				if(rhs){
					this.items.push(operation(other.items[i], starred));
				}else{
					this.items.push(operation(starred, other.items[i]));
				}
				this.names.push(other.names[i])
				this.namesLC.push(other.namesLC[i])
			}
		}
	}
	return this;
};
Vector.prototype.collapseDimensions = function(target){
	if(target instanceof Vector){
		if(this.depth() == target.depth()){
			return this;
		}else{
			var selector = [];
			var base = this;
			var targetLevel = target;
			for(var i=0; i<this.depth(); i++){
				if(!(targetLevel instanceof Vector)){
					selector.push(function(x){return functionBank["sum"](x[0].items)});
					base = base.items[0];
				}else if((base.namesLC === undefined && targetLevel.namesLC === undefined) || (base.namesLC !== undefined && targetLevel.namesLC !== undefined && keysMatch(base.namesLC, targetLevel.namesLC))){
					selector.push("*");
					base = base.items[0];
					targetLevel = targetLevel.items[0]
				}else{
					selector.push(function(x){return functionBank["sum"](x[0].items)});
					
					base = base.items[0];
				}
			}
			if(targetLevel.items){
				throw "MSG: Keys do not match for vector collapsing.";
			}
			return selectFromMatrix(this, selector);
		}
	}else{
		return functionBank["sum"]([functionBank["flatten"]([this])]);
	}
};
function keysMatch(thisNames, keys){
	if(keys.indexOf("*") == -1){
		for(var i = 0; i < thisNames.length; i++){
			if(thisNames[i] != "*"){
				if(isUndefined(thisNames[i])){
					return false;
				}
				if(keys.indexOf(thisNames[i])==-1){
					return false
				}
			}
		}
	}
	if(thisNames.indexOf("*") == -1){
		for(var i = 0; i < keys.length; i++){
			if(keys[i] != "*"){
				if(isUndefined(keys[i])){
					return false;
				}
				if(thisNames.indexOf(keys[i])==-1){
					return false
				}
			}
		}
	}
	return true;
}
Vector.prototype.depth = function(){
	if(this.items.length == 0 || !(this.items[0] instanceof Vector)){
		return 1;
	}
	return this.items[0].depth()+1;
};
Vector.prototype.keysMatch = function(keys){
	if(this.names){
		return keysMatch(this.namesLC, keys)
	}else{
		return false
	}
	return true;
};
Vector.prototype.cloneApply = function(operation){
	return this.fullClone().apply(operation);
};
Vector.prototype.apply = function(operation){
	for(var i=0; i < this.items.length; i++){
		this.items[i] = operation(this.items[i], this.names?(this.names[i]):undefined);
	}
	return this;
};

Vector.prototype.stackApply = function(operation){
	//console.log("Stacking")
	if(this.depth() == 1){
		return operation(this);
	}
	var s = this.stack();
	//console.log(s);
	return s.recurseApply(operation);
};
Vector.prototype.stack = function(selector){
	//console.log("Stack!")
	var res = [];
	
	selector = selector || [0];
	
	var base = this.select(selector);
	
	
	for(var i=1; i<this.items.length; i++){
		selector[0] = i;
		var alt = this.select(selector);
		if((base instanceof Vector ) && (alt instanceof Vector)){
			if((base.names && (! alt.names)) || (alt.names && (! base.names))){
				throw "MSG: Mismatched keys for vector collapsing.";
			}else if(base.items.length != alt.items.length){
				throw "MSG: Vectors of unequal size.";
			}
		}else if(! ((base instanceof Vector ) || (alt instanceof Vector)) ){
			throw "MSG: Mismatched keys for vector collapsing.";
		}
	}
	selector[0] = 0
	
	selector.push(0)
	
	//console.log(base.items.length);
	for(var i = 0; i < base.items.length; i++){
		//console.log(i)
		selector[selector.length-1] = base.names?base.namesLC[i]:i;
		
		if(base.items[i] instanceof Vector){
			res.push(this.stack(selector.slice()));
		}else{
			var vecs = [];
			var baseSub;
			for(var j = 0; j < this.items.length; j++){
				var newSelector = selector.slice();
				newSelector[0] = j
				
				var item = this.select(newSelector);
				if(item instanceof Vector){
					throw("MSG: Number where vector expected in vector collapsing.")
				}
				vecs.push(item);
			}
			var v = new Vector(vecs);
			v.terminateApply = true; 
			res.push(v);
		}
	}
	
	return new Vector(res, base.names?base.names.slice():undefined);
};
Vector.prototype.select = function(selector){
	var b = this;
	
	for(var s = 0; s < selector.length; s++){
		if(! b.items){
			throw "MSG: Number where vector expected in vector collapsing.";
		}
		if((selector[s] instanceof String) || (typeof selector[s] == "string")){
			var ind = b.namesLC.indexOf(selector[s].valueOf());
			if(ind == -1){
				throw "MSG: Mismatched keys for vector collapsing.";
			}
			b = b.items[ind];
		}else{
			b = b.items[selector[s]];
		}
	}
	return b;
};
Vector.prototype.recurseApply = function(operation){
	for(var i=0; i < this.items.length; i++){
		if((this.items[i] instanceof Vector) && !(this.items[i].terminateApply)){
			this.items[i] = this.items[i].recurseApply(operation);
		}else{
			this.items[i] = operation(this.items[i]);
		}
	}
	return this;
};
Vector.prototype.fullNames = function(){
	if((this.items[0] instanceof Vector) && this.items[0].names){
		var subn = this.items[0].fullNames()
		var n = [];
		for(var i = 0; i < this.names.length; i++){
			for(var j = 0; j< subn.length; j++){
				n.push([this.names[i]].concat(subn[j]))
			}
		}
		//console.log(n)
		return n;
	}else{
		
		var n = [];
		for(var i=0; i<this.names.length; i++){
			n.push([this.names[i]]);
		}
		return n
	}
}
Vector.prototype.clone = function(){
	var newItems = [];
	for(var i=0; i<this.items.length; i++){
		if(this.items[i] instanceof Vector){
			newItems.push(this.items[i].clone());
		}else{
			newItems.push(this.items[i]);
		}
	}
	return new Vector(newItems, this.names?this.names.slice():undefined, this.parent);
};
Vector.prototype.fullClone = function(){
	var newItems = [];
	for(var i=0; i<this.items.length; i++){
		if(this.items[i].fullClone){
			newItems.push(this.items[i].fullClone());
		}else{
			newItems.push(this.items[i]);
		}
	}
	return new Vector(newItems, this.names?this.names.slice():undefined, this.parent);
};

Vector.prototype.equals = function(vec){
	if(this.length() != vec.length()){
		return false;
	}
	
	for(var i = 0; i < this.items.length; i++){
		if(! strictEquals(this.items[i], vec.items[i])){
			return false;
		}
	}
	return true;
}


if(! Primitive){
	var Primitive = function(n){
		this.v = n;
		this.vector = new Vector([],[], VectorBase);
	}
	Primitive.prototype.value = function(){
		return this.v.fullClone();
	};
	Primitive.prototype.setValue = function(newValue){
		this.v = newValue;
		return newValue;
	};
	Primitive.prototype.toNum = function(){
		return this.v.fullClone();
	};
	Primitive.prototype.toString = function(){
		return "Primitive Reference";
	};
	
	
}

function strictEquals(a,b){
	if((a instanceof Agent) || (b instanceof Agent)){
		if((a instanceof Agent) && (b instanceof Agent)){
			if(a.instanceId == b.instanceId){
				return true
			}
		}
	}else if((a instanceof Vector) || (b instanceof Vector)){
		if((a instanceof Vector) && (b instanceof Vector)){
			if(a.equals(b)){
				return true;
			}
		}
	}else if(eq(a,b)){
		return true;
	}
	return false;
}

function createTree(input){
	var cstream = new org.antlr.runtime.ANTLRStringStream(input.replace(/\\n/g,"\n"));
	var lexer = new FormulaLexer(cstream);
	var tstream = new org.antlr.runtime.CommonTokenStream(lexer);
	var parser = new FormulaParser(tstream);
	var parsedTree = parser.lines();
	var root = convertToObject(parsedTree.tree, parser);
	if (isLocal()) {
		//console.log(root);
	}
	return root;
}
function trimTree(root, primitiveBank){
	return trimNode(root, primitiveBank);	
}
function evaluateTree(root, varBank){
	evaluatingLine = undefined;
	try {
		return evaluateNode(root, varBank);	
	}catch(err){
		if(err.returnVal){
			return err.data;
		}else{
			throw(err);
		}
	}
}

var PB = {"test": new Primitive(new Material(3)),"a": new Primitive(new Material(1)),"b": new Primitive(new Material(2)),"c": new Primitive(new Material(3))};


function evaluate(input, dontToNum) {
	//console.log(input);
	
	PB["test vector"] = new Primitive(new Vector([new Material(1), new Material(2), new Material(3)],[], VectorBase));
	
	PB["test vector 2"] = new Primitive(new Vector([new Material(1.2), new Material(2.9), new Material(3)],[], VectorBase));
	
	var root = trimTree(createTree(input), PB);
	
	//console.log(root);
	var x;
	try {
		
		
		x = evaluateTree(root, varBank)
		
		if(! dontToNum){
			x = x.toNum();
		}

		
 	}catch(err){
		 if(err=="PLOT"){
			var res = {isPlot: true};
			res.data = [];
			var newBank = {};
			newBank["-parent"] = varBank;
 			for(var i = -100; i <= 100; i += 1){
				newBank["x"] = new Material(i/10);
				res.data.push([i/10, 0+evaluateTree(root, newBank).value]);
 			}
			
			return res;
 		}else{
 			throw(err);
 		}
 	}
	if(x instanceof Material){
		if(x.value.toPrecision){
			if(x.value === 0){
				x.value = "0";
			}else{
				x.value = x.value.toPrecision(21);
			}
		}
		if(x.value.substr(x.value.length-1,1)=="."){
			x.value=x.value.substring(0, x.value.length-1)
		}
		
		x.value=x.value.replace(/\.?\+\.?/g,"+");
		x.value=x.value.replace(/\.?\-\.?/g,"-");
		x.value=x.value.replace(/\.i/g,"i");
		x.value=x.value.replace(/(\d)i/g,"$1*<i>i</i>");
		x.value=x.value.replace(/\.e/g,"e");
		x.value=x.value.replace(/e\+/g,"e");
		
		if(x.value=="+inf.0"){
			x.value="Infinity";
		}else if(x.value=="-inf.0"){
			x.value="-Infinity";
		}
	}
	
	return x;
}

var TreeNode = function(text, typeName, line){
	this.origText = text;
	this.text = text.toLowerCase();
	this.typeName = typeName;
	this.line = line;
	this.children = [];
};

function convertToObject(node, parser) {
	var t = node.getToken();
	var current = new TreeNode( t.getText(), parser.getTokenNames()[t.getType()], t.line);
	//Add children
	/*console.log("--")
	console.log(t);
	console.log(current);*/
	
	if (node.getChildCount() > 0) {
		var children = node.getChildren();
		for (var i=0; i<children.length; i++) {
			current.children.push(convertToObject(children[i], parser));

			if((! current.line) && current.children[current.children.length-1].line){
				current.line = current.children[current.children.length-1].line;
			}
		}
	}

	return current;
}


var funcEvalMap = new Object();
var evaluatingLine = null;

funcEvalMap["LINES"] = function(node, scope) {
	if(node.children.length==0){
		return new Material(0);
	}
	var response;
	for(var i=0; i<node.children.length; i++){
		if(node.children[i].text=="return"){
			throw {returnVal: true, data: evaluateNode(node.children[i].children[0], scope)};
		}else{
			response =  evaluateNode(node.children[i], scope);
		}
	}
	return response;
};

funcEvalMap["NEGATE"] = function(node, scope) {
	return negate(evaluateNode(node.children[0], scope).toNum());
};
function negate(x){
	if(x instanceof Vector){
		return x.cloneApply(negate);
	}
	
	if((typeof x == 'boolean')){
		throw "MSG: Cannot convert Booleans to Numbers.";
	}
	if((x instanceof Agent)){
		throw "MSG: Cannot convert Agents to Numbers.";
	}
	
	return new Material(fn["-"](x.value), x.units);
};

funcEvalMap["AND"] = function(node, scope) {
	return funAnd(evaluateNode(node.children[0], scope).toNum(), evaluateNode(node.children[1], scope).toNum())
};

function funAnd(lhs,rhs){
	if(lhs instanceof Vector){
		return lhs.cloneCombine(rhs, funAnd, false);
	}else if(rhs instanceof Vector){
		return rhs.cloneCombine(lhs, funAnd, true);
	}
	
	return trueValue(lhs) && trueValue(rhs);
};

funcEvalMap["OR"] = function(node, scope) {
	return funOr(evaluateNode(node.children[0], scope).toNum(), evaluateNode(node.children[1], scope).toNum())
};

function funOr(lhs,rhs){
	if(lhs instanceof Vector){
		return lhs.cloneCombine(rhs, funOr, false);
	}else if(rhs instanceof Vector){
		return rhs.cloneCombine(lhs, funOr, true);
	}
	
	return trueValue(lhs) || trueValue(rhs);
};

funcEvalMap["XOR"] = function(node, scope) {
	return funXor(evaluateNode(node.children[0], scope).toNum(), evaluateNode(node.children[1], scope).toNum())
};

function funXor(lhs,rhs){
	if(lhs instanceof Vector){
		return lhs.cloneCombine(rhs, funXor, false);
	}else if(rhs instanceof Vector){
		return rhs.cloneCombine(lhs, funXor, true);
	}
	
	return (trueValue(lhs) || trueValue(rhs)) && ! (trueValue(lhs) && trueValue(rhs));
};


funcEvalMap["NOT"] = function(node, scope) {
	return fNot(evaluateNode(node.children[0], scope).toNum());
};

function fNot(x){
	if(x instanceof Vector){
		return x.cloneApply(fNot);
	}
	
	return ! trueValue(x);
};

funcEvalMap["NOTEQUALS"] = function(node, scope) {
	return neq(evaluateNode(node.children[0], scope).toNum(), evaluateNode(node.children[1], scope).toNum());
};

function neq(lhs, rhs){
	if((typeof lhs == "boolean" && !(rhs instanceof Vector)) || (typeof rhs == "boolean" && !(lhs instanceof Vector))){
		return trueValue(lhs)!=trueValue(rhs);
	}
	if(( ((lhs instanceof String) || (typeof lhs == "string")) && !(rhs instanceof Vector)) || ( ((rhs instanceof String) || (typeof rhs == "string")) && !(lhs instanceof Vector))){
		return (lhs.toLowerCase?lhs.toLowerCase():lhs) != (rhs.toLowerCase?rhs.toLowerCase():rhs);
	}
	
	
	if(lhs instanceof Vector){
		return lhs.cloneCombine(rhs, neq, false);
	}else if(rhs instanceof Vector){
		return rhs.cloneCombine(lhs, neq, true);
	}
	
	if((! (lhs instanceof Material)) || (! (rhs instanceof Material))){
		return lhs != rhs;
	}
	
	if (lhs.units !== rhs.units) {
		var scale = convertUnits(rhs.units, lhs.units);
		if (scale === 0) {
			return true;
		} else {
			rhs.value = fn["*"](rhs.value, scale);
			rhs.units = lhs.units;
		}
	}

	return ! fn["="](lhs.value, rhs.value);
};

funcEvalMap["EQUALS"] = function(node, scope) {
	return eq(evaluateNode(node.children[0], scope).toNum(), evaluateNode(node.children[1], scope).toNum());
};

function eq(lhs, rhs){
	if(((typeof lhs) == "boolean" && !(rhs instanceof Vector)) || ((typeof rhs) == "boolean" && !(lhs instanceof Vector))){
		return trueValue(lhs)==trueValue(rhs);
	}
	if(( ( (typeof lhs == "string") || (lhs instanceof String) ) && !(rhs instanceof Vector)) || (( (typeof rhs == "string") || (rhs instanceof String) ) && !(lhs instanceof Vector))){
		return (lhs.toLowerCase?lhs.toLowerCase():lhs) == (rhs.toLowerCase?rhs.toLowerCase():rhs);
	}
	
	
	if(lhs instanceof Vector){
		return lhs.cloneCombine(rhs, eq, false);
	}else if(rhs instanceof Vector){
		return rhs.cloneCombine(lhs, eq, true);
	}
	
	if((! (lhs instanceof Material)) || (! (rhs instanceof Material))){
		return lhs == rhs;
	}
	
	if (lhs.units !== rhs.units) {
		var scale = convertUnits(rhs.units, lhs.units);
		if (scale === 0) {
			return false;
		} else {
			rhs.value = fn["*"](rhs.value, scale);
			rhs.units = lhs.units;
		}
	}
	

	return fn["="](lhs.value, rhs.value);
};

function comparisonValid(lhs, rhs){
	if((lhs instanceof String) || (typeof lhs == 'string') || (rhs instanceof String) || (typeof rhs == 'string')){
		throw "MSG: Cannot use Strings in logical inequality comparisons.";
	}
	if((lhs instanceof Agent) || (rhs instanceof Agent)){
		throw "MSG: Cannot use Agents in logical inequality comparisons.";
	}
}

funcEvalMap["LT"] = function(node, scope) {
	return lessThan(evaluateNode(node.children[0], scope).toNum(), evaluateNode(node.children[1], scope).toNum());
};
function lessThan(lhs, rhs){
	
	comparisonValid(lhs, rhs);
	
	if(lhs instanceof Vector){
		return lhs.cloneCombine(rhs, lessThan, false);
	}else if(rhs instanceof Vector){
		return rhs.cloneCombine(lhs, lessThan, true);
	}
	
	if (lhs.units !== rhs.units) {
		var scale = convertUnits(rhs.units, lhs.units);
		if (scale === 0) {
			unitAlert(lhs.units, rhs.units, "comparison");
		} else {
			rhs.value = fn["*"](rhs.value, scale);
			rhs.units = lhs.units;
		}
	}


	return fn["<"](lhs.value, rhs.value);;
};

funcEvalMap["LTEQ"] = function(node, scope) {
	return lessThanEq(evaluateNode(node.children[0], scope).toNum(), evaluateNode(node.children[1], scope).toNum());
};
function lessThanEq(lhs, rhs){
	
	comparisonValid(lhs, rhs);
	
	if(lhs instanceof Vector){
		return lhs.cloneCombine(rhs, lessThanEq, false);
	}else if(rhs instanceof Vector){
		return rhs.cloneCombine(lhs, lessThanEq, true);
	}
	
	if (lhs.units !== rhs.units) {
		var scale = convertUnits(rhs.units, lhs.units);
		if (scale === 0) {
			unitAlert(lhs.units, rhs.units, "comparison");
		} else {
			rhs.value = fn["*"](rhs.value, scale);
			rhs.units = lhs.units;
		}
	}
	

	return fn["<="](lhs.value, rhs.value);
};

funcEvalMap["GT"] = function(node, scope) {
	return greaterThan(evaluateNode(node.children[0], scope).toNum(), evaluateNode(node.children[1], scope).toNum());
};

function greaterThan(lhs, rhs){
	
	comparisonValid(lhs, rhs);
	
	if(lhs instanceof Vector){
		return lhs.cloneCombine(rhs, greaterThan, false);
	}else if(rhs instanceof Vector){
		return rhs.cloneCombine(lhs, greaterThan, true);
	}
	
	if (lhs.units !== rhs.units) {
		var scale = convertUnits(rhs.units, lhs.units);
		if (scale === 0) {
			unitAlert(lhs.units, rhs.units, "comparison");
		} else {
			rhs.value = fn["*"](rhs.value, scale);
			rhs.units = lhs.units;
		}
	}
	

	return fn[">"](lhs.value, rhs.value);
};

funcEvalMap["GTEQ"] = function(node, scope) {
	return greaterThanEq(evaluateNode(node.children[0], scope).toNum(), evaluateNode(node.children[1], scope).toNum());
};

function greaterThanEq(lhs, rhs){
	
	comparisonValid(lhs, rhs);
	
	
	if(lhs instanceof Vector){
		return lhs.cloneCombine(rhs, greaterThanEq, false);
	}else if(rhs instanceof Vector){
		return rhs.cloneCombine(lhs, greaterThanEq, true);
	}
	
	
	if (lhs.units !== rhs.units) {
		var scale = convertUnits(rhs.units, lhs.units);
		if (scale === 0) {
			unitAlert(lhs.units, rhs.units, "comparison");
		} else {
			rhs.value = fn["*"](rhs.value, scale);
			rhs.units = lhs.units;
		}
	}
	

	return fn[">="](lhs.value, rhs.value);
};

funcEvalMap["PLUS"] = function(node, scope) {
	return plus(evaluateNode(node.children[0], scope).toNum(), evaluateNode(node.children[1], scope).toNum());
};

function plus(lhs, rhs){
	if(lhs instanceof Vector){
		return lhs.cloneCombine(rhs, plus, false);
	}else if(rhs instanceof Vector){
		return rhs.cloneCombine(lhs, plus, true);
	}
	
	if((typeof lhs == 'boolean') || (typeof rhs == 'boolean')){
		throw "MSG: Cannot convert Booleans to Numbers.";
	}
	if((lhs instanceof Agent) || (rhs instanceof Agent)){
		throw "MSG: Cannot convert Agents to Numbers.";
	}
	if(((typeof lhs == 'string') || (lhs instanceof String)) || ((typeof rhs == 'string') || (rhs instanceof String)) ){
		var s = new String(lhs.toString()+rhs.toString());
		s.parent = StringBase;
		return s;
	}
	
	if (lhs.units !== rhs.units) {
		var scale = convertUnits(rhs.units, lhs.units);
		if (scale === 0) {
			unitAlert(lhs.units, rhs.units, "addition");
		} else {
			rhs.value = fn["*"](rhs.value, scale);
			rhs.units = lhs.units;
		}
	}
	
	return new Material(fn["+"](lhs.value, rhs.value), rhs.units);

};

funcEvalMap["MINUS"] = function(node, scope) {
	return minus(evaluateNode(node.children[0], scope).toNum(), evaluateNode(node.children[1], scope).toNum());
};

function minus(lhs, rhs){

	if(lhs instanceof Vector){
		return lhs.cloneCombine(rhs, minus, false);
	}else if(rhs instanceof Vector){
		return rhs.cloneCombine(lhs, minus, true);
	}
	
	if((typeof lhs == 'boolean') || (typeof rhs == 'boolean')){
		throw "MSG: Cannot convert Booleans to Numbers.";
	}
	if((lhs instanceof Agent) || (rhs instanceof Agent)){
		throw "MSG: Cannot convert Agents to Numbers.";
	}
	
	if (lhs.units !== rhs.units) {
		var scale = convertUnits(rhs.units, lhs.units);
		if (scale === 0) {
			unitAlert(lhs.units, rhs.units, "subtraction");
		} else {
			rhs.value = fn["*"](rhs.value, scale);
			rhs.units = lhs.units;
		}
	}
	
	

	return new Material(fn["-"](lhs.value, rhs.value), rhs.units);
};

funcEvalMap["MULT"] = function(node, scope) {
	return mult(evaluateNode(node.children[0], scope).toNum(), evaluateNode(node.children[1], scope).toNum());
};

function mult(lhs, rhs){
	if(lhs instanceof Vector){
		return lhs.cloneCombine(rhs, mult, false);
	}else if(rhs instanceof Vector){
		return rhs.cloneCombine(lhs, mult, true);
	}
	
	if((typeof lhs == 'boolean') || (typeof rhs == 'boolean')){
		throw "MSG: Cannot convert Booleans to Numbers.";
	}
	if((lhs instanceof Agent) || (rhs instanceof Agent)){
		throw "MSG: Cannot convert Agents to Numbers.";
	}
	
	var x = fn["*"](lhs.value, rhs.value);
	if(lhs.units && rhs.units){
		lhs.units.addBase(); rhs.units.addBase();
		return new Material(fn["*"](fn["*"](lhs.units.toBase, x), rhs.units.toBase), lhs.units.multiply(rhs.units, 1));
	}else if(lhs.units){
		return new Material(x, lhs.units);
	}else if(rhs.units){
		return new Material(x, rhs.units);
	}
	
	return new Material(x);
};

funcEvalMap["DIV"] = function(node, scope) {
	return div(evaluateNode(node.children[0], scope).toNum(), evaluateNode(node.children[1], scope).toNum());
};

function div(lhs, rhs){
	if(lhs instanceof Vector){
		return lhs.cloneCombine(rhs, div, false);
	}else if(rhs instanceof Vector){
		return rhs.cloneCombine(lhs, div, true);
	}
	
	if((typeof lhs == 'boolean') || (typeof rhs == 'boolean')){
		throw "MSG: Cannot convert Booleans to Numbers.";
	}
	if((lhs instanceof Agent) || (rhs instanceof Agent)){
		throw "MSG: Cannot convert Agents to Numbers.";
	}
	
	var x = fn["/"](lhs.value, rhs.value);
	if(lhs.units && rhs.units){
		lhs.units.addBase(); rhs.units.addBase();
		return new Material(fn["/"](fn["*"](lhs.units.toBase, x), rhs.units.toBase), lhs.units.multiply(rhs.units, -1));
	}else if(lhs.units){
		return new Material(x, lhs.units);
	}else if(rhs.units){
		return new Material(x, rhs.units.power(-1));
	}
	
	return new Material(x);
	
};


funcEvalMap["POWER"] = function(node, scope) {
	if(node.children.length == 1){
		return evaluateNode(node.children[0], scope);
	}

	var rhs = evaluateNode(node.children[node.children.length - 1], scope).toNum();
	
	for(var j = node.children.length - 1; j > 0; j--){
		
		var lhs = evaluateNode(node.children[j - 1], scope).toNum();
		if ((rhs instanceof Vector) || ! rhs.units) {
			rhs = power(lhs, rhs);
		} else {
			throw "MSG: Exponents may not have units.";
		}
	}
	return rhs;
};

function power(lhs, rhs){
	if(lhs instanceof Vector){
		return lhs.cloneCombine(rhs, power, false);
	}else if(rhs instanceof Vector){
		return rhs.cloneCombine(lhs, power, true);
	}
	
	if((typeof lhs == 'boolean') || (typeof rhs == 'boolean')){
		throw "MSG: Cannot convert Booleans to Numbers.";
	}
	if((lhs instanceof Agent) || (rhs instanceof Agent)){
		throw "MSG: Cannot convert Agents to Numbers.";
	}
	
	var x = lhs.value;
	if(typeof x == "number"){
		x = sn("#e"+x)
	}
	return new Material(fn.expt(x, rhs.value), lhs.units?lhs.units.power(rhs.value):undefined);
};

funcEvalMap["MOD"] = function(node, scope) {
	return doMod(evaluateNode(node.children[0], scope).toNum(), evaluateNode(node.children[1], scope).toNum());
};

function doMod(lhs, rhs){
	if(lhs instanceof Vector){
		return lhs.cloneCombine(rhs, doMod, false);
	}else if(rhs instanceof Vector){
		return rhs.cloneCombine(lhs, doMod, true);
	}
	
	if((typeof lhs == 'boolean') || (typeof rhs == 'boolean')){
		throw "MSG: Cannot convert Booleans to Numbers.";
	}
	if((lhs instanceof Agent) || (rhs instanceof Agent)){
		throw "MSG: Cannot convert Agents to Numbers.";
	}
	
	if (! rhs.units) {
		return new Material(fn.mod(lhs.value, rhs.value), lhs.units);
	} else {
		throw "MSG: The right hand side of \"mod\" may not have units."
	}
};


funcEvalMap["IDENT"] = function(node, scope) {
	var varName = node.text;
	
	while ( !(varName in scope) ) {
		if ( scope["-parent"] ) {
			scope = scope["-parent"];
		} else {
			if(varName == "x" && window.isCalc){
				throw "PLOT" ;
			}else if(varName=="i"){//imaginary number
				return new Material(sn("i"));
			}else{
				throw "MSG: The variable or function \"" + node.origText + "\" does not exist.";
			}
		}
	}
	
	var v = scope[varName];
	
	if((v instanceof TreeNode) && v.typeName == "ARRAY"){
		v = evaluateNode(v, scope);
	}
	if(v.fullClone && !(v instanceof Vector)){
		return v.fullClone();
	}else{
		return v;
	}
};

funcEvalMap["NEW"] = function(node, scope) {
	
	var base = evaluateNode(node.children[0], scope);
	if(base instanceof Vector){
		var n = new Vector([],undefined, base);
		var constructor;
		var r;
		try{
			r = selectFromVector(base, "constructor");
			constructor = r.data;
		}catch(err){}
		
		if(! constructor){
			if(node.children.length==2 && node.children[1].children.length>0){
				throw "MSG: No constructor available for '"+node.children[0].text+"'.";
			}
		}else{
			if(node.children.length==2){
				callFunction(constructor, node.children[1], scope, n, r.parent);
			}else{
				callFunction(constructor, {children:[]}, scope, n, r.parent);
			}
		}
		return n;
	}else{
		throw "MSG: 'New' can only be use to create instances of Vectors.";
	}
}

funcEvalMap["INNER"] = function(node, scope) {
	
	var base = evaluateNode(node.children[0], scope);
	
	if(node.children.length==2 & node.children[1].typeName=="FUNCALL"){
		return callFunction(base, node.children[1], scope);
	}

	var lastSelf; // for "self" binding
	var lastBase; // for "self" binding

	if(scope.self && node.children[0].text=="parent"){
		lastSelf = scope.self;
	}else if(!((base instanceof Function) || (base instanceof UserFunction))){
		lastSelf = base;
	}
	
	for(var i=1; i< node.children.length; i++){
		//console.log(node.children[i].typeName)
		
		
		if(node.children[i].typeName == "SELECTOR" ){
			if(node.children[i].children[0].typeName == "DOTSELECTOR"){
				
				for(var j=0; j<node.children[i].children[0].children.length; j++){
					var res = [];
					if(node.children[i].children[0].children[j].text){
						res.push(node.children[i].children[0].children[j].text);
					}else{
						res.push(node.children[i].children[0].children[j].valueOf());
					}
					try{
						base = selectFromMatrix(base, res);
					}catch(err){
						if(base instanceof Primitive && !(base instanceof Agent)){
							base = base.toNum();
							j--;
						}else{
							throw(err);
						}
					}
					
					if(!((base instanceof Function) || (base instanceof UserFunction))){
						lastSelf = base;
						lastBase = base;
					}
				}
				
			}else{
			
				if(base instanceof Primitive){
					base = base.toNum();
			
					if(!((base instanceof Function) || (base instanceof UserFunction))){
						lastSelf = base;
						lastBase = base;
					}
				}
		
		
				try{
					base = selectFromMatrix(base, createMatrixSelector(node.children[i], scope, 0, true));
				}catch(err){
					if(base instanceof Primitive ){
						base = base.toNum();
						i--;
					}else{
						throw(err);
					}
				}
				
				if(!((base instanceof Function) || (base instanceof UserFunction))){
					lastSelf = base;
					lastBase = base;
				}
			}
			
			
		}else{//"FUNCALL"
			base = callFunction(base, node.children[i], scope, lastSelf, lastBase);
			
			if(!((base instanceof Function) || (base instanceof UserFunction))){
				lastSelf = base;
				lastBase = base;
			}
		}
	}
	return base;
};

function callFunction(base, node, scope, lastSelf, lastBase){
	if((typeof base != "function") && ! (base instanceof UserFunction)){
		//if(isLocal()){
		//	console.log(base);
		//}
		throw "MSG: Trying to call a non-function.";
	}
	
	var vals = [];
	var fingerprint = "";
	if(node instanceof Array){
		vals = node;
	}else{
		if(! node.functionFingerprint){
			node.functionFingerprint = "FINGERPRINT-" + Math.random();
		}
		fingerprint = node.functionFingerprint;

		if(base.delayEvalParams){
			//don't evaluate params right away. needed for IfThenElse and short circuiting
			for (var j = 0; j < node.children.length; j++){
				vals.push({node: node.children[j], scope: scope});
			}
		}else{
			for (var j = 0; j < node.children.length; j++){
				var item = evaluateNode(node.children[j], scope);
				if(item.fullClone && ! (item instanceof Vector)){
					item = item.fullClone();
				}
				vals.push(item);
			}
		}
	}
	
	var fn;
	if (base.fn) {
		 fn = base.fn; // user defined function
	} else {
		node.delayEvalParams = base.delayEvalParams;
		fn = base; //built-in
	}
	
	var oldLine = evaluatingLine;
	
	var x = fn(vals, fingerprint, lastSelf, lastBase);
	
	evaluatingLine = oldLine;
	
	return x;
	
}

function createMatrixSelector(node, scope, offset, createFunctions){
	var selector = [];
	offset = offset || 0;
	for(var i=offset; i<node.children.length; i++){
		var child = node.children[i];
		if(child.typeName=="MULT"){
			selector.push("*");
		}else{
			var x = evaluateNode(node.children[i], scope);
			if((typeof x == "function") || (x instanceof UserFunction)){
				if(typeof x == "function"){
					var fn = x;
				}else{
					var fn = x.fn;
				}
				(function(f){
				selector.push(function(x){
					if(! x[0].stackApply){
						throw "MSG: Can't apply function across elements of non-vector."
					}
					
					return x[0].stackApply(function(x){
						return f([x]);	
					});
				})
				})(fn);
			}else{
				selector.push(x.toNum());
			}
		}
	}
	return selector
}

function selectFromMatrix(mat, items, fill){
	//console.log("--")
	//console.log(items)

	var m = mat;
	if(! (m instanceof Vector)){
		if(m.vector){
			m = m.vector;
		}else if(m.parent){
			m = new Vector([],[], m.parent);
		}
	}
	if(isUndefined(fill) && m.fullClone){
		m = m.fullClone();
	}
	//console.log("--")
	
	var root = selectFromVector(m, items.shift(), items.length==0?fill:undefined, isDefined(fill))
	var children = [];
	if(root.collapsed){
	 	children = [root.data];
	}else{
		children = root.data.items;
	}
	
	while(items.length > 0){
		//console.log("iteration");
		//console.log(children);
		var newChildren = [];
		var selector = items.shift();
		//console.log(selector)
		for(var i = 0; i < children.length; i++){
			//console.log("child")
			//console.log(children[i])
			if(! (children[i] instanceof Vector)){
			//	if(children[i].parent instanceof Vector){
			//		children[i] = children[i].parent.fullClone();
			//	}else if(children[i].vector instanceof Vector){
			//		children[i] = children[i].vector.fullClone();
			//	}else{
					throw "MSG: No element available for: "+selector;
			//	}
			}
			//console.log(children[i])
			var vec = selectFromVector(children[i], selector, items.length==0?fill:undefined);
			//console.log(vec);
			
			if(vec.collapsed){

				if(! fill){
					children[i].items = [vec.data];
					children[i].names = ["!!BREAKOUT DATA"]; 
				}
			
				newChildren=newChildren.concat(vec.data)
			}else{
				newChildren=newChildren.concat(vec.data.items)

				if(! fill){
					children[i].items = vec.data.items;
					children[i].names = vec.data.names;
				}
			}
		}
		children = newChildren;
	}
	
	//console.log("done:")
	//console.log(root.data)
	//console.log(root);
	return doBreakouts(root.data);
}

function doBreakouts(vec){
	if(! (vec instanceof Vector)){
		return vec;
	}
	if(vec.items.length==1 && vec.names && vec.names[0]=="!!BREAKOUT DATA"){
		return doBreakouts(vec.items[0]);
	}
	for(var i=0; i < vec.items.length; i++){
		vec.items[i] = doBreakouts(vec.items[i])
	}
	return vec;
}

function selectFromVector(vec, items, fill, doNotClone){
	
	

	if(items=="*"){
		return {data: vec};
	}else if(typeof items == "function"){
		return {data: items([vec]), collapsed: true};
	}else if(items=="parent"){
		if(vec.parent){
			return {data: doNotClone?vec.parent:vec.parent.fullClone(), collapsed:true};
		}else{
			throw "MSG: Vector does not have a parent.";
		}
	}

	if(items instanceof Vector){
		var res = [];
		var names = vec.names?[]:undefined;
		for(var i=0; i < items.items.length; i++){
			var v = items.items[i];
			var shouldSelect = true;
			if(typeof v == "boolean"){
				if(v){
					v = new Material(i+1);
				}else{
					shouldSelect = false;
				}
			}
			if(shouldSelect){
				var r = selectElementFromVector(vec, v, fill)
				res.push(r.value);
				if(names){
					names.push(r.name);
				}
			}
		}
		return {collapsed: false, parent: vec, data: new Vector(res, names, vec.parent)};
	}else{
		return {collapsed: true, parent: vec, data: selectElementFromVector(vec, items, fill).value};
	}
}


function selectElementFromVector(vec, item, fill){
	
	/*if(! (vec instanceof Vector)){
		if(vec.vector){
			vec = vec.vector;
		}else if(vec.parent){
			vec = vec.parent;
		}else{
			throw "MSG: Upping failed."
		}
	}*/
		
	
	var name = undefined;
	var value = undefined;
	
	var index;

	
	if( (item instanceof String) || (typeof item == "string")){
		try{
			if(isUndefined(fill)){
				if(!vec.names){
					throw "MSG: Key '"+item+"' not in vector."
				}
			}
			if(vec.names){
				index = -1;
				var lc = item.toLowerCase();
				for(var i=0; i<vec.names.length; i++){
					if(vec.names[i] && vec.names[i].toLowerCase() === lc){
						index = i;
						break;
					}
				}
				if(index<0 || isUndefined(index)){
					index = vec.names.indexOf("*");
				}
			}
			if(index < 0 || isUndefined(index)){
				if(isUndefined(fill)){
					throw "MSG: Key '"+item+"' not in vector.";
				}else{
					index = item;
				}
		
			}
		}catch(err){
			if(vec.parent){
				return selectElementFromVector(vec.parent, item, fill);
			}else{
				throw err;
			}
		}
	
	}else{
		index = parseFloat(item.toNum())-1;
	}
	
	if((index instanceof String) || (typeof index == "string")){
		if(! vec.names){
			vec.names = [];
			for(var i=0; i<vec.items.length; i++){
				vec.names.push(undefined);
			}
		}
		vec.items.push(fill);
		vec.names.push(index.valueOf());
		value = fill;
		name = index;
		
	}else{
		if(index < 0 || (!vec.items) || index >= vec.items.length || index % 1 != 0 ){
			throw "MSG: Index "+(1+index)+" is not in the vector.";
		}
		if(!isUndefined(fill)){
			vec.items[index] = fill;
		}
		value = vec.items[index];
		if(vec.names){
			name = vec.names[index];
		}
	}

	return {name: name, value: value};
}



funcEvalMap["ARRAY"] = function(node, scope) {
	
	if(node.children.length == 1 && node.children[0] instanceof Vector){
		return node.children[0].fullClone(); // pre calculated vector
	}
	
	var vals = [];
	var names = [];
	var hasName = false;
	for (var i = 0; i < node.children.length; i++){
		vals.push(evaluateNode(node.children[i].children[0], scope));
		if(node.children[i].children.length>1){
			if(node.children[i].children[1].text){
				names.push(node.children[i].children[1].origText);
			}else{
				names.push(node.children[i].children[1].valueOf());
			}
			hasName = true;
		}else{
			names.push(undefined);
		}
	}
	return new Vector(vals, hasName?names:undefined);
};

funcEvalMap["RANGE"] = function(node, scope) {
	if(node.children.length==1){
		return evaluateNode(node.children[0], scope);
	}
	var vals = [];
	var start = evaluateNode(node.children[0], scope).toNum();
	var end = evaluateNode(node.children[node.children.length-1], scope).toNum();

	if((! (start instanceof Material)) || (! (end instanceof Material))){
		throw "MSG: Range elements must be numbers.";
	}
	
	vals.push(start.fullClone());
	if (start.units !== end.units) {
		var scale = convertUnits(start.units, end.units);
		if (scale != 1) {
			//console.log(scale)
			throw "MSG: Units on both sides of ':' must be equal."
		}
	}
	//throw "modsa";
	var step = node.children.length==2?new Material(1, start.units):evaluateNode(node.children[1], scope).toNum();
	
	if(! (step instanceof Material)){
		throw "MSG: Range elements must be numbers.";
	}
	
	if(eq(start,end)){
		
	}else if(lessThan(start, end)){
		var it = plus(start, step);
		while(lessThanEq(it, end)){
			vals.push(it);
			it = plus(it, step);
		}
	}else if(greaterThan(start, end)){
		if(node.children.length==2){
			step = negate(step);
		}
		var it = plus(start, step);
		while(greaterThanEq(it, end)){
			vals.push(it);
			it = plus(it, step);
		}
	}
	//console.log(vals)
	
	return new Vector(vals);
};

function makeFunctionCall(varName, varNames, varDefaults, node, scope) {

	var fn = new UserFunction();

	fn.localScope = new Object();
	fn.localScope["nVars"] = varNames.length;
	for (var i = 0; i < varNames.length; i++) {
		fn.localScope[i += ""] = varNames[i];
	}
	fn.localScope["-parent"] = scope;
	fn.defaults = varDefaults;
	
	fn.fn = function(x, fingerPrint, lastSelf, lastBase) {
		var minLength = x.length;
		for(var i=0;i<x.length; i++){
			if(x[i].optional){
				minLength--;
			}
		}
		if (fn.localScope["nVars"] - fn.defaults.length > x.length || minLength > fn.localScope["nVars"]) {
			var names = [];
			for (var i = 0; i < fn.localScope["nVars"]; i++) {
				if(fn.defaults.length - (fn.localScope["nVars"]-i)>-1){
					names.push(fn.localScope[i += ""] + "=" + fn.defaults[fn.defaults.length - (fn.localScope["nVars"]-i)]);
				}else{
					names.push(fn.localScope[i += ""]);
				}
			}
			
			throw "MSG: Wrong number of parameters for " + varName + "("+names.join(", ")+").";
		}
		var localScope = {"-parent": scope};
		
		//console.log(fn.localScope);
		for (var i = 0; i < x.length; i++) {
			localScope[fn.localScope[i += ""]] = x[i];
		}
		for (var i = x.length; i < fn.localScope["nVars"]; i++) {
			//console.log(fn.defaults[fn.defaults.length - (fn.localScope["nVars"]-i)]);
			localScope[fn.localScope[i += ""]] = fn.defaults[fn.defaults.length - (fn.localScope["nVars"]-i)];
			//if(localScope[fn.localScope[i += ""]].fullClone){
			//	localScope[fn.localScope[i += ""]] = localScope[fn.localScope[i += ""]].fullClone();
			//}
		}
		
		
		if(lastSelf){
			if(! localScope.self){
				localScope["self"] = lastSelf;
			}
			//if(! localScope.parent){
		}
		if(lastBase){	
			if(lastBase.parent){
				localScope["parent"] = lastBase.parent;
			}
				//}
		}

		try{
			//console.log(localScope)
			return evaluateNode(node, localScope);
		}catch(err){
			if(err.returnVal){
				return err.data;
			}else{
				throw(err);
			}
		}
	};

	return fn;
};

funcEvalMap["THROW"] = function(node, scope) {
	throw "MSG: "+evaluateNode(node.children[0], scope);
};

funcEvalMap["TRYCATCH"] = function(node, scope) {
	try{
		return evaluateNode(node.children[0], scope);
	}catch(err){
		var localScope = {"-parent": scope};
		if((typeof err == "string") || err instanceof String){
			localScope[node.children[2].text] = s(err.substr(5));
		}else{
			localScope[node.children[2].text] = s("An error has occurred.");
		}
		return evaluateNode(node.children[1], localScope)
	}
};

funcEvalMap["WHILE"] = function(node, scope) {
	var lastResult = new Material(0);
	var innerScope = {"-parent": scope};
	while(trueValue(evaluateNode(node.children[0], scope).toNum())){
		lastResult = evaluateNode(node.children[1], innerScope);
	}
	return lastResult;
};

funcEvalMap["IFTHENELSE"] = function(node, scope) {
	//console.log(node);
	var innerScope = {"-parent": scope};
	for(var i=0; i<node.children[0].children.length; i++){
		if(trueValue(evaluateNode(node.children[0].children[i], scope).toNum())){
			return evaluateNode(node.children[1].children[i], innerScope);
		}
	}
	if(node.children[0].children.length != node.children[1].children.length){
		return evaluateNode(node.children[1].children[i], innerScope);
	}
	
	return new Material(0);
};

funcEvalMap["FORIN"] = function(node, scope) {
	var lastResult = new Material(0);
	var id = node.children[0].text;
	
	var innerScope = {"-parent": scope};
	var vec = evaluateNode(node.children[1], scope);
	if(! (vec instanceof Vector)){
		throw "MSG: The in argument of a For-In loop mush be a a vector."
	}
	for(var i=0; i<vec.items.length; i++){
		innerScope[id] = vec.items[i];
		lastResult = evaluateNode(node.children[2], innerScope);
	}
	return lastResult;
};

funcEvalMap["FOR"] = function(node, scope) {
	var lastResult = new Material(0);
	var id = node.children[0].text;
	var start = evaluateNode(node.children[1].children[0], scope).toNum();
	var by = new Material(1);
	
	if(node.children[1].children.length==3){
		by = evaluateNode(node.children[1].children[2], scope).toNum();
	}
	var innerScope = {"-parent": scope};

	innerScope[id] = start;
	while(fn[by.value>=0?"<=":">="](innerScope[id].value, evaluateNode(node.children[1].children[1], scope).toNum())){
		lastResult = evaluateNode(node.children[2], innerScope);
		innerScope[id] = plus(innerScope[id], by);
	}
	return lastResult;
}

funcEvalMap["FUNCTION"] = function(node, scope) {
	var id = node.children[0].children[0].text;
	
	functionGenerator(id, node.children[0], node.children[1], node.children[2], scope)
			
	return '"' + id + "\" defined"; 
};

funcEvalMap["ANONFUNCTION"] = function(node, scope) {
	return functionGenerator(null, node.children[0], node.children[1], node.children[2], scope); 
};

funcEvalMap["ASSIGN"] = function(node, scope) {
	//console.log(node);
	var items = node.children.length-1;
	var x = evaluateNode(node.children[node.children.length-1], scope);
	if(items>1 && (!(x instanceof Vector) || x.items.length<items)){
		throw "MSG: Too few elements returned for assignment.";
	}
	for(var i=0; i<items; i++){
		if(node.children[i] instanceof PrimitiveStore){
			if(items==1){
				node.children[i].primitive.setValue(x);
			}else{
				node.children[i].primitive.setValue(x.items[i]);
			}
		}else{
			//console.log(node);
			var varName = node.children[i].children[0].text;
			if(node.children[i].children.length > 1){
				var selector = createSelector(node.children[i].children[1], scope);
			}
			//console.log(selector);
			
			var origScope = scope;
			while(scope["-parent"] !== null){
				if(isDefined(scope[varName])){
					break;
				}
				scope = scope["-parent"];
			}
			if(scope["-parent"]===null && isUndefined(scope[varName])){
				scope = origScope;
			}
			
			var v;
			if(items == 1){
				v = x;
			}else{
				v = x.items[i];
			}
			if(node.children[i].children.length == 1){
				scope[varName] = v;
			}else{
				if(isDefined(scope[varName])){
					//if( scope[varName] instanceof Vector){
					selectFromMatrix(scope[varName], selector, v);
					//}else{
					//throw "MSG: The variable '"+node.children[i].children[0].origText+"' is not a vector.";
					//}
				}else{
					throw "MSG: The variable '"+node.children[i].children[0].origText+"' does not exist.";
				}
			}
		}
	}
	if(items>1){
		return new Vector(x.items.slice(0,items));
	}else{
		return x;
	}
};

function createSelector(node, scope){
	if(node.children[0].typeName == "DOTSELECTOR"){
		var res = [];
		for(var i=0; i<node.children[0].children.length; i++){
			if(node.children[0].children[i].text){
				res.push(node.children[0].children[i].text);
			}else{
				res.push(node.children[0].children[i].valueOf());
			}
		}
		return res;
	}else{
		return createMatrixSelector(node, scope, 0, true)
	}
}

funcEvalMap["MATERIAL"] = function(node, scope) {
	var v =evaluateNode(node.children[0], scope).toNum();
	if(v.units){
		throw "MSG: Cannot create material where numeric part itself has units."
	}
	return new Material(v.value, node.children[1]);
};

function functionGenerator(varName, paramNames, paramDefaults, code, scope){
	var varNames = [];
	var varDefaults = [];
	for (var i = ((varName===null)?0:1); i < paramNames.children.length ; i++) {
		varNames.push(paramNames.children[i].text);
	}
		
	for (var i = 0; i < paramDefaults.children.length ; i++) {
		varDefaults.push(paramDefaults.children[i]);
	}
	if(varName===null){
		return makeFunctionCall(varName===null?"Function":varName, varNames, varDefaults, code, scope);
	}else{
		scope[varName] = makeFunctionCall(varName, varNames, varDefaults, code, scope);
	}
}

var unitEvalMap = new Object();
unitEvalMap["MULT"] = function(node) {
	return evaluateUnits(node.children[0]).concat(evaluateUnits(node.children[1]));
};
unitEvalMap["POW"] = function(node) {
	var rhsMult = 1;
	var rhsLoc = 1;
	var lhsLoc = 0;
	
	if(node.children.length == 3 + lhsLoc){
		rhsMult = rhsMult*-1;
	 	rhsLoc++;
	}
	var lhs = evaluateUnits(node.children[lhsLoc]);
	var rhs = evaluateUnits(node.children[rhsLoc]) * rhsMult;
	
	if (lhs instanceof Array) {
		for (var i = 0; i < lhs.length; i++) {
			lhs[i].exponent = lhs[i].exponent * rhs;
		}
		return lhs;
	} else {
		return Math.pow(lhs, rhs);
	}
};
unitEvalMap["DIV"] = function(node) {
	var lhs = evaluateUnits(node.children[0]);
	var rhs = evaluateUnits(node.children[1]);
	for (var i = 0; i < rhs.length; i++) {
		rhs[i].exponent = rhs[i].exponent * -1;
	}
	return lhs.concat(rhs);
};
unitEvalMap["PER"] = unitEvalMap["DIV"];

unitEvalMap["UNIT"] = function(node) {
	var unitName = "";
	for (var i = 0; i < node.children.length; i++) {
		unitName = unitName + node.children[i].text;
		if (i < node.children.length - 1) {
			unitName = unitName + " ";
		}
	}
	return [{
		id: unitName,
		exponent: 1
	}];
};
unitEvalMap["UNITCLUMP"] = function(node) {
	var x = evaluateUnits(node.children[0]);
	if(node.children.length>1){
		for(var i=1; i<node.children.length; i++){
			if(node.children[i].typeName == "NEGATE"){
				for (var j = 0; j < x.length; j++) {
			 		x[j].exponent = x[j].exponent * -1;
			 	}
		 	}else if(node.children[i].typeName == "SQUARED"){
				for (var j = 0; j < x.length; j++) {
			 		x[j].exponent = x[j].exponent * 2;
			 	}
			}else if(node.children[i].typeName == "CUBED"){
				for (var j = 0; j < x.length; j++) {
			 		x[j].exponent = x[j].exponent * 3;
			 	}
			}
		}
	}
	return x;
};
unitEvalMap["INTEGER"] = function(node) {
	return parseInt(node.text);
};
unitEvalMap["FLOAT"] = function(node) {
	return parseFloat(node.text);
};

function evaluateUnits(node) {
	if(node instanceof Material){
		return node.value;
	}
	//console.log( node.typeName);
	
	//console.log(node);
	return unitEvalMap[node.typeName](node);
}

function evaluateNode(node, scope) {
	if(node instanceof TreeNode){
		evaluatingLine = node.line || evaluatingLine;
		
		return funcEvalMap[node.typeName](node, scope);
	}else if(node instanceof PrimitiveStore){
		if(node.type == "totalValue"){
			if(! node.primitive.totalContents){
				throw "MSG: You can only use the double-bracket notation for total conveyor contents on Stock primitives.";
			}
			return node.primitive.totalContents();
		}else if(node.type == "object"){
			return node.primitive;
		}
	}else{
		return node;
	}
}

var trimEvalMap = new Object();


trimEvalMap["POWER"] = function(node, primitives) {
	if(node.children.length == 1){
		return trimNode(node.children[0], primitives);
	}else{
		var n = new TreeNode(node.origText, node.typeName, node.line);
		for(var i = 0; i < node.children.length; i++){
			n.children.push(trimNode(node.children[i], primitives));
		}
		return n;
	}
};
trimEvalMap["INNER"] = function(node, primitives) {
	if(node.children.length == 1){
		return trimNode(node.children[0], primitives);
	}else{
		var n = new TreeNode(node.origText, node.typeName, node.line);
		for(var i = 0; i < node.children.length; i++){
			n.children.push(trimNode(node.children[i], primitives));
		}
		return n;
	}
};;
trimEvalMap["RANGE"] = trimEvalMap["POWER"];
trimEvalMap["TRUE"] = function(node) {
	return true;
};
trimEvalMap["FALSE"] = function(node) {
	return false;
};
trimEvalMap["STRING"] = function(node) {
	//console.log(node.origText);
	var sub = node.origText.substr(1, node.origText.length-2);
	var s;
	if(node.origText[0]=="\""){
		s = sub.replace(/\\\\/g,"\\\\TEMPTXT\\\\").replace(/\\"/g,"\"").replace(/\\'/g,"\'").replace(/\\t/g,"\t").replace(/\\b/g,"\b").replace(/\\f/g,"\f").replace(/\\n/g,"\n").replace(/\\r/g,"\r").replace(/\\\\TEMPTXT\\\\/g, "\\");
	}else{
		s = sub.replace(/\n/,"\\n");
	}
	s = new String(s);
	s.vector = new Vector([],[],StringBase);
	return s;
};
trimEvalMap["INTEGER"] = function(node) {
	return new Material(sn("#e"+node.text));
};
trimEvalMap["MATERIAL"] = function(node, scope) {
	var units = node.children[0];
	var x = trimNode(node.children[1], scope);
	var units = evaluateUnits(units);
	var exponents = [], names = [];
	for(var i=0; i < units.length; i++){
		var j = names.indexOf(units[i].id);
		if(j == -1){
			exponents.push(units[i].exponent);
			names.push(units[i].id);
		}else{
			exponents[j] = exponents[j]+units[i].exponent;
		}
	}
	if(x instanceof Material){
		if(x.units){
			throw "MSG: Cannot create material where numeric part itself has units."
		}
		return new Material(x.value, getUnitStore(names, exponents, true));
	}else{
		var m = new TreeNode(node.origText, "MATERIAL", node.line);
		m.children = [x, getUnitStore(names, exponents, true)]
		return m;
	}
};
trimEvalMap["MULT"] = function(node, scope) {

	if(node.children.length==0){
		return "*";
	}
	
	var lhs = trimNode(node.children[0], scope);
	var rhs = trimNode(node.children[1], scope);
	if(isConst(lhs) && isConst(rhs)){
		return mult(lhs, rhs);
	}else{
		var n = new TreeNode(node.origText, node.typeName, node.line);
		n.children = [lhs, rhs]
		return n;
	}
};

trimEvalMap["DIV"] = function(node, scope) {
	var lhs = trimNode(node.children[0], scope);
	var rhs = trimNode(node.children[1], scope);
	if(isConst(lhs) && isConst(rhs)){
		return div(lhs, rhs);
	}else{
		var n = new TreeNode(node.origText, node.typeName, node.line);
		n.children = [lhs,rhs]
		return n;
	}
};
trimEvalMap["PLUS"] = function(node, scope) {
	var lhs = trimNode(node.children[0], scope);
	var rhs = trimNode(node.children[1], scope);
	if(isConst(lhs) && isConst(rhs)){
		return plus(lhs, rhs);
	}else{
		var n = new TreeNode(node.origText,  node.typeName, node.line);
		n.children = [lhs,rhs]
		return n;
	}
};
trimEvalMap["MINUS"] = function(node, scope) {
	var lhs = trimNode(node.children[0], scope);
	var rhs = trimNode(node.children[1], scope);
	if(isConst(lhs) && isConst(rhs)){
		return minus(lhs, rhs);
	}else{
		var n = new TreeNode(node.origText, node.typeName, node.line);
		n.children = [lhs,rhs]
		return n;
	}
};

trimEvalMap["FLOAT"] = trimEvalMap["INTEGER"];
trimEvalMap["PRIMITIVE"] = function(node, primitiveBank) {
	var res;
	if(node.text.substr(0, 2)=="[["){
		res = new PrimitiveStore(primitiveBank[node.text.substr(2, node.text.length-4)], "totalValue");
	}else{
		res = new PrimitiveStore(primitiveBank[node.text.substr(1, node.text.length-2)], "object");
	}
	if(typeof res.primitive === "undefined"){
		throw "MSG: The primitive <i>"+node.origText+"</i> could not be found.";
	}
	return res;
};
trimEvalMap["NEGATE"] = function(node, scope) {
	if(node.children.length==0){
		return new TreeNode(node.origText,  node.typeName, node.line);
	}
	var x = trimNode(node.children[0], scope);
	if(isConst(x)){
		return negate(x)
	}else{
		var n = new TreeNode(node.origText, node.typeName, node.line);
		n.children = [x]
		return n;
	}
};

trimEvalMap["ARRAY"] = function(node, scope){
	var n = new TreeNode(node.origText, node.typeName,node.line);
	var vals = [];
	var names = [];
	var hasName = false;
	for(var i = 0; i < node.children.length; i++){
		n.children.push(trimNode(node.children[i], scope));
		vals.push(n.children[i].children[0]);
		if(n.children[i].children.length>1){
			if(n.children[i].children[1].text){
				names.push(n.children[i].children[1].origText);
			}else{
				names.push(n.children[i].children[1].valueOf());
			}
			hasName = true;
		}else{
			names.push(undefined);
		}
	}
	
	var allConst = true;
	for(var i=0; i<vals.length; i++){
		if(! isConst(vals[i]) ){
			allConst = false;
			break;
		}
	}
	
	if(allConst){
		n.children = [new Vector(vals, hasName?names:undefined)];
	}
	return n;
}

function isConst(x){
	if( (x instanceof Material) || (typeof x == "string") || (x instanceof String) || (typeof x == "boolean") || (x instanceof Vector) ){
		return true;
	}
	return false
}

function trimNode(node, primitives) {
	if(trimEvalMap.hasOwnProperty(node.typeName)){
		evaluatingLine = node.line || evaluatingLine;
		return trimEvalMap[node.typeName](node, primitives);
	}else{
		var n = new TreeNode(node.origText, node.typeName,node.line);
		for(var i = 0; i < node.children.length; i++){
			n.children.push(trimNode(node.children[i], primitives));
		}
		return n;
	}
}

function trueValue(q){
	if(typeof q == "boolean"){
		return q;
	}else if(q instanceof Material){
		return neq(q.value, 0);	
	}else{
		throw "MSG: Only numbers can be used in place of booleans."
	}
}

function isLocal() {
	return (document.location.hostname == "localhost" || document.location.hostname == "insightmaker.test" || document.location.hostname == "calc.test" );
}

function isUndefined(item){
	return typeof(item)=="undefined";
}

function isDefined(item){
	return (! isUndefined(item));
}

function fireEvent(obj, eventName, eventObj){
	var p;
	var lastSelf  = obj;
	if(obj instanceof Vector){
		p = obj.parent;
	}else if (obj.vector instanceof Vector){
		obj = obj.vector;
		p = obj.parent;
	}else if (obj.parent instanceof Vector){
		obj = obj.parent;
		p = obj;
	}else{
		return false;
	}
	
	try{
		//console.log(eventName);
		//console.log(obj);
		var r = selectFromVector(obj, eventName);
		//console.log("found!");
	}catch(err){
		//console.log(err);
		return false;
	}
	
	eventObj.optional = true;
	
	return callFunction(r.data, [eventObj], varBank, lastSelf, p);
}

function ObjToVec(obj){
	var keys = Object.keys(obj);
	var vals = [];
	for(var i=0; i<keys.length; i++){
		vals.push(obj[keys[i]]);
	}
	return new Vector(vals, keys);
	
}


"use strict";
/*

Copyright 2010-2020 Scott Fortmann-Roe. All rights reserved.

This file may distributed and/or modified under the
terms of the Insight Maker Public License (https://InsightMaker.com/impl).

*/


functionLoaders.push(function () {

	defineFunction("RandBeta", { params: [{ name: "Alpha", noUnits: true, noVector: true }, { name: "Beta", noUnits: true, noVector: true }] }, function (x) {

		return new Material(RandBeta(x[0].value, x[1].value));
	});
	defineFunction("RandDist", { params: [{ name: "Distribution", noUnits: true, needVector: true }, { name: "Y (in which case Distribution is X)", noUnits: true, needVector: true, defaultVal: false }] }, function (x) {
		var xVals, yVals;
		if (x.length == 1 || x[1] === false) {
			var vec = x[0];
			xVals = [];
			yVals = [];
			for (var i = 0; i < vec.items.length; i++) {
				xVals.push(vec.items[i].items[0].toNum().value);
				yVals.push(vec.items[i].items[1].toNum().value);
			}
		} else {
			xVals = x[0].toNum().items.map(function (x) { return x.value });
			yVals = x[1].toNum().items.map(function (x) { return x.value });
		}
		return new Material(RandDist(xVals, yVals));
	});
	defineFunction("RandBoolean", { params: [{ name: "Probability", defaultVal: 0.5, noUnits: true, noVector: true }] }, function (x) {
		var p;
		if (x.length != 0) {
			p = x[0].toNum().value;
		} else {
			p = 0.5;
		}

		if (Rand() < p) {
			return true;
		} else {
			return false;

		}
	});
	defineFunction("Rand", { params: [{ name: "Lower Bound", defaultVal: 0, noUnits: true, noVector: true }, { name: "Upper Bound", defaultVal: 1, noUnits: true, noVector: true }] }, function (x) {
		if (x.length != 0) {
			return new Material(Rand(x[0].toNum().value, x[1].toNum().value));
		} else {
			return new Material(Rand());
		}
	});
	defineFunction("RandNormal", { params: [{ name: "Mean", defaultVal: 0, noUnits: true, noVector: true }, { name: "Standard Deviation", defaultVal: 1, noUnits: true, noVector: true }] }, function (x) {
		if (x.length != 0) {
			return new Material(RandNormal(x[0].toNum().value, x[1].toNum().value));
		} else {
			return new Material(RandNormal());
		}
	});
	defineFunction("RandExp", { params: [{ name: "Rate", defaultVal: 1, noUnits: true, noVector: true }] }, function (x) {
		if (x.length != 0) {
			return new Material(RandExp(x[0].toNum().value));
		} else {
			return new Material(RandExp());
		}
	});
	defineFunction("RandLognormal", { params: [{ name: "Mean", noUnits: true, noVector: true }, { name: "Standard Deviation", noUnits: true, noVector: true }] }, function (x) {
		return new Material(RandLognormal(x[0].toNum().value, x[1].toNum().value));
	});
	defineFunction("RandBinomial", { params: [{ name: "Count", noUnits: true, noVector: true }, { name: "Probability", noUnits: true, noVector: true }] }, function (x) {
		return new Material(RandBinomial(x[0].toNum().value, x[1].toNum().value));
	});
	defineFunction("RandNegativeBinomial", { params: [{ name: "Successes", noUnits: true, noVector: true }, { name: "Probability", noUnits: true, noVector: true }] }, function (x) {
		return new Material(RandNegativeBinomial(x[0].toNum().value, x[1].toNum().value));
	});
	defineFunction("RandGamma", { params: [{ name: "Alpha", noUnits: true, noVector: true }, { name: "Beta", noUnits: true, noVector: true }] }, function (x) {
		return new Material(RandGamma(x[0].toNum().value, x[1].toNum().value));
	});
	defineFunction("RandPoisson", { params: [{ name: "Rate", noUnits: true, noVector: true }] }, function (x) {
		return new Material(RandPoisson(x[0].toNum().value));
	});
	defineFunction("RandTriangular", { params: [{ name: "Minimum", noUnits: true, noVector: true }, { name: "Maximum", noUnits: true, noVector: true }, { name: "Peak", noUnits: true, noVector: true }] }, function (x) {
		return new Material(RandTriangular(x[0].toNum().value, x[1].toNum().value, x[2].toNum().value));
	});

	defineFunction("Real", { params: [{ name: "Number" }], recurse: true }, function (x) {
		var r = x[0].toNum();
		r.value = fn["real-part"](r.value);
		return r;
	});
	defineFunction("Imag", { params: [{ name: "Number" }], recurse: true }, function (x) {
		var r = x[0].toNum();
		r.value = fn["imag-part"](r.value);
		return r;
	});
	defineFunction("Magnitude", { params: [{ name: "Number" }] }, function (x) {
		if (x[0].toNum() instanceof Vector) {
			return functionBank["sqrt"]([functionBank["sum"]([mult(x[0], x[0])])])
		}
		var r = x[0].toNum();
		r.value = fn.magnitude(r.value);
		return r;
	});
	defineFunction("Angle", { params: [{ name: "Number" }], recurse: true }, function (x) {
		return new Material(fn.angle(x[0].toNum().value), getUnitStore(["radians"], [1]));
	});
	defineFunction("Abs", { params: [{ name: "Number" }], recurse: true }, function (x) {
		var r = x[0].toNum();
		r.value = fn.abs(r.value);
		return r;
	});
	defineFunction("sin", { params: [{ name: "Number" }], recurse: true }, function (x) {
		var z = x[0].toNum();

		if (z.units) {
			z = mult(z, new Material(1, getUnitStore(["radians"], [-1])))
		}
		if (!z.units) {
			return new Material(fn.sin(z.value));
		} else {
			throw "MSG: Non-angular units cannot be used in Sin().";
		}
	});
	defineFunction("cos", { params: [{ name: "Number" }], recurse: true }, function (x) {
		var z = x[0].toNum();

		if (z.units) {
			z = mult(z, new Material(1, getUnitStore(["radians"], [-1])))
		}
		if (!z.units) {
			return new Material(fn.cos(z.value));
		} else {
			throw "MSG: Non-angular units cannot be used in Cos().";
		}

	});
	defineFunction("tan", { params: [{ name: "Number" }], recurse: true }, function (x) {
		var z = x[0].toNum();

		if (z.units) {
			z = mult(z, new Material(1, getUnitStore(["radians"], [-1])))
		}
		if (!z.units) {
			return new Material(fn.tan(z.value));
		} else {
			throw "MSG: Non-angular units cannot be used in Tan().";
		}

	});


	defineFunction("asin", { params: [{ name: "Number", noUnits: true }], recurse: true }, function (x) {
		return new Material(fn.asin(x[0].toNum().value));
	});
	defineFunction("acos", { params: [{ name: "Number", noUnits: true }], recurse: true }, function (x) {
		return new Material(fn.acos(x[0].toNum().value));
	});
	defineFunction("atan", { params: [{ name: "Number", noUnits: true }], recurse: true }, function (x) {
		return new Material(fn.atan(x[0].toNum().value));
	});

	defineFunction("arcsin", { params: [{ name: "Number", noUnits: true }], recurse: true }, function (x) {
		return new Material(fn.asin(x[0].toNum().value), getUnitStore(["radians"], [1]));
	});
	defineFunction("arccos", { params: [{ name: "Number", noUnits: true }], recurse: true }, function (x) {
		return new Material(fn.acos(x[0].toNum().value), getUnitStore(["radians"], [1]));
	});
	defineFunction("arctan", { params: [{ name: "Number", noUnits: true }], recurse: true }, function (x) {
		return new Material(fn.atan(x[0].toNum().value), getUnitStore(["radians"], [1]));
	});

	defineFunction("Sign", { params: [{ name: "Number" }], recurse: true }, function (x) {
		var r = x[0].toNum();
		if (r.value < 0) {
			return div(new Material(-1), new Material(1));
		} else if (r.value > 0) {
			return div(new Material(1), new Material(1));
		} else if (r.value == 0) {
			return new Material(0);
		}
		throw "MSG: Invalid value for Sign";
	});

	defineFunction("Sqrt", { params: [{ name: "Number" }], recurse: true }, function (x) {
		var r = x[0].toNum();
		r.value = fn.sqrt(r.value);
		if (r.units) {
			r.units = r.units.power(0.5);
		}
		return r;
	});
	defineFunction("Ln", { params: [{ name: "Number", noUnits: true }], recurse: true }, function (x) {
		return new Material(fn.log(x[0].toNum().value));
	});
	defineFunction("Log", { params: [{ name: "Number", noUnits: true }], recurse: true }, function (x) {
		return new Material(fn.log(x[0].toNum().value, 10));
	});
	defineFunction("Logit", { params: [{ name: "Number", noUnits: true }], recurse: true }, function (x) {
		var r = x[0].toNum();
		r.value = fn["-"](fn.log(r.value), fn.log(fn["-"](1, r.value)));
		return r;
	});
	defineFunction("Expit", { params: [{ name: "Number", noUnits: true }], recurse: true }, function (x) {
		var r = x[0].toNum();
		r.value = fn["/"](1, fn["+"](1, fn.exp(fn["-"](r.value))));
		return r;
	});
	defineFunction("Round", { params: [{ name: "Number", noUnits: false }], recurse: true }, function (x) {
		var r = x[0].toNum();
		r.value = fn.round(r.value);
		return r;
	});
	defineFunction("Ceiling", { params: [{ name: "Number", noUnits: false }], recurse: true }, function (x) {
		var r = x[0].toNum();
		r.value = fn.ceiling(r.value);
		return r;
	});
	defineFunction("Floor", { params: [{ name: "Number", noUnits: false }], recurse: true }, function (x) {
		var r = x[0].toNum();
		r.value = fn.floor(r.value);
		return r;
	});
	defineFunction("Exp", { params: [{ name: "Number", noUnits: true }], recurse: true }, function (x) {
		return new Material(fn.exp(x[0].toNum().value));
	});

	functionBank["ifthenelse"] = function (x) {
		testArgumentsSize(x, "IfThenElse", 3, 3);

		var v = evaluateNode(x[0].node, x[0].scope).toNum();

		if (v instanceof Vector) {
			return vecIfThenElse(v, evaluateNode(x[1].node, x[1].scope), evaluateNode(x[2].node, x[2].scope))
		}

		if (trueValue(v)) {
			//console.log("T");
			return evaluateNode(x[1].node, x[1].scope);
		} else {
			//console.log("F")
			return evaluateNode(x[2].node, x[2].scope);
		}
	};
	functionBank["ifthenelse"].delayEvalParams = true;

	function vecIfThenElse(test, tVal, fVal) {

		var choiceFn = function (t, f) {
			if (t instanceof Vector) {
				return t.combine(f, choiceFn);
			} else {
				return [t, f];
			}
		};

		tVal = tVal.toNum();
		fVal = fVal.toNum();
		if (tVal instanceof Vector) {
			var choices = tVal.cloneCombine(fVal, choiceFn);
		} else if (fVal instanceof Vector) {
			choices = fVal.cloneCombine(tVal, function (a, b) { return choiceFn(b, a) });
		} else {
			choices = choiceFn(tVal, fVal);
		}

		var testFn = function (test, val) {
			if (test instanceof Vector) {
				return test.combine(val, testFn);
			}

			if (trueValue(test)) {
				return val[0];
			} else {
				return val[1];
			}
		}

		return test.cloneCombine(choices, testFn)
	}


	functionBank["map"] = function (x) {
		//console.log(x);
		testArgumentsSize(x, "Map", 2, 2);
		var v;
		if (x[0].node instanceof Vector) {
			v = x[0].node;
		} else if (x[0] instanceof Vector) {
			v = x[0];
		} else {
			v = evaluateNode(x[0].node, x[1].scope);
		}

		if (v instanceof Primitive) {
			v = v.toNum();
		}
		if (!(v instanceof Vector)) {
			throw "MSG: Map() requires a vector as its first argument.";
		}
		v = v.fullClone();

		var fn;
		var scope = { x: null, "-parent": x[1].scope }
		var node = x[1].node;
		try {
			fn = evaluateNode(node, scope)
		} catch (err) {

		};

		var f;
		if ((fn instanceof Function) || (fn instanceof UserFunction)) {
			if (fn.fn) {
				fn = fn.fn;
			}
			f = function (x, key) {
				return fn([x]);
			};
		} else {
			f = function (input, key) {
				scope.x = input;
				scope.key = key || "";
				return evaluateNode(node, scope);
			}
		}

		return v.apply(f);
	};
	functionBank["map"].delayEvalParams = true;
	VectorObject["map"] = functionBank["map"];

	defineFunction("Sample", { object: [functionBank, VectorObject], params: [{ name: "Vector", needVector: true }, { name: "Sample Size" }, { name: "Repeat", noVector: true, allowBoolean: true, defaultVal: false }] }, function (x) {
		var v = x[0].toNum();
		var count = x[1].toNum().value;
		if (count == 0) {
			return new Vector([]);
		}

		var length = v.length();
		var repeat = x[2] && trueValue(x[2].toNum());

		if (length == 0) {
			throw "MSG: Sample() requires a non-empty vector.";
		}
		var res = [];
		if (repeat) {
			for (var i = 0; i < count; i++) {
				res.push(v.items[Math.floor(Rand() * length)]);
			}
		} else {
			if (length < count) {
				throw "MSG: Vector for Sample() is too small for the given sample size.";
			}

			var shuffled = v.items.slice();
			for (var i = 0; i < count; i++) {
				res.push(shuffled.splice(Math.floor(Rand() * shuffled.length), 1)[0]);
			}
		}

		return new Vector(res);
	});

	defineFunction("IndexOf", { object: [functionBank, VectorObject], params: [{ name: "Haystack", needVector: true, noUnits: true }, { name: "Needle", allowBoolean: true, allowString: true }] }, function (x) {

		var v = x[1];

		if (v instanceof Vector) {
			var res = [];
			for (var i = 0; i < v.items.length; i++) {
				res.push(findElement(v.items[i], x[0]));
			}
			return new Vector(res);
		} else {
			return findElement(v, x[0]);
		}
	});

	defineFunction("Contains", { object: [functionBank, VectorObject], params: [{ name: "Haystack", needVector: true, noUnits: true }, { name: "Needle", allowBoolean: true, noVector: true, allowString: true }] }, function (x) {

		if (eq(new Material(0), functionBank["indexof"](x))) {
			return false;
		} else {
			return true;
		}
	});

	defineFunction("Collapse", { params: [{ name: "Source", needVector: true, noUnits: false }, { name: "Target", noVector: false }] }, function (x) {
		return x[0].toNum().collapseDimensions(x[1].toNum());
	});

	function findElement(needle, haystack) {
		for (var i = 0; i < haystack.length(); i++) {
			if (eq(needle, haystack.items[i])) {
				return new Material(i + 1);
			}
		}
		return new Material(0);
	}

	functionBank["filter"] = function (x) {
		testArgumentsSize(x, "Filter", 2, 2);

		var v;
		if (x[0].node instanceof Vector) {
			v = x[0].node;
		} else if (x[0] instanceof Vector) {
			v = x[0];
		} else {
			v = evaluateNode(x[0].node, x[0].scope);
		}

		if (v instanceof Primitive) {
			v = v.toNum();
		}
		if (!(v instanceof Vector)) {
			throw "MSG: Filter() requires a vector as its first argument.";
		}
		v = v.fullClone();

		var t = functionBank["map"](x);
		return functionBank["select"]([v, t]);
	};
	functionBank["filter"].delayEvalParams = true;
	VectorObject["filter"] = functionBank["filter"];

	functionBank["join"] = function (x) {
		var res = [];
		var names = [];
		var hasNames = false;
		for (var i = 0; i < x.length; i++) {
			var y = x[i];

			if (y instanceof Primitive) {
				y = y.toNum();
			}

			if (y instanceof Vector) {
				res = res.concat(y.items);
				if (y.names) {
					names = names.concat(y.names)
					hasNames = true;
				} else {
					for (var j = 0; j < y.items.length; j++) {
						names.push(undefined)
					}
				}
			} else {
				res.push(y);
				names.push(undefined);
			}
		}
		return new Vector(res, hasNames ? names : undefined);
	};

	functionBank["repeat"] = function (x) {
		testArgumentsSize(x, "Repeat", 2, 2);
		var items = evaluateNode(x[1].node, x[1].scope).toNum();
		var count = items;
		if (items instanceof Vector) {
			count = items.items.length;
		}
		var res = [];
		var scope = { x: null, "-parent": x[1].scope, key: null }
		for (var i = 0; i < count; i++) {
			if (items instanceof Vector) {
				scope.key = items.items[i];
			}
			scope.x = new Material(i + 1);
			res.push(evaluateNode(x[0].node, scope));
		}

		return new Vector(res, (items instanceof Vector) ? items.items.slice() : undefined);

	};
	functionBank["repeat"].delayEvalParams = true;

	defineFunction("Select", { params: [{ name: "Haystack", needVector: true, noUnits: true }, { name: "Indexes", noUnits: true }] }, function (x) {

		var indexes = x[1].toNum();
		if (x[1] instanceof Vector) {
			var v = x[1].toNum();
			var isBoolean = true;
			for (var i = 0; i < v.length(); i++) {
				if (v.items[i] instanceof Material) {
					isBoolean = false;
					break;
				}
			}
			if (isBoolean == true) {
				var res = [];
				var names = x[0].names ? [] : undefined;
				if (v.length() != x[0].length()) {
					throw "MSG: Length of vector must be equal for boolean selection.";
				}
				for (var i = 0; i < v.length(); i++) {
					if (trueValue(v.items[i])) {
						res.push(x[0].items[i]);

						if (x[0].names) {
							names.push(x[0].names[i])
						}
					}
				}
				return new Vector(res, names);
			} else {
				var res = [];
				var names = x[0].names ? [] : undefined;
				for (var i = 0; i < v.length(); i++) {
					var q = v.items[i].value
					if (q <= 0 || q > x[0].length()) {
						throw "MSG: Selected element out of range.";
					}
					res.push(x[0].items[q - 1]);

					if (x[0].names) {
						names.push(x[0].names[q - 1])
					}
				}
				return new Vector(res, names);
			}
		} else {
			if (x[1].value > 0 && x[1].value <= x[0].length()) {
				return x[0].items[x[1].value - 1];
			} else {
				throw "MSG: Selected element out of range.";
			}
		}
	});

	defineFunction("Reverse", {
		allowEmpty: true, params: { name: "Items..." }, prep: function (x) {
			return functionBank["join"](x);
		}
	}, function (x) {
		return new Vector(x.items.slice().reverse(), x.names ? x.names.slice().reverse() : undefined);
	});
	defineFunction("Reverse", { object: VectorObject, params: [{ name: "Vector", needVector: true }] }, function (x) {
		return functionBank["reverse"](x);
	});

	defineFunction("Sort", {
		allowEmpty: true, params: { name: "Items..." }, prep: function (x) {
			return functionBank["join"](x).toNum();
		}
	}, function (x) {
		var res = x.stackApply(function (x) {
			var items = [];
			for (var i = 0; i < x.items.length; i++) {
				items.push({ item: x.items[i], name: x.names ? x.names[i] : undefined })
			}

			var res = items.sort(function (a, b) {
				if (lessThan(a.item, b.item)) {
					return -1;
				}
				if (greaterThan(a.item, b.item)) {
					return 1;
				}
				return 0;
			});


			var names = x.names ? [] : undefined;
			items = []

			for (var i = 0; i < res.length; i++) {
				items.push(res[i].item);
				if (names) {
					names.push(res[i].name)
				}
			}

			return new Vector(items, names);
		});
		return res;
	});
	defineFunction("Sort", { object: VectorObject, params: [{ name: "Vector", needVector: true }] }, function (x) {
		return functionBank["sort"](x);
	});

	defineFunction("Unique", {
		allowEmpty: true, params: { name: "Items....", allowBoolean: true }, prep: function (x) {
			return functionBank["join"](x).toNum();
		}
	}, function (x) {
		if (x.items.length == 0) {
			return new Vector([]);
		}

		var res = [];
		var names = x.names ? [] : undefined;

		for (var i = 0; i < x.items.length; i++) {
			var found = false;

			for (var j = 0; j < res.length; j++) {
				if (strictEquals(x.items[i], res[j])) {
					found = true;
					break;
				}
			}
			if (!found) {
				res.push(x.items[i]);
				if (names) {
					names.push(x.names[i]);
				}
			}
		}
		return new Vector(res, names);
	});
	defineFunction("Unique", { object: VectorObject, params: [{ name: "Vector", needVector: true }] }, function (x) {
		return functionBank["unique"](x);
	});



	defineFunction("Union", { object: [functionBank, VectorObject], params: [{ name: "Vector 1", needVector: true }, { name: "Vector 2", needVector: true }] }, function (x) {
		return functionBank["unique"](functionBank["join"](x).items);
	});

	defineFunction("Intersection", { object: [functionBank, VectorObject], params: [{ name: "Vector 1", needVector: true }, { name: "Vector 2", needVector: true }] }, function (x) {
		var v1 = x[0];
		var v2 = x[1];

		var res = [];

		for (var i = 0; i < v1.items.length; i++) {
			for (var j = 0; j < v2.items.length; j++) {
				if (strictEquals(v1.items[i], v2.items[j])) {
					res.push(v1.items[i]);
					break;
				}
			}
		}
		return functionBank["unique"](res);
	});


	defineFunction("Difference", { object: [functionBank, VectorObject], params: [{ name: "Vector 1", needVector: true }, { name: "Vector 2", needVector: true }] }, function (x) {
		var v1 = x[0];
		var v2 = x[1];

		var res = [];

		for (var i = 0; i < v1.items.length; i++) {
			var found = false;
			for (var j = 0; j < v2.items.length; j++) {
				if (strictEquals(v1.items[i], v2.items[j])) {
					found = true;
					break;
				}
			}
			if (!found) {
				res.push(v1.items[i]);
			}
		}
		for (var i = 0; i < v2.items.length; i++) {
			var found = false;
			for (var j = 0; j < v1.items.length; j++) {
				if (strictEquals(v2.items[i], v1.items[j])) {
					found = true;
					break;
				}
			}
			if (!found) {
				res.push(v2.items[i]);
			}
		}

		return functionBank["unique"](res);
	});

	defineFunction("Factorial", { params: [{ name: "Number", noUnits: true }], recurse: true }, function (x) {
		return new Material(factorial(x[0].toNum().value));
	});

	defineFunction("Max", { params: { name: "Items..." }, prep: joinVector }, function (x) {

		var res = x.stackApply(function (v) {
			//console.log(v);
			var x = v.items;
			if (x.length > 0) {
				var max = x[0];
				for (var i = 1; i < x.length; i++) {
					if (greaterThan(x[i], max)) {
						max = x[i];
					}
				}
				return max;
			} else {
				throw "MSG: You must have at least one element to calculate a max.";
			}
		});

		return res;
	});
	defineFunction("Max", { object: VectorObject, params: [{ name: "Vector", needVector: true }] }, function (x) {
		return functionBank["max"](x);
	});

	function joinVector(x, notToNum, skip) {
		if (!notToNum) {
			for (var i = 0; i < x.length; i++) {
				x[i] = x[i].toNum();
			}
		}
		if (x.length == 1 && (x[0] instanceof Vector)) {
			if (skip) {
				return x[0];
			} else {
				return functionBank["flatten"]([x[0]]);
			}
		} else {
			return (new Vector(scalarsToVectors(x)));
		}
	}
	function joinArray(x) {
		for (var i = 0; i < x.length; i++) {
			if (x[i].toNum) {
				x[i] = x[i].toNum();
			}
		}
		if (x.length == 1 && (x[0] instanceof Vector)) {
			return functionBank["flatten"]([x[0].toNum()]).items;
		}
		return joinVector(x, undefined, true).items;
	}
	function scalarsToVectors(x) {
		var needVector = false;
		var vec;

		for (var i = 0; i < x.length; i++) {
			if (x[i] instanceof Vector) {
				vec = x[i];
				needVector = true;
				break;
			}
		}

		if (needVector) {
			for (var i = 0; i < x.length; i++) {
				if (!(x[i] instanceof Vector)) {
					x[i] = replicateVectorStructure(vec, x[i]);
				}
			}
		}

		return x;
	}
	function replicateVectorStructure(vec, val) {
		var v = vec.fullClone();
		for (var i = 0; i < v.items.length; i++) {
			if (v.items[i] instanceof Vector) {
				v.items[i] = replicateVectorStructure(v.items[i], val);
			} else {
				v.items[i] = val;
			}
		}
		return v;
	}

	defineFunction("Lookup", { params: [{ name: "Value", noVector: true }, { name: "Value Vector", needVector: true }, { name: "Results Vector", needVector: true }] }, function (x) {
		var v = x[0].toNum();
		var xVec = x[1].toNum();
		var yVec = x[2].toNum();

		if (xVec.items.length != yVec.items.length) {
			throw "MSG: The value and results vectors must be the same length";
		}

		if (xVec.items.length < 1) {
			throw "MSG: You must have at least one element in your vectors";
		}

		var vec = [];
		for (var i = 0; i < xVec.items.length; i++) {
			vec.push({ x: xVec.items[i], y: yVec.items[i] });
		}

		vec.sort(function (a, b) {
			if (greaterThan(a.x, b.x)) {
				return 1;
			} else if (lessThan(a.x, b.x)) {
				return -1;
			} else {
				return 0;
			}
		});

		for (var i = 0; i < vec.length; i++) {
			if (eq(vec[i].x, v)) {
				return vec[i].y.fullClone();
			} else if (greaterThan(vec[i].x, v)) {
				if (i == 0) {
					return vec[i].y.fullClone();
				}

				var dist = minus(vec[i].x, vec[i - 1].x);
				var distLower = minus(v, vec[i - 1].x);
				var distUpper = minus(vec[i].x, v);
				var fLower = div(distUpper, dist);
				var fUpper = div(distLower, dist);
				return plus(mult(vec[i - 1].y, fLower), mult(vec[i].y, fUpper));
			}
		}

		return vec[vec.length - 1].y.fullClone();
	});

	defineFunction("Fill", { object: [functionBank, VectorObject], params: [{ name: "Vector", needVector: true }, { name: "Value", allowBoolean: true }] }, function (x) {
		return replicateVectorStructure(x[0], x[1]);
	});

	defineFunction("Min", { params: { name: "Items..." }, prep: joinVector }, function (x) {
		var res = x.stackApply(function (v) {
			var x = v.items;
			if (x.length > 0) {
				var min = x[0];
				for (var i = 1; i < x.length; i++) {
					if (lessThan(x[i], min)) {
						min = x[i];
					}
				}
				return min;

			} else {
				throw "MSG: You must have at least one element to calculate a median.";
			}
		});

		return res;
	});
	defineFunction("Min", { object: VectorObject, params: [{ name: "Vector", needVector: true }] }, function (x) {
		return functionBank["min"](x);
	});
	defineFunction("Mean", { params: { name: "Items..." }, prep: joinArray }, function (x) {
		var sum = x[0];
		for (var i = 1; i < x.length; i++) {
			sum = plus(sum, x[i]);
		}
		return div(sum, new Material(x.length));
	});
	defineFunction("Mean", { object: VectorObject, params: [{ name: "Vector", needVector: true }] }, function (x) {
		return functionBank["mean"](x);
	});
	defineFunction("Sum", { params: { name: "Items..." }, prep: joinArray }, function (x) {
		var sum = x[0];

		for (var i = 1; i < x.length; i++) {
			sum = plus(sum, x[i]);
		}
		return sum;
	});
	defineFunction("Sum", { object: VectorObject, params: [{ name: "Vector", needVector: true }] }, function (x) {
		return functionBank["sum"](x);
	});
	defineFunction("Product", { params: { name: "Items..." }, prep: joinArray }, function (x) {
		var total = x[0];
		for (var i = 1; i < x.length; i++) {
			total = mult(total, x[i]);
		}
		return total;
	});
	defineFunction("Product", { object: VectorObject, params: [{ name: "Vector", needVector: true }] }, function (x) {
		return functionBank["product"](x);
	});
	defineFunction("Median", { params: { name: "Items..." }, prep: joinVector }, function (x) {
		var res = x.stackApply(function (v) {
			var x = functionBank["sort"]([v]).items;
			if (x.length > 0) {
				if (Math.floor((x.length - 1) / 2) == (x.length - 1) / 2) {
					return x[(x.length - 1) / 2];
				} else {
					return div(plus(x[Math.floor(((x.length - 1) / 2))], x[Math.ceil(((x.length - 1) / 2))]), new Material(2));
				}
			} else {
				throw "MSG: You must have at least one element to calculate a median.";
			}
		});
		return res;
	});
	defineFunction("Median", { object: VectorObject, params: [{ name: "Vector", needVector: true }] }, function (x) {
		return functionBank["median"](x);
	});
	defineFunction("StdDev", { params: { name: "Items..." }, prep: joinVector }, function (x) {
		var res = x.stackApply(function (v) {
			var x = v.items;
			if (x.length > 1) {

				var mean = functionBank["mean"](x);
				var sum = power(minus(x[0], mean), new Material(2));

				for (var i = 1; i < x.length; i++) {

					sum = plus(sum, power(minus(x[i], mean), new Material(2)));
				}
				var r = power(div(sum, new Material(x.length - 1)), new Material(0.5));

				return functionBank["real"]([r]);
			} else {
				throw "MSG: You must have at least two elements to calculate the standard deviation.";
			}
		});
		return res;
	});
	defineFunction("StdDev", { object: VectorObject, params: [{ name: "Vector", needVector: true }] }, function (x) {
		return functionBank["stddev"](x);
	});
	defineFunction("Correlation", { params: [{ name: "Vector 1", needVector: true }, { name: "Vector 2", needVector: true }] }, function (x) {
		var v1 = x[0].toNum();
		var v2 = x[1].toNum();

		if (v1.length() <= 1) {
			throw "MSG: You must have at least two elements in your vectors to calculate their correlation.";
		}
		if (v1.length() != v2.length()) {
			throw "MSG: The vectors for Correlation() must be of the same size.";
		}


		var v1_mean = functionBank["mean"]([v1]);
		var v2_mean = functionBank["mean"]([v2]);

		var v1_stddev = functionBank["stddev"]([v1]);
		var v2_stddev = functionBank["stddev"]([v2]);

		if (v1_stddev.value == 0 || v2_stddev.value == 0) {
			return new Material(0);
		}

		return div(functionBank["sum"]([mult(minus(v1.clone(), v1_mean), minus(v2.clone(), v2_mean))]), mult(minus(functionBank["count"]([v1]), new Material(1)), mult(v1_stddev, v2_stddev)))
	});
	functionBank["count"] = function (x) {
		x = functionBank["join"](x).items;
		return new Material(sn("#e" + x.length));
	};
	functionBank["flatten"] = function (x) {
		var res = flatten(functionBank["join"](x));
		return new Vector(res.items, res.hasName ? res.names : undefined);
	};

	defineFunction("Keys", { object: VectorObject, params: [{ name: "Vector", needVector: true }] }, function (x) {
		if (!x[0].names) {
			return new Vector([]);
		}
		return new Vector(x[0].names.filter(function (x) { return isDefined(x) }).map(function (x) { return s(x) }));
	});
	defineFunction("Values", { object: VectorObject, params: [{ name: "Vector", needVector: true }] }, function (x) {
		return new Vector(x[0].items);
	});
	defineFunction("Length", { object: VectorObject, params: [{ name: "Vector", needVector: true }] }, function (x) {
		return new Material(sn("#e" + x[0].items.length));
	});
	defineFunction("Count", { object: VectorObject, params: [{ name: "Vector", needVector: true }] }, function (x) {
		return new Material(sn("#e" + x[0].items.length));
	});
	defineFunction("Flatten", { object: VectorObject, params: [{ name: "Vector", needVector: true }] }, function (x) {
		return functionBank["flatten"](x);
	});

	function flatten(x) {
		var res = [];
		var names = [];
		var hasName = undefined;

		for (var i = 0; i < x.length(); i++) {
			if (x.items[i] instanceof Vector) {
				var z = flatten(x.items[i]);
				res = res.concat(z.items);
				names = names.concat(z.names);
				hasName = hasName || z.hasName;
			} else {
				res.push(x.items[i]);
				if (x.names) {
					names.push(x.names[i]);
					hasName = true;
				} else {
					names.push(undefined);
				}
			}
		}
		return { items: res, names: names, hasName: hasName };
	}


	/* Statistics */

	defineFunction("CDFNormal", { params: [{ name: "x", noUnits: true, noVector: true }, { name: "Mean", defaultVal: 0, noUnits: true, noVector: true }, { name: "Standard Deviation", defaultVal: 1, noUnits: true, noVector: true }] }, function (x) {
		var val = x[0].toNum().value;
		var mu = x[1] ? x[1].toNum().value : 0;
		var sd = x[2] ? x[2].toNum().value : 1;

		return new Material(jStat.normal.cdf(val, mu, sd));
	});

	defineFunction("PDFNormal", { params: [{ name: "x", noUnits: true, noVector: true }, { name: "Mean", defaultVal: 0, noUnits: true, noVector: true }, { name: "Standard Deviation", defaultVal: 1, noUnits: true, noVector: true }] }, function (x) {
		var val = x[0].toNum().value;
		var mu = x[1] ? x[1].toNum().value : 0;
		var sd = x[2] ? x[2].toNum().value : 1;

		return new Material(jStat.normal.pdf(val, mu, sd));
	});

	defineFunction("InvNormal", { params: [{ name: "p", noUnits: true, noVector: true }, { name: "Mean", defaultVal: 0, noUnits: true, noVector: true }, { name: "Standard Deviation", defaultVal: 1, noUnits: true, noVector: true }] }, function (x) {
		var val = x[0].toNum().value;
		if (val < 0 || val > 1) {
			throw "MSG: p is a probability and must be between 0 and 1 inclusive."
		}
		var mu = x[1] ? x[1].toNum().value : 0;
		var sd = x[2] ? x[2].toNum().value : 1;

		return new Material(jStat.normal.inv(val, mu, sd));
	});

	defineFunction("CDFLogNormal", { params: [{ name: "x", noUnits: true, noVector: true }, { name: "Mean", defaultVal: 0, noUnits: true, noVector: true }, { name: "Standard Deviation", defaultVal: 1, noUnits: true, noVector: true }] }, function (x) {
		var val = x[0].toNum().value;
		var mu = x[1] ? x[1].toNum().value : 0;
		var sd = x[2] ? x[2].toNum().value : 1;

		return new Material(jStat.lognormal.cdf(val, mu, sd));
	});

	defineFunction("PDFLogNormal", { params: [{ name: "x", noUnits: true, noVector: true }, { name: "Mean", defaultVal: 0, noUnits: true, noVector: true }, { name: "Standard Deviation", defaultVal: 1, noUnits: true, noVector: true }] }, function (x) {
		var val = x[0].toNum().value;
		var mu = x[1] ? x[1].toNum().value : 0;
		var sd = x[2] ? x[2].toNum().value : 1;

		return new Material(jStat.lognormal.pdf(val, mu, sd));
	});

	defineFunction("InvLogNormal", { params: [{ name: "p", noUnits: true, noVector: true }, { name: "Mean", defaultVal: 0, noUnits: true, noVector: true }, { name: "Standard Deviation", defaultVal: 1, noUnits: true, noVector: true }] }, function (x) {
		var val = x[0].toNum().value;
		if (val < 0 || val > 1) {
			throw "MSG: p is a probability and must be between 0 and 1 inclusive."
		}
		var mu = x[1] ? x[1].toNum().value : 0;
		var sd = x[2] ? x[2].toNum().value : 1;

		return new Material(jStat.lognormal.inv(val, mu, sd));
	});

	defineFunction("CDFt", { params: [{ name: "x", noUnits: true, noVector: true }, { name: "Degrees of Freedom", noUnits: true, noVector: true }] }, function (x) {
		var val = x[0].toNum().value;
		var dof = x[1].toNum().value;
		if (dof <= 0) {
			throw "MSG: Degrees of Freedom must be greater than 0."
		}

		return new Material(jStat.studentt.cdf(val, dof));
	});

	defineFunction("PDFt", { params: [{ name: "x", noUnits: true, noVector: true }, { name: "Degrees of Freedom", noUnits: true, noVector: true }] }, function (x) {
		var val = x[0].toNum().value;
		var dof = x[1].toNum().value;
		if (dof <= 0) {
			throw "MSG: Degrees of Freedom must be greater than 0."
		}

		return new Material(jStat.studentt.pdf(val, dof));
	});

	defineFunction("Invt", { params: [{ name: "p", noUnits: true, noVector: true }, { name: "Degrees of Freedom", noUnits: true, noVector: true }] }, function (x) {
		var val = x[0].toNum().value;
		if (val < 0 || val > 1) {
			throw "MSG: p is a probability and must be between 0 and 1 inclusive."
		}
		var dof = x[1].toNum().value;
		if (dof <= 0) {
			throw "MSG: Degrees of Freedom must be greater than 0."
		}

		return new Material(jStat.studentt.inv(val, dof));
	});

	defineFunction("CDFF", { params: [{ name: "x", noUnits: true, noVector: true }, { name: "Degrees of Freedom 1", noUnits: true, noVector: true }, { name: "Degrees of Freedom 2", noUnits: true, noVector: true }] }, function (x) {
		var val = x[0].toNum().value;
		var dof1 = x[1].toNum().value;
		if (dof1 <= 0) {
			throw "MSG: Degrees of Freedom must be greater than 0."
		}
		var dof2 = x[2].toNum().value;
		if (dof2 <= 0) {
			throw "MSG: Degrees of Freedom must be greater than 0."
		}

		return new Material(jStat.centralF.cdf(val, dof1, dof2));
	});

	defineFunction("PDFF", { params: [{ name: "x", noUnits: true, noVector: true }, { name: "Degrees of Freedom 1", noUnits: true, noVector: true }, { name: "Degrees of Freedom 2", noUnits: true, noVector: true }] }, function (x) {
		var val = x[0].toNum().value;
		var dof1 = x[1].toNum().value;
		if (dof1 <= 0) {
			throw "MSG: Degrees of Freedom must be greater than 0."
		}
		var dof2 = x[2].toNum().value;
		if (dof2 <= 0) {
			throw "MSG: Degrees of Freedom must be greater than 0."
		}

		return new Material(jStat.centralF.pdf(val, dof1, dof2));
	});

	defineFunction("InvF", { params: [{ name: "p", noUnits: true, noVector: true }, { name: "Degrees of Freedom 1", noUnits: true, noVector: true }, { name: "Degrees of Freedom 2", noUnits: true, noVector: true }] }, function (x) {
		var val = x[0].toNum().value;
		if (val < 0 || val > 1) {
			throw "MSG: p is a probability and must be between 0 and 1 inclusive."
		}
		var dof1 = x[1].toNum().value;
		if (dof1 <= 0) {
			throw "MSG: Degrees of Freedom must be greater than 0."
		}
		var dof2 = x[2].toNum().value;
		if (dof2 <= 0) {
			throw "MSG: Degrees of Freedom must be greater than 0."
		}

		return new Material(jStat.centralF.inv(val, dof1, dof2));
	});

	defineFunction("CDFChiSquared", { params: [{ name: "x", noUnits: true, noVector: true }, { name: "Degrees of Freedom", noUnits: true, noVector: true }] }, function (x) {
		var val = x[0].toNum().value;
		var dof = x[1].toNum().value;
		if (dof <= 0) {
			throw "MSG: Degrees of Freedom must be greater than 0."
		}

		return new Material(jStat.chisquare.cdf(val, dof));
	});

	defineFunction("PDFChiSquared", { params: [{ name: "x", noUnits: true, noVector: true }, { name: "Degrees of Freedom", noUnits: true, noVector: true }] }, function (x) {
		var val = x[0].toNum().value;
		var dof = x[1].toNum().value;
		if (dof <= 0) {
			throw "MSG: Degrees of Freedom must be greater than 0."
		}

		return new Material(jStat.chisquare.pdf(val, dof));
	});

	defineFunction("InvChiSquared", { params: [{ name: "p", noUnits: true, noVector: true }, { name: "Degrees of Freedom", noUnits: true, noVector: true }] }, function (x) {
		var val = x[0].toNum().value;
		if (val < 0 || val > 1) {
			throw "MSG: p is a probability and must be between 0 and 1 inclusive."
		}
		var dof = x[1].toNum().value;
		if (dof <= 0) {
			throw "MSG: Degrees of Freedom must be greater than 0."
		}

		return new Material(jStat.chisquare.inv(val, dof));
	});


	defineFunction("CDFExponential", { params: [{ name: "x", noUnits: true, noVector: true }, { name: "Rate", noUnits: true, noVector: true }] }, function (x) {
		var val = x[0].toNum().value;
		var rate = x[1].toNum().value;
		if (rate <= 0) {
			throw "MSG: Rate must be greater than 0."
		}

		return new Material(jStat.exponential.cdf(val, rate));
	});

	defineFunction("PDFExponential", { params: [{ name: "x", noUnits: true, noVector: true }, { name: "Rate", noUnits: true, noVector: true }] }, function (x) {
		var val = x[0].toNum().value;
		var rate = x[1].toNum().value;
		if (rate <= 0) {
			throw "MSG: Rate must be greater than 0."
		}

		return new Material(jStat.exponential.pdf(val, rate));
	});

	defineFunction("InvExponential", { params: [{ name: "p", noUnits: true, noVector: true }, { name: "DRate", noUnits: true, noVector: true }] }, function (x) {
		var val = x[0].toNum().value;
		if (val < 0 || val > 1) {
			throw "MSG: p is a probability and must be between 0 and 1 inclusive."
		}
		var rate = x[1].toNum().value;
		if (rate <= 0) {
			throw "MSG: Rate must be greater than 0."
		}

		return new Material(jStat.exponential.inv(val, rate));
	});

	defineFunction("CDFPoisson", { params: [{ name: "x", noUnits: true, noVector: true }, { name: "Lambda", noUnits: true, noVector: true }] }, function (x) {
		var val = x[0].toNum().value;
		var Lambda = x[1].toNum().value;
		if (Lambda <= 0) {
			throw "MSG: Lambda must be greater than 0."
		}

		return new Material(jStat.poisson.cdf(val, Lambda));
	});

	defineFunction("PMFPoisson", { params: [{ name: "x", noUnits: true, noVector: true }, { name: "Lambda", noUnits: true, noVector: true }] }, function (x) {
		var val = x[0].toNum().value;
		var Lambda = x[1].toNum().value;
		if (Lambda <= 0) {
			throw "MSG: Rate must be greater than 0."
		}

		return new Material(jStat.poisson.pdf(val, Lambda));
	});



	/* End Statistics */



	defineFunction("SetRandSeed", { params: [{ name: "Seed Number", noUnits: true, noVector: true }] }, function (x) {
		Math.seedrandom(x[0].toNum().value);
		return "Random Seed Set";
	});

	defineFunction("Alert", { params: [{ name: "Message", allowString: true, allowBoolean: true }] }, function (x) {
		alert(x[0]);
		return 1;
	});

	defineFunction("Console", { params: [{ name: "Message", allowString: true, allowBoolean: true }] }, function (x) {
		console.log(x[0]);
		return 1;
	});

	defineFunction("Prompt", { params: [{ name: "Message", allowString: true, allowBoolean: true }, { name: "Default", defaultVal: "", allowString: true, allowBoolean: true }] }, function (x) {
		var y = x[1];
		if ((y instanceof Material) && !y.units) {
			y = y.value;
		}
		var x = prompt(x[0], y);
		if (parseFloat(x).toString() == x) {
			return new Material(parseFloat(x));
		} else {
			return x;
		}
	});

	defineFunction("Confirm", { params: [{ name: "Message", allowString: true, allowBoolean: true }] }, function (x) {
		return confirm(x[0]);
	});

	defineFunction("Parse", { object: StringObject, params: [{ name: "String", allowString: true }] }, function (x) {
		//if((typeof x[0] == "string") || (x[0] instanceof String)){
		return new Material(parseFloat(x[0], 10));
		//}else{
		//return x[0];
		//}
	});

	defineFunction("Split", { object: StringObject, params: [{ name: "String", needString: true }, { name: "Splitter", needString: true }] }, function (x) {
		return s(new Vector(x[0].split(x[1])));
	});

	defineFunction("Join", { object: VectorObject, params: [{ name: "String", needVector: true }, { name: "Joiner", needString: true }] }, function (x) {
		return s(x[0].items.join(x[1]));
	});

	defineFunction("Trim", { object: StringObject, params: [{ name: "String", needString: true }], recurse: true }, function (x) {
		return s(x[0].trim());
	});

	defineFunction("Range", { object: StringObject, params: [{ name: "String", needString: true }, { name: "Indexes", noUnits: true, allowVector: true }] }, function (x) {
		if (x[1] instanceof Vector) {
			var res = "";
			for (var i = 0; i < x[1].items.length; i++) {
				res += x[0].charAt(x[1].items[i].toNum().value - 1);
			}
			return s(res);
		} else {
			return s(x[0].charAt(x[1].toNum().value - 1));
		}
	});

	defineFunction("Length", { object: StringObject, params: [{ name: "String", needString: true }] }, function (x) {
		return new Material(x[0].length);
	});

	defineFunction("IndexOf", { object: StringObject, params: [{ name: "Haystack", needString: true }, { name: "Needle", needString: true }] }, function (x) {
		return new Material(x[0].indexOf(x[1]) + 1);
	});

	defineFunction("Contains", { object: StringObject, params: [{ name: "Haystack", needString: true }, { name: "Needle", needString: true }] }, function (x) {
		return !eq(StringObject["indexof"](x), new Material(0));
	});

	defineFunction("Lowercase", { object: StringObject, params: [{ name: "String", needString: true }] }, function (x) {
		return s(x[0].toLowerCase());
	});

	defineFunction("Uppercase", { object: StringObject, params: [{ name: "String", needString: true }] }, function (x) {
		return s(x[0].toUpperCase());
	});

	StringBase = makeObjectBase(StringObject);
	VectorBase = makeObjectBase(VectorObject);

});

function s(x) {
	if (x instanceof Vector) {
		return x.recurseApply(s);
	}
	var res = new String(x);
	res.parent = StringBase;
	return res;
}

function makeObjectBase(x) {
	var names = Object.keys(x);
	var items = [];
	for (var i = 0; i < names.length; i++) {
		items.push(objectizeFunction(x[names[i]]));
	}
	var vec = new Vector(items, names);
	vec.parent = undefined;
	return vec;
}


function defineFunction(name, definition, fn) {
	var configs = definition.params;
	var arr = Array.isArray(configs);

	var vectorized = [];

	var requiredLength = configs.length;
	for (var i = 0; i < configs.length; i++) {
		if (configs[i].hasOwnProperty("defaultVal")) {
			requiredLength = i;
			break;
		}
	}

	for (var i = 0; i < configs.length; i++) {
		if (configs[i].vectorize) {
			vectorized.push(i);
			if (configs[i].noVector) {
				throw "MSG: Cannot have a non-vector vectorized parameter. Function '" + name + "', parameter '" + configs[i].name + "'.";
			}
		}
	}




	var fnName;
	if (arr) {
		if (!definition.object) {
			fnName = name + "(" + configs.map(function (x) { return x.name + (x.hasOwnProperty("defaultVal") ? "=" + x.defaultVal.toString() : ""); }).join(", ") + ")";
		} else {
			fnName = name + "(" + configs.slice(1).map(function (x) { return x.name + (x.hasOwnProperty("defaultVal") ? "=" + x.defaultVal.toString() : ""); }).join(", ") + ")";
		}
	} else {
		fnName = name + "(items...)";
	}

	var f = function (x, id) {
		if (definition.prep) {
			x = definition.prep(x);
		}

		if (arr && (x.length > configs.length || x.length < requiredLength)) {
			throw "MSG: Wrong number of parameters for " + fnName + ".";
		} else if ((!arr) && x.length == 0 && (!definition.allowEmpty)) {
			throw "MSG: At least one parameter required for " + name + "().";
		}

		for (var i = 0; i < x.length; i++) {
			var config = arr ? configs[i] : configs;

			if (config.noUnits && (!((!(x[i].toNum() instanceof Material)) || !x[i].toNum().units))) {
				throw "MSG: " + fnName + " does not except units for the argument '" + config.name + "'.";
			}
			if (config.noVector && (x[i] instanceof Vector)) {
				throw "MSG: " + fnName + " does not except vectors for the argument '" + config.name + "'.";
			}
			if (config.vectorize && (x[i] instanceof Vector) && !x[i].names) {
				throw "MSG: " + fnName + " does not accepted non-named vectors for the argument '" + config.name + "'.";
			}
			if (config.needVector) {
				if (x[i] instanceof Primitive) {
					x[i] = x[i].toNum();
				}
				if (!(x[i] instanceof Vector)) {
					throw "MSG: " + fnName + " requires a vector for the argument '" + config.name + "'.";
				}
			}
			if (config.needPrimitive && !(x[i] instanceof Primitive)) {
				throw "MSG: " + fnName + " requires a primitive for the argument '" + config.name + "'.";
			}
			if ((!config.allowBoolean) && (typeof x[i] == "boolean")) {
				throw "MSG: " + fnName + " does not accept boolean values for the argument '" + config.name + "'.";
			}
			if (config.needAgent && (!(x[i] instanceof Agent))) {
				x[i] = agent(x[i], fnName, config.name);
			}
			if (config.needString) {
				if (!((typeof x[i] == "string") || (x[i] instanceof String))) {
					throw "MSG: " + fnName + " requires a string for the argument '" + config.name + "'.";
				}
			}
			if (((!config.allowString) && (!config.needString))
				&& ((typeof x[i] == "string") || (x[i] instanceof String))) {
				throw "MSG: " + fnName + " does not accept string values for the argument '" + config.name + "'.";
			}
			if (config.needAgents && (!(x[i] instanceof Agents))) {
				x[i] = agents(x[i], fnName, config.name);
			}
			if (config.needPopulation && (!(x[i] instanceof Vector))) {
				x[i] = getPopulation(x[i], fnName, config.name);
			}
			if (config.needFunction && (!((x[i] instanceof Function) || (x[i] instanceof UserFunction)))) {
				throw "MSG: " + fnName + " requires a function for the argument '" + config.name + "'.";
			}
		}
		if (definition.recurse) {
			var q = x[0].toNum();
		}
		if (definition.recurse && (q instanceof Vector)) {
			return q.cloneApply(function (z) { return f([z].concat(x.slice(1)), id) });
		} else if (vectorized.length > 0) {
			// Auto-vectorize the inner function


			var base = undefined, baseI = -1;
			for (var i = 0; i < vectorized.length; i++) {
				if (x[vectorized[i]]) {
					var v = x[vectorized[i]].toNum();
					if ((v instanceof Vector) && (v.namesLC)) {
						if (!base) {
							base = v;
							baseI = vectorized[i];
						} else {
							if (!base.keysMatch(v.namesLC)) {
								throw "MSG: Vector keys do not match between parameters '" + configs[baseI].name + "' and '" + configs[vectorized[i]].name + "' in " + fnName + ".";
							}
						}
					}
				}
			}

			if (!base) {
				// Nothing is vectorized, we can behave normally
				return fn(x, id);
			} else {
				// We need to vectorize
				//console.log("getting facney!")
				var keys = base.namesLC;
				var res = [];
				for (var i = 0; i < keys.length; i++) {
					var newX = [];
					for (var j = 0; j < x.length; j++) {
						if (vectorized.indexOf(j) == -1) {
							newX.push(x[j]);
						} else {
							var v = x[j].toNum();
							if ((v instanceof Vector) && (v.namesLC)) {
								newX.push(v.select([keys[i]]));
							} else {
								newX.push(v);
							}

						}
					}
					//console.log(newX);
					var z = fn(newX, id);
					if (z instanceof Vector) {
						if (!base.keysMatch(z.namesLC)) {
							throw "MSG: Vector keys do not match between parameter '" + configs[baseI].name + "' and calculation result.";
						}

						res.push(z.select([keys[i]]));
					} else {
						res.push(z);
					}
				}
				return new Vector(res, keys);
			}


		} else {
			return fn(x, id);
		}
	}

	if (!definition.object) {
		functionBank[name.toLowerCase()] = f;
	} else {
		if (definition.object instanceof Array) {
			for (var i = 0; i < definition.object.length; i++) {
				definition.object[i][name.toLowerCase()] = f;
			}
		} else {
			definition.object[name.toLowerCase()] = f;
		}
	}

	if (definition.recurse) {
		VectorObject[name.toLowerCase()] = f;
	}
}

function objectizeFunction(fn) {
	var f = function (x, fingerprint, lastSelf) {
		return fn([lastSelf].concat(x), fingerprint, lastSelf)
	}
	f.delayEvalParams = fn.delayEvalParams;
	return f;
}

function factorial(x) {
	if (Math.round(x) != x) {
		throw "MSG: The factorial() function only accepts integers.";
	} else if (x < 0) {
		throw "MSG: The factorial() function is only defined for integers 0 or larger.";
	}
	if (x > 1) {
		return x * factorial(x - 1);
	} else {
		return 1;
	}
}

function testArgumentsSize(x, name, min, max) {
	if (x.length < min || x.length > max) {
		throw "MSG: Wrong number of parameters for " + name + "()."
	}
}


"use strict";

/* 
Third party: http://www.crockford.com/javascript/inheritance.html
*/

Function.prototype.method = function (name, func) {
    this.prototype[name] = func;
    return this;
};


Function.method('inherits', function (parent) {
    var d = {}, p = (this.prototype = new parent());
    this.method('uber', function uber(name) {
        if (!(name in d)) {
            d[name] = 0;
        }        
        var f, r, t = d[name], v = parent.prototype;
        if (t) {
            while (t) {
                v = v.constructor.prototype;
                t -= 1;
            }
            f = v[name];
        } else {
            f = p[name];
            if (f == this[name]) {
                f = v[name];
            }
        }
        d[name] += 1;
        r = f.apply(this, Array.prototype.slice.apply(arguments, [1]));
        d[name] -= 1;
        return r;
    });
    return this;
});

"use strict";
/*

Copyright 2010-2020 Scott Fortmann-Roe. All rights reserved.

This file may distributed and/or modified under the
terms of the Insight Maker Public License (https://InsightMaker.com/impl).

*/


var AgentBase;
var AgentObject = {};

var PrimitiveBase;
var PrimitiveObject = {};

functionLoaders.push(function () {


	defineFunction("Stop", { params: [] }, function (x) {
		throw {
			msg: "STOP"
		};
	});

	defineFunction("Pause", { params: [] }, function (x) {
		simulate.sleep(true);
		return new Material(0);
	});

	defineFunction("Time", { params: [] }, function (x) {
		return simulate.time().fullClone();
	});

	defineFunction("TimeStep", { params: [] }, function (x) {
		return simulate.timeStep.fullClone();
	});

	defineFunction("TimeLength", { params: [] }, function (x) {
		return simulate.timeLength.fullClone();
	});

	defineFunction("TimeStart", { params: [] }, function (x) {
		return simulate.timeStart.fullClone();
	});

	defineFunction("TimeEnd", { params: [] }, function (x) {
		return simulate.timeEnd.fullClone();
	});

	defineFunction("Seconds", { params: [{ name: "Value", defaultVal: "time", vectorize: true }] }, function (x) {
		var item;
		if (x.length == 0) {
			item = simulate.time().fullClone();
		} else {
			item = x[0].toNum();
		}
		return mult(item, new Material(1, getUnitStore(["seconds"], [-1])));
	});

	defineFunction("Minutes", { params: [{ name: "Value", defaultVal: "time", vectorize: true }] }, function (x) {
		var item;
		if (x.length == 0) {
			item = simulate.time().fullClone();
		} else {
			item = x[0].toNum();
		}
		return mult(item, new Material(1, getUnitStore(["minutes"], [-1])));
	});

	defineFunction("Hours", { params: [{ name: "Value", defaultVal: "time", vectorize: true }] }, function (x) {
		var item;
		if (x.length == 0) {
			item = simulate.time().fullClone();
		} else {
			item = x[0].toNum();
		}
		return mult(item, new Material(1, getUnitStore(["hours"], [-1])));
	});

	defineFunction("Days", { params: [{ name: "Value", defaultVal: "time", vectorize: true }] }, function (x) {
		var item;
		if (x.length == 0) {
			item = simulate.time().fullClone();
		} else {
			item = x[0].toNum();
		}
		return mult(item, new Material(1, getUnitStore(["days"], [-1])));
	});

	defineFunction("Weeks", { params: [{ name: "Value", defaultVal: "time", vectorize: true }] }, function (x) {
		var item;
		if (x.length == 0) {
			item = simulate.time().fullClone();
		} else {
			item = x[0].toNum();
		}
		return mult(item, new Material(1, getUnitStore(["weeks"], [-1])));
	});

	defineFunction("Months", { params: [{ name: "Value", defaultVal: "time", vectorize: true }] }, function (x) {
		var item;
		if (x.length == 0) {
			item = simulate.time().fullClone();
		} else {
			item = x[0].toNum();
		}
		return mult(item, new Material(1, getUnitStore(["months"], [-1])));
	});

	defineFunction("Years", { params: [{ name: "Value", defaultVal: "time", vectorize: true }] }, function (x) {
		var item;
		if (x.length == 0) {
			item = simulate.time().fullClone();
		} else {
			item = x[0].toNum();
		}
		return mult(item, new Material(1, getUnitStore(["years"], [-1])));
	});

	defineFunction("Seasonal", { params: [{ name: "Peak", defaultVal: "0", vectorize: true }] }, function (x) {
		var peak;
		if (x.length == 0) {
			peak = new Material(0, simulate.timeUnits);
		} else {
			peak = x[0].fullClone();
			if (!peak.units) {
				peak.units = simulate.timeUnits;
			}
		}
		var position = minus(functionBank["time"]([]), peak);
		var dist = position.forceUnits(createUnitStore("years")).value * 2 * 3.14159265359;
		return new Material(Math.cos(dist));
	});

	defineFunction("Unitless", { params: [{ name: "Value", noVector: true }] }, function (x) {
		return new Material(x[0].toNum().value);
	});

	defineFunction("PastMean", { object: [functionBank, PrimitiveObject], params: [{ name: "[Primitive]", noVector: true, needPrimitive: true }, { name: "Past Range", defaultVal: "All Time", vectorize: true }] }, function (x) {
		if (x.length == 1) {
			return functionBank["mean"](x[0].getPastValues());
		} else {
			return functionBank["mean"](x[0].getPastValues(x[1].toNum()));
		}
	});

	defineFunction("PastMedian", { object: [functionBank, PrimitiveObject], params: [{ name: "[Primitive]", noVector: true, needPrimitive: true }, { name: "Past Range", defaultVal: "All Time", vectorize: true }] }, function (x) {

		if (x.length == 1) {
			return functionBank["median"](x[0].getPastValues());
		} else {
			return functionBank["median"](x[0].getPastValues(x[1].toNum()));
		}
	});

	defineFunction("PastValues", { object: [functionBank, PrimitiveObject], params: [{ name: "[Primitive]", noVector: true, needPrimitive: true }, { name: "Past Range", defaultVal: "All Time", vectorize: true }] }, function (x) {

		var items;
		if (x.length == 1) {
			items = x[0].getPastValues();
		} else {
			items = x[0].getPastValues(x[1].toNum());
		}
		return new Vector(items);
	});

	defineFunction("PastStdDev", { object: [functionBank, PrimitiveObject], params: [{ name: "[Primitive]", noVector: true, needPrimitive: true }, { name: "Past Range", defaultVal: "All Time", vectorize: true }] }, function (x) {

		var items;
		if (x.length == 1) {
			items = x[0].getPastValues();
		} else {
			items = x[0].getPastValues(x[1].toNum());
		}
		if (items.length > 1) {
			return functionBank["stddev"](items);
		} else {
			return new Material(0);
		}
	});

	defineFunction("PastCorrelation", { params: [{ name: "[Primitive]", noVector: true, needPrimitive: true }, { name: "[Primitive]", noVector: true, needPrimitive: true, object: [functionBank, PrimitiveObject] }, { name: "Past Range", vectorize: true, defaultVal: "All Time" }] }, function (x) {
		var items1;
		var items2;
		if (x[2] != "All Time") {
			items1 = x[0].getPastValues();
			items2 = x[1].getPastValues();
		} else {
			items1 = x[0].getPastValues(x[2].toNum());
			items2 = x[1].getPastValues(x[2].toNum());
		}

		if (items1.length > 1) {
			return functionBank["correlation"]([new Vector(items1), new Vector(items2)]);
		} else {
			return new Material(0);
		}
	});

	defineFunction("PastMax", { object: [functionBank, PrimitiveObject], params: [{ name: "[Primitive]", noVector: true, needPrimitive: true }, { name: "Past Range", defaultVal: "All Time", vectorize: true }] }, function (x) {

		if (x.length == 1) {
			return functionBank["max"](x[0].getPastValues());
		} else {
			return functionBank["max"](x[0].getPastValues(x[1].toNum()));
		}
	});

	defineFunction("PastMin", { object: [functionBank, PrimitiveObject], params: [{ name: "[Primitive]", noVector: true, needPrimitive: true }, { name: "Past Range", defaultVal: "All Time", vectorize: true }] }, function (x) {

		if (x.length == 1) {
			return functionBank["min"](x[0].getPastValues());
		} else {
			return functionBank["min"](x[0].getPastValues(x[1].toNum()));
		}
	});

	defineFunction("Pulse", { params: [{ name: "Start Time", vectorize: true }, { name: "Height", vectorize: true, defaultVal: 1 }, { name: "Width", vectorize: true, defaultVal: 0 }, { name: "Repeat Period", vectorize: true, defaultVal: 0 }] }, function (x) {

		var start = x[0].toNum();
		var height = new Material(1);
		var width = new Material(0);
		var repeat = new Material(0);

		if (x.length > 1) {
			height = x[1].toNum();
			if (x.length > 2) {
				width = x[2].toNum();
				if (x.length > 3) {
					repeat = x[3].toNum();
				}
			}
		}
		if (!start.units) {
			start.units = simulate.timeUnits;
		}
		if (!width.units) {
			width.units = simulate.timeUnits;
		}
		if (!repeat.units) {
			repeat.units = simulate.timeUnits;
		}

		if (repeat.value <= 0) {
			if (eq(simulate.time(), start) || greaterThanEq(simulate.time(), start) && lessThanEq(simulate.time(), plus(start, width))) {
				return height;
			}
		} else if (greaterThanEq(simulate.time(), start)) {
			var x = minus(simulate.time(), mult(functionBank["floor"]([div(minus(simulate.time(), start), repeat)]), repeat));
			var dv = minus(simulate.time(), start);
			if (minus(functionBank["round"]([div(dv, repeat)]), div(dv, repeat)).value == 0 || (greaterThanEq(x, start) && lessThanEq(x, plus(start, width)))) {
				return height;
			}
		}
		return new Material(0, height.units);
	});

	defineFunction("Ramp", { params: [{ name: "Start Time", vectorize: true }, { name: "Finish Time", vectorize: true }, { name: "Height", vectorize: true, defaultVal: 1 }] }, function (x) {

		var start = x[0].toNum();
		var finish = x[1].toNum();
		var height = new Material(1);
		if (x.length == 3) {
			height = x[2].toNum();
		}
		if (!start.units) {
			start.units = simulate.timeUnits;
		}
		if (!finish.units) {
			finish.units = simulate.timeUnits;
		}
		if (greaterThanEq(simulate.time(), start)) {
			var q = div(mult(functionBank["min"]([minus(finish, start), minus(simulate.time(), start)]), height), minus(finish, start));
			//console.log(q);
			return q;
		}
		return new Material(0, height.units);
	});

	defineFunction("Step", { params: [{ name: "Start Time", vectorize: true }, { name: "Height", vectorize: true, defaultVal: 1 }] }, function (x) {


		var start = x[0].toNum();
		var height = new Material(1);
		if (x.length == 2) {
			height = x[1].toNum();
		}
		if (!start.units) {
			start.units = simulate.timeUnits;
		}

		if (greaterThanEq(simulate.time(), start)) {
			return height;
		}

		return new Material(0, height.units);

	});
	functionBank["staircase"] = functionBank["step"];

	defineFunction("Smooth", { object: [functionBank, PrimitiveObject], params: [{ name: "[Primitive]", noVector: true, needPrimitive: true }, { name: "Period", vectorize: true }, { name: "Initial Value", vectorize: true, defaultVal: "None" }] }, function (x) {

		if (x[1].toNum().value <= 0) {
			throw "MSG: The smoothing period must be greater than 0.";
		}


		if (x.length == 2) {
			return x[0].smoothF(x[1].toNum());
		} else {
			return x[0].smoothF(x[1].toNum(), x[2].toNum()); //With default value
		}
	});

	defineFunction("Delay", { object: [functionBank, PrimitiveObject], params: [{ name: "[Primitive]", noVector: true, needPrimitive: true }, { name: "Delay", vectorize: true }, { name: "Initial Value", defaultVal: "None", vectorize: true }] }, function (x) {

		if (x[1].toNum().value < 0) {
			throw "MSG: The delay must be greater than or equal to 0.";
		}
		if (x.length == 2) {
			return x[0].pastValue(x[1].toNum());
		} else {
			return x[0].pastValue(x[1].toNum(), x[2].toNum()); //With default value
		}
	});


	defineFunction("Delay1", { object: [functionBank, PrimitiveObject], params: [{ name: "[Primitive]", noVector: true, needPrimitive: true }, { name: "Delay", vectorize: true }, { name: "Initial Value", vectorize: true, defaultVal: "None" }] }, function (x) {

		if (x[1].toNum().value <= 0) {
			throw "MSG: The delay must be greater than 0.";
		}


		if (x.length == 2) {
			return x[0].expDelayF(1, x[1].toNum());
		} else {
			return x[0].expDelayF(1, x[1].toNum(), x[2].toNum()); //With default value
		}
	});

	defineFunction("Delay3", { object: [functionBank, PrimitiveObject], params: [{ name: "[Primitive]", noVector: true, needPrimitive: true }, { name: "Delay", vectorize: true }, { name: "Initial Value", vectorize: true, defaultVal: "None" }] }, function (x) {

		if (x[1].toNum().value <= 0) {
			throw "MSG: The delay must be greater than 0.";
		}


		if (x.length == 2) {
			return x[0].expDelayF(3, x[1].toNum());
		} else {
			return x[0].expDelayF(3, x[1].toNum(), x[2].toNum()); //With default value
		}
	});



	functionBank["fix"] = function (x, id) {
		testArgumentsSize(x, "Fix", 1, 2);
		var spacing = -1;
		if (x.length == 2) {
			spacing = evaluateNode(x[1].node, x[1].scope).toNum();
		}

		var mySeries = null;
		for (var i = 0; i < simulate.oldAggregateSeries.length; i++) {
			if (simulate.oldAggregateSeries[i].match(id)) {
				mySeries = simulate.oldAggregateSeries[i];
				break;
			}
		}

		if (mySeries === null) {
			mySeries = new AggregateSeries(id, spacing);
			simulate.oldAggregateSeries.push(mySeries);
		}

		return mySeries.get(x[0]);
	};
	functionBank["fix"].delayEvalParams = true;


	functionBank["populationsize"] = function (x) {
		testArgumentsSize(x, "PopulationSize", 1, 1);
		if (x[0] instanceof Agents) {
			return new Material(sn("#e" + x[0].agents.length));
		}
		throw "MSG: PopulationSize must be passed an agent population as an argument.";
	}
	PrimitiveObject["populationsize"] = functionBank["populationsize"];

	defineFunction("Remove", { object: [functionBank, AgentObject], params: [{ needAgent: true, name: "[Agent]" }] }, function (x) {
		//console.log(x[0]);
		if (x[0].dead) {
			throw "MSG: Cannot remove an already removed agent.";
		}

		simulate.tasks.add(new Task({
			time: simulate.time(),
			priority: 10,
			expires: 1,
			name: "Remove Agent",
			action: function () {
				x[0].die();
			}
		}))


		return new Material(1);
	});

	defineFunction("Add", { object: [functionBank, PrimitiveObject], params: [{ name: "[Agent Population]" }, { needAgent: true, name: "[Base]", defaultVal: "Agent Base" }] }, function (x) {

		while ((!(x[0] instanceof Agents)) && x[0].container != null) {
			x[0] = x[0].container;
		}
		if (!(x[0] instanceof Agents)) {
			throw "MSG: You must pass an agent population as the first argument to Add().";
		}
		if (x.length == 2) {
			return x[0].add(x[1]);
		} else {
			return x[0].add();
		}
	});

	defineFunction("FindAll", { object: [functionBank, VectorObject, PrimitiveObject], params: [{ needPopulation: true, name: "[Agent Population]" }] }, function (x) {
		return x[0];
	});

	defineFunction("ResetTimer", { object: [functionBank, PrimitiveObject], params: [{ needPrimitive: true, name: "[Action]" }] }, function (x) {
		if (!(x[0] instanceof Action)) {
			throw "MSG: ResetTimer requires an Action primitive.";
		}
		x[0].resetTimer();
		return new Material(0);
	});

	defineFunction("Transition", { object: [functionBank, PrimitiveObject], params: [{ needPrimitive: true, name: "[Transition]" }] }, function (x) {
		if (!(x[0] instanceof Transition)) {
			throw "MSG: Transition requires an Transition primitive.";
		}
		x[0].doTransition()
		return new Material(0);
	});

	defineFunction("Value", { object: [functionBank, VectorObject, AgentObject], params: [{ name: "[Population]" }, { needPrimitive: true, name: "[Primitive]" }] }, function (x) {//need population should be false

		var id = x[1].id;

		//console.log("v:");
		var population = null;
		//sdsadas

		if (!((x[0] instanceof Agents) || (x[0] instanceof Agent) || (x[0] instanceof Vector) || (!x[0]))) {
			x[0] = x[0].toNum();
		}

		if (x[0] instanceof Agents) {
			population = getPopulation(x[0]);
		}

		if (x[0] instanceof Vector) {
			population = x[0];
		}
		if (population !== null) {
			var res = [];
			var q = -1;
			for (var i = 0; i < population.items.length; i++) {
				if (q != -1) {
					res.push(population.items[i].children[q]);
				} else {
					for (var j = 0; j < population.items[i].children.length; j++) {
						if (population.items[i].children[j].id == id) {
							res.push(population.items[i].children[j]);
							q = j;
							break;
						}
					}
				}
			}

			return new Vector(res);
		} else if (x[0] instanceof Agent) {
			//console.log(x[0].index);
			//console.log(id);
			for (var j = 0; j < x[0].children.length; j++) {
				if (x[0].children[j].id == id) {
					//console.log(id+"-"+x[0].children[j].value().toString())
					return x[0].children[j];
				}
			}
			throw "MSG: Could not find referenced primitive for \"Value()\".";
		}
		throw "MSG: Invalid type for the first argument of \"Value()\".";
	});

	defineFunction("SetValue", { object: [functionBank, VectorObject, PrimitiveObject, AgentObject], params: [{ name: "[Population]" }, { needPrimitive: true, name: "[Primitive]" }, { name: "Value", noVector: true, allowBoolean: true }] }, function (x) {//need population should be false
		var id = x[1].id;

		//console.log("v:");
		var population = null;

		if (x[0] instanceof Agents) {
			population = getPopulation(x[0]);
		}
		if (x[0] instanceof Vector) {
			population = x[0];
		}
		if (population !== null) {
			var res = [];
			for (var i = 0; i < population.length(); i++) {
				for (var j = 0; j < population.items[i].children.length; j++) {
					if (population.items[i].children[j].id == id) {
						population.items[i].children[j].setValue(x[2]);
					}
				}
			}
			return new Material(1);
		} else if (x[0] instanceof Agent) {
			//console.log(x[0].index);
			//console.log(id);
			for (var j = 0; j < x[0].children.length; j++) {
				if (x[0].children[j].id == id) {
					//console.log(id+"-"+x[0].children[j].value().toString())
					x[0].children[j].setValue(x[2]);
					return new Material(1);
				}
			}
			throw "MSG: Could not find referenced primitive for \"SetValue()\".";
		}
		throw "MSG: Invalid type for the first argument of \"SetValue()\".";
	});

	defineFunction("FindIndex", { object: [functionBank, VectorObject, PrimitiveObject], params: [{ needPopulation: true, name: "[Agent Population]" }, { name: "Index", noVector: true, noUnits: true }] }, function (x) {
		var population = x[0];
		//console.log("hi")
		for (var i = 0; i < population.length(); i++) {
			if (population.items[i].index + 1 == x[1].value) {
				return population.items[i];
			}
		}

		//	debugger;

		throw "MSG: Index not found in population."
	});

	defineFunction("FindState", { object: [functionBank, VectorObject, PrimitiveObject], params: [{ needPopulation: true, name: "[Agent Population]" }, { needPrimitive: true, name: "[State]" }] }, function (x) {

		var population = x[0];

		if (!((x[1] instanceof State) || (x[1].dna.type === "State"))) {
			throw "MSG: FindState() requires a State primitive as its argument.";
		}

		var id = x[1].id;
		var res = [];

		for (var i = 0; i < population.items.length; i++) {
			if (population.items[i].stateIDs.indexOf(id) !== -1) {
				res.push(population.items[i]);
			}
		}

		return new Vector(res);
	});

	defineFunction("FindNotState", { object: [functionBank, VectorObject, PrimitiveObject], params: [{ needPopulation: true, name: "[Agent Population]" }, { needPrimitive: true, name: "[State]" }] }, function (x) {

		var population = x[0];
		if (!((x[1] instanceof State) || (x[1].dna.type === "State"))) {
			throw "MSG: FindNotState() requires a State primitive as its argument.";
		}

		var id = x[1].id;
		var res = [];

		for (var i = 0; i < population.items.length; i++) {
			if (population.items[i].stateIDs.indexOf(id) === -1) {
				res.push(population.items[i]);
			}
		}

		return new Vector(res);
	});

	defineFunction("FindNearby", { object: [functionBank, VectorObject, PrimitiveObject], params: [{ needPopulation: true, name: "[Agent Population]" }, { name: "Target" }, { name: "Distance Limit", noVector: true }] }, function (x) {
		var population = x[0];

		var loc = locationValue(x[1]);

		try {
			var a = agent(x[1]);
		} catch (err) {
		}


		var res = [];
		for (var i = 0; i < population.length(); i++) {
			var item = agent(population.items[i]);
			if (item !== a) {
				if (lessThanEq(distance(loc, item), x[2])) {
					res.push(item);
				}
			}
		}
		return new Vector(res);
	});

	defineFunction("FindNearest", { object: [functionBank, VectorObject, PrimitiveObject], params: [{ needPopulation: true, name: "[Agent Population]" }, { name: "Target" }, { noUnits: true, noVector: true, defaultVal: 1, name: "Count" }] }, function (x) {
		var population = x[0];
		var count = 1;

		if (x.length == 3) {
			count = x[2].value;

			if (count < 1) {
				throw "MSG: You must select at least one agent in FindNearest().";
			}
			if (count != Math.floor(count)) {
				throw "MSG: Count must be an integer."
			}
		}


		var loc = locationValue(x[1]);
		try {
			var a = agent(x[1]);
		} catch (err) {
		}


		var res = [];
		for (var i = 0; i < population.items.length; i++) {
			var item = agent(population.items[i]);
			if (item !== a) {
				res.push({ distance: distance(loc, item), item: item });
			}
		}

		if (res.length < count) {
			throw "MSG: Can't find nearest " + count + " agents of a population of size " + res.length + ".";
		}


		var minItems = [res[0]];
		for (var i = 1; i < res.length; i++) {
			var added = false;
			for (var j = 0; j < minItems.length; j++) {
				if (lessThan(res[i].distance, minItems[j].distance)) {
					minItems.splice(j, 0, res[i])
					added = true;
					break;
				}
			}
			if ((!added) && minItems.length < count) {
				minItems.push(res[i]);
			} else if (minItems.length > count) {
				minItems.length = count;
			}
		}

		if (minItems.length === 1) {
			return minItems[0].item;
		} else {
			minItems.sort(function (a, b) {
				return a.distance - b.distance;
			});
			return new Vector(minItems.map(function (x) { return x.item }));
		}
	});


	defineFunction("FindFurthest", { object: [functionBank, VectorObject, PrimitiveObject], params: [{ needPopulation: true, name: "[Agent Population]" }, { name: "Target" }, { noUnits: true, noVector: true, defaultVal: 1, name: "Count" }] }, function (x) {

		var population = x[0];

		var count = 1;
		if (x.length === 3) {
			count = x[2].value;

			if (count < 1) {
				throw "MSG: You must select at least one agent in FindFurthest().";
			}
			if (count != Math.floor(count)) {
				throw "MSG: Count must be an integer."
			}
		}



		var loc = locationValue(x[1]);
		try {
			var a = agent(x[1]);
		} catch (err) {
		}


		var res = [];
		for (var i = 0; i < population.items.length; i++) {
			var item = agent(population.items[i]);
			if (item !== a) {
				res.push({ distance: distance(loc, item), item: item });
			}
		}

		if (res.length < count) {
			throw "MSG: Can't find furthest " + count + " agents of a population of size " + res.length + ".";
		}

		var minItems = [res[0]];
		for (var i = 1; i < res.length; i++) {
			var added = false;
			for (var j = 0; j < minItems.length; j++) {
				if (greaterThan(res[i].distance, minItems[j].distance)) {
					minItems.splice(j, 0, res[i])
					added = true;
					break;
				}
			}
			if ((!added) && minItems.length < count) {
				minItems.push(res[i]);
			} else if (minItems.length > count) {
				minItems.length = count;
			}
		}

		if (minItems.length === 1) {
			return minItems[0].item;
		} else {
			minItems.sort(function (a, b) {
				return b.distance - a.distance;
			});
			return new Vector(minItems.map(function (x) { return x.item }));
		}
	});

	defineFunction("Index", { object: [functionBank, AgentObject], params: [{ noVector: true, needAgent: true, name: "[Agent]" }] }, function (x) {
		//console.log("--")
		//console.log(x);
		//die
		return new Material(sn("#e" + (x[0].index + 1)));
	});

	defineFunction("Connect", { object: [functionBank, AgentObject], params: [{ needAgent: true, name: "[Agent 1]" }, { name: "[Agent 2]" }, { name: "Weight", defaultVal: "missing" }] }, function (x) {

		var weight = undefined;
		if (x[2] != "missing") {
			weight = x[2];
		}

		if (x[1] instanceof Vector) {
			x[1].items.forEach(function (a) {
				x[0].connect(a, weight);
			});
		} else {
			x[0].connect(x[1], weight);
		}
		return new Material(1);
	});

	defineFunction("Unconnect", { object: [functionBank, AgentObject], params: [{ needAgent: true, name: "[Agent 1]" }, { name: "[Agent 2]" }] }, function (x) {
		if (x[1] instanceof Vector) {
			x[1].items.forEach(function (a) {
				x[0].unconnect(a);
			});
		} else {
			x[0].unconnect(x[1]);
		}
		return new Material(1);
	});

	defineFunction("Connected", { object: [functionBank, AgentObject], params: [{ needAgent: true, name: "[Agent]" }] }, function (x) {
		return new Vector(x[0].connected.slice());
	});

	defineFunction("ConnectionWeight", { object: [functionBank, AgentObject], params: [{ needAgent: true, name: "[Agent 1]" }, { name: "[Agent 2]" }] }, function (x) {
		if (x[1] instanceof Vector) {
			return new Vector(x[1].items.map(function (a) {
				return x[0].connectionWeight(a);
			}));
		} else {
			return x[0].connectionWeight(x[1]);
		}
	});

	defineFunction("SetConnectionWeight", { object: [functionBank, AgentObject], params: [{ needAgent: true, name: "[Agent 1]" }, { name: "[Agent 2]" }, { name: "Weight" }] }, function (x) {
		if (x[1] instanceof Vector) {
			x[1].items.forEach(function (a) {
				x[0].setConnectionWeight(a, x[2]);
			});
		} else {
			x[0].setConnectionWeight(x[1], x[2]);
		}
		return new Material(1);
	});

	functionBank["die"] = function (x) {
		console.log(x);
		throw "MSG: Terminated using \"die\".";
	}

	functionBank["print"] = function (x) {

		if (x.length == 2) {
			console.log(x[0].value.toString());
			console.log(x[1]);
			return x[1];
		} else {
			console.log(x[0]);
			return x[0];
		}
	}

	defineFunction("Width", { params: [{ needAgents: true, name: "[Agent Population]" }] }, function (x) {
		return x[0].geoWidth;
	});

	defineFunction("Height", { params: [{ needAgents: true, name: "[Agent Population]" }] }, function (x) {
		return x[0].geoHeight;
	});

	defineFunction("Distance", { object: [functionBank, AgentObject], params: [{ name: "Location 1" }, { name: "Location 2" }] }, function (x) {
		x[0] = locationValue(x[0]);
		x[1] = locationValue(x[1]);

		return distance(x[0], x[1]);
	});



	defineFunction("Location", { object: [functionBank, AgentObject], params: [{ needAgent: true, name: "[Agent]" }] }, function (x) {
		if (!x[0].location) {
			throw "MSG: The location is not defined."
		} else {
			return x[0].location.fullClone();
		}
	});

	defineFunction("SetLocation", { object: [functionBank, AgentObject], params: [{ needAgent: true, name: "[Agent]" }, { needVector: true, name: "Direction" }] }, function (x) {
		var v = x[1].toNum();
		var agent = x[0];
		agent.location = v.fullClone();
		if (!agent.location.names) {
			agent.location.names = ["x", "y"];
			agent.location.namesLC = ["x", "y"];
		}
		return new Material(0);
	});

	defineFunction("Move", { object: [functionBank, AgentObject], params: [{ needAgent: true, name: "[Mover]" }, { needVector: true, name: "Direction" }] }, function (x) {

		var v = x[1].toNum();
		shiftLocation(x[0], plus(x[0].location, v));
		return new Material(0);
	});

	function locationValue(x) {
		if (x instanceof Vector) {
			if (x.items.length != 2) {
				throw "MSG: Location vector does not contain exactly two elements."
			}
			else {
				return x;
			}
		} else {
			try {
				return agent(x).location;
			} catch (err) {
				throw "MSG: Location must be a vector or an agent.";
			}
		}
	}

	defineFunction("MoveTowards", { object: [functionBank, AgentObject], params: [{ needAgent: true, name: "[Mover]" }, { name: "[Target]" }, { name: "Distance", noVector: true }] }, function (x) {
		var a = x[0];

		var l1 = locationValue(x[1]);
		var l2 = a.location;

		var distx = minus(l1.items[0], l2.items[0]);
		var disty = minus(l1.items[1], l2.items[1]);

		if (distx.value == 0 && disty.value == 0) {
			return new Material(1);
		}


		if (a.container.geoWrap) {

			if (greaterThan(distx, a.container.halfWidth)) {
				distx = minus(a.container.geoWidth, distx)
			} else if (lessThan(distx, negate(a.container.halfWidth))) {
				distx = minus(distx, negate(a.container.geoWidth))
			}
			if (greaterThan(disty, a.container.halfHeight)) {
				disty = minus(a.container.geoHeight, disty)
			} else if (lessThan(disty, negate(a.container.halfHeight))) {
				disty = minus(disty, negate(a.container.geoHeight))
			}
		}

		var dir = new Vector([distx, disty], ["x", "y"])

		shiftLocation(x[0], plus(x[0].location, mult(dir, div(x[2], distance(x[0], (x[1] instanceof Vector) ? x[1] : agent(x[1]))))));

		return new Material(1);
	});

	PrimitiveBase = makeObjectBase(PrimitiveObject);

	AgentBase = makeObjectBase(AgentObject);

	PrimitiveBase.parent = AgentBase;

	VectorBase = makeObjectBase(VectorObject);

});


function distance(a, b) {
	var l1 = (a instanceof Vector) ? a : a.location;
	var l2 = (b instanceof Vector) ? b : b.location;
	//console.log(a)
	//console.log(b)

	var s1 = l1.items[0].toString() + "," + l1.items[1].toString();
	var s2 = l2.items[0].toString() + "," + l2.items[1].toString();
	if (simulate.distanceCache[s1 + "-" + s2]) {
		return simulate.distanceCache[s1 + "-" + s2];
	} else if (simulate.distanceCache[s2 + "-" + s1]) {
		return simulate.distanceCache[s2 + "-" + s1];
	}
	var distx = minus(l1.items[0], l2.items[0]);
	var disty = minus(l1.items[1], l2.items[1]);

	var agents = null;
	if (!(a instanceof Vector)) {
		agents = a.container;
	} else if (!(b instanceof Vector)) {
		agents = b.container;
	}
	if (agents !== null && agents.geoWrap) {
		if (greaterThan(distx, agents.halfWidth)) {
			distx = minus(agents.geoWidth, distx)
		} else if (lessThan(distx, negate(agents.halfWidth))) {
			distx = minus(distx, negate(agents.geoWidth))
		}
		if (greaterThan(disty, agents.halfHeight)) {
			disty = minus(agents.geoHeight, disty)
		} else if (lessThan(disty, negate(agents.halfHeight))) {
			disty = minus(disty, negate(agents.geoHeight))
		}
	}

	var v1 = distx.value;
	var v2 = disty.value;

	if (distx.units !== disty.units) {
		v2 = fn["*"](v2, convertUnits(distx.units, disty.units));
	}

	var dist = fn["real-part"](fn["sqrt"](fn["+"](fn["*"](v1, v1), fn["*"](v2, v2))));
	dist = new Material(dist, distx.units);
	simulate.distanceCache[s1 + s2] = dist;
	return dist;
	//var dist = functionBank["sqrt"]([plus( power(distx, (new Material(2))), power(disty, (new Material(2))) )])

	//dist.value = fn["real-part"](dist.value);
	//return dist;
}

function agent(obj) {
	if ((obj instanceof Variable) || (obj instanceof Stock)) {
		obj = obj.toNum();
	}
	if (obj instanceof Agent) {
		return obj;
	} else if ((!strictAgentResolution) && obj instanceof Primitive) { // flexAgents is now disabled by default, kept for compatibility 
		return agent(obj.container);
	} else {
		throw "MSG: An agent is required here.";
	}
}

function agents(obj) {
	if (obj instanceof Agents) {
		return obj;
	} else if ((obj instanceof Primitive) || (obj instanceof Agent)) {
		return agents(obj.container);
	} else {
		throw "MSG: An agent population is required here.";
	}
}

function getPopulation(item) {
	if (item.items) {
		return item;
	}
	var res = [];
	if (item instanceof Agents) {
		return new Vector(item.agents.slice());
	} else if (item.toNum() instanceof Vector) {
		return item.toNum();
	} else {
		return new Vector([agent(item)]);
	}
}

function shiftLocation(agent, newLocation) {

	if (agent.container.geoWrap) {
		while (lessThan(newLocation.items[0], new Material(0))) {
			newLocation.items[0] = plus(newLocation.items[0], agent.container.geoWidth);
		}
		while (greaterThan(newLocation.items[0], agent.container.geoWidth)) {
			newLocation.items[0] = minus(newLocation.items[0], agent.container.geoWidth);
		}
		while (lessThan(newLocation.items[1], new Material(0))) {
			newLocation.items[1] = plus(newLocation.items[1], agent.container.geoHeight);
		}
		while (greaterThan(newLocation.items[1], agent.container.geoHeight)) {
			newLocation.items[1] = minus(newLocation.items[1], agent.container.geoHeight);
		}
	}

	agent.location = newLocation;
	if (!agent.location.names) {
		agent.location.names = ["x", "y"];
		agent.location.namesLC = ["x", "y"];
	}
}

function isUndefined(item) {
	return typeof (item) == "undefined";
}

function isDefined(item) {
	return !isUndefined(item);
}

function constraintAlert(item, type, val) {
	var msg = "The " + (type == "max" ? "maximum" : "minimum") + " constraint on the primitive <b>" + clean(getName(findID(item.id))) + "</b> has been violated. The primitive's value attempted to become " + clean(val.value) + " when the " + (type == "max" ? "maximum" : "minimum") + " allowed value is " + (type == "max" ? item.dna.maxConstraint : item.dna.minConstraint) + ".";
	error(msg, item, false);
}

function error(msg, primitive, showEditor, line, details) {
	var x = {
		msg: msg,
		primitive: primitive,
		showEditor: showEditor,
		line: line,
		details: details
	};
	if (isLocal()) {
		console.log("Error:")
		console.log(x);
	}
	throw x;
}

function testPrimitive(x, name, primitiveIndexes) {
	for (var i = 0; i < primitiveIndexes.length; i++) {
		if (!(x[primitiveIndexes[i]] instanceof Primitive)) {
			throw "MSG: " + name + "() requires a primitive reference to be passed to it as argument number " + (primitiveIndexes[i] + 1) + ".";
		}
	}

}

// For printing vectors
function prepareDisplay(x) {
	return x;
}


"use strict";
/*

Copyright 2010-2020 Scott Fortmann-Roe. All rights reserved.

This file may distributed and/or modified under the
terms of the Insight Maker Public License (https://InsightMaker.com/impl).

*/


function AggregateSeries(mid, mspacing) {
	this.id = mid;
	this.spacing = mspacing;
	this.oldValues = [];
}

AggregateSeries.method("match", function (mid) {
	return this.id == mid;
});


AggregateSeries.method("get", function (data) {
	var index = 0;
	if (this.spacing < 0) {
		index = 0;
	} else if (this.spacing == 0) {
		index = Math.floor(div(minus(simulate.time(), simulate.timeStart), simulate.UserTimeStep).value);
	} else {
		index = Math.floor(div(minus(simulate.time(), simulate.timeStart), this.spacing.forceUnits(simulate.timeUnits)).value);
	}

	while (this.oldValues.length - 1 < index) {
		this.oldValues.push(evaluateNode(data.node, data.scope));
	}
	if (this.oldValues[index].fullClone) {
		return this.oldValues[index].fullClone();
	} else {
		return this.oldValues[index];
	}
});

function DataBank() {
	this.dataSeries = {};
}

DataBank.method("series", function () {
	return Object.keys(this.dataSeries);
});

DataBank.method("clone", function () {
	var d = new DataBank();
	var keys = this.series();
	for (var i = 0; i < keys.length; i++) {
		d.dataSeries[keys[i]] = this.dataSeries[keys[i]];
	}
	return d;
})

DataBank.method("getSeries", function (n) {
	if (!this.dataSeries[n]) {
		this.dataSeries[n] = [];
	}
	return this.dataSeries[n];
});

DataBank.method("trimValues", function (newUbound) {
	var series = this.series();
	for (var i = 0; i < series.length; i++) {
		var d = this.getSeries(series[i]);
		if (d.length - 1 > newUbound) {
			d.splice(newUbound + 1, d.length - newUbound + 1);
		}
	}
});

function ExpGroup(n, kv, iv) {
	this.stocks = [];
	this.k = kv;

	for (var i = 1; i <= n; i++) {
		this.stocks.push(iv);
	}
	this.out = iv;
}

ExpGroup.method("moveForward", function (inp) {
	var nexp = new ExpGroup(this.stocks.length, this.k, new Material(0));

	nexp.out = this.stocks[this.stocks.length - 1];

	for (var i = this.stocks.length - 1; i > 0; i--) {
		nexp.stocks[i] = plus(mult(this.stocks[i], new Material(1 - this.k)), mult(this.stocks[i - 1], new Material(this.k))); //this.stocks[i]*(1-k) + this.stocks[i-1]*k;
	}

	nexp.stocks[0] = plus(mult(this.stocks[0], new Material(1 - this.k)), mult(inp, new Material(this.k)));//stocks[0]*(1-k) + inp*k;

	return nexp;
}
);



"use strict";
/*

Copyright 2010-2020 Scott Fortmann-Roe. All rights reserved.

This file may distributed and/or modified under the
terms of the Insight Maker Public License (https://InsightMaker.com/impl).

*/


function Primitive() {
	this.id = null;
	this.agentId = null;
	this.index = null;
	this.instanceId = null;

	this.container = null;

	this.dna = null;

	this.equation = null;

	this.cachedValue = undefined;
	this.pastValues = [];
	this.pastData = new DataBank();

	this.frozen = false;

	this.parent = PrimitiveBase;
}
Primitive.method("clone", function () {
	var p = new this.constructorFunction();
	p.dna = this.dna;
	p.container = this.container;
	p.agentId = this.agentId;
	p.index = this.index;
	p.id = this.id;
	p.createIds();
	p.pastValues = this.pastValues.slice(0);

	if (this.dna.slider) {
		if (simulate.sliders[this.dna.id]) {
			simulate.sliders[this.dna.id].push(p);
		} else {
			simulate.sliders[this.dna.id] = [p];
		}

	}

	p.cachedValue = this.cachedValue ? this.cachedValue.fullClone() : this.cachedValue;

	this.innerClone(p);

	return p;
});
Primitive.method("clearCached", function () {
	this.cachedValue = undefined;
});
Primitive.method("storeValue", function () {
	if (isUndefined(this.cachedValue)) {
		this.value();
	}
	this.pastValues.push(this.cachedValue)
})
Primitive.method("toNum", function () {
	return this.value();
});
Primitive.method("calculateValue", function () {
	throw "MSG: " + getText("[%s] does not have a value and can not be used as a value in an equation.", this.dna.name);
});
Primitive.method("createIds", function () {
	this.instanceId = simulate.getID(this.agentId + "-" + this.index);
});
Primitive.method("getPastValues", function (length) {

	var items = this.pastValues.slice();

	/* Add current value to array if needed */
	var bins = Math.ceil(div(simulate.time(), this.dna.solver.userTimeStep).value) + 1;
	if (items.length < bins) {
		items.push(this.value());
	}

	var res;
	if (isUndefined(length)) {
		res = items.map(function (x) { return x.fullClone() });
	} else {
		var bins = Math.ceil(div(length.forceUnits(simulate.timeUnits), this.dna.solver.userTimeStep).value);

		res = [];
		for (var i = Math.max(0, items.length - 1 - bins); i < items.length; i++) {
			res.push(items[i].fullClone());
		}
	}

	//res = [this.value().fullClone()].concat(res);
	//console.log(res.map(function(x){return x.value}));
	return res;
});
Primitive.method("pastValue", function pastValue(delay, defaultValue) {
	var periods;

	if (this.pastValues.length - 1 < Math.round((simulate.time().value - simulate.timeStart.value) / this.dna.solver.userTimeStep.value)) {
		periods = div(delay.forceUnits(simulate.timeUnits), this.dna.solver.userTimeStep).value;
	} else {
		periods = div(delay.forceUnits(simulate.timeUnits), this.dna.solver.userTimeStep).value + 1;
	}

	if (periods == 0) {
		return this.value();
	}

	if (Math.ceil(periods) > this.pastValues.length) {
		if (isUndefined(defaultValue)) {
			if (this.pastValues.length > 0) {
				return this.pastValues[0].fullClone();
			} else {
				return this.value();
			}
		} else {
			return defaultValue;
		}
	}

	if (periods == Math.round(periods)) {
		if (periods == 0) {
			return value;
		} else {
			return this.pastValues[this.pastValues.length - periods].fullClone();
		}
	}

	var fraction = periods - Math.floor(periods);
	var entry = Math.floor(periods);
	var first_period, second_period;
	if (entry == 0) {
		first_period = this.value();
	} else {
		first_period = this.pastValues[this.pastValues.length - entry];
	}
	second_period = this.pastValues[this.pastValues.length - 1 - entry];
	return plus(mult(first_period, new Material(1 - fraction)), mult(second_period, new Material(fraction)));
});

Primitive.method("smoothF", function (delay, initialV) {
	//console.log("--")
	var a = div(this.dna.solver.userTimeStep, delay.forceUnits(simulate.timeUnits)).value;

	var dat = this.pastData.getSeries("Smooth: " + a + "," + initialV);

	if (dat.length == 0) {
		if (isUndefined(initialV)) {
			dat.push(this.pastValues[0] ? this.pastValues[0] : this.value());
		} else {
			dat.push(initialV);
		}
	}

	//console.log("--")
	//console.log(this.pastValues.slice())
	//console.log(dat.slice())
	var maxInd = Math.floor((simulate.time().value - simulate.timeStart.value) / this.dna.solver.userTimeStep.value);

	for (var i = dat.length - 1; i < maxInd; i++) {
		var m = this.pastValues[i] ? this.pastValues[i] : (this.cachedValue ? this.cachedValue : this.pastValues[i - 1]);
		//console.log(m.value);
		dat.push(plus(mult(dat[i], new Material(1 - a)), mult(new Material(a), m)));
	}
	//if(dat.length <= maxInd){
	//	dat.push(plus(mult(dat[i-1], new Material(1-a)), mult(new Material(a), this.value())));
	//}

	return dat[dat.length - 1].fullClone();
});
Primitive.method("expDelayF", function (order, delay, initialV) {
	this.value();

	var a = div(this.dna.solver.userTimeStep, delay.forceUnits(simulate.timeUnits)).value * order;

	var dat = this.pastData.getSeries("ExpDelay: " + order + "," + delay.value + "," + initialV);

	if (dat.length == 0) {
		if (isUndefined(initialV)) {
			dat.push(new ExpGroup(order, a, this.pastValues[0] ? this.pastValues[0] : this.value()));
		} else {
			var exIV = new ExpGroup(order, a, initialV);
			dat.push(exIV.moveForward(this.pastValues[0] ? this.pastValues[0] : this.value()));
		}
	}

	for (var i = dat.length; i < this.pastValues.length; i++) {
		dat.push(dat[i - 1].moveForward(this.pastValues[i]));
	}
	//console.log(dat);
	return dat[dat.length - 1].out.fullClone();
});
Primitive.method("testUnits", function (m, ignoreFlow) {
	//console.log("testing units")
	if (m instanceof Vector) {
		var me = this;
		m.recurseApply(function (x) {
			me.testUnits(x, ignoreFlow);
			return x;
		});
		return
	}

	if ((!this.dna.units) && m.units) {
		error(getText("Wrong units generated for %s. Expected no units and got %s. Either specify units for the primitive or adjust the equation.", "<i>" + clean(this.dna.name) + "</i>", "<i>" + clean(m.units.toString()) + "</i>"), this, true);
	} else if (this.dna.units !== m.units) {
		var scale = convertUnits(m.units, this.dna.units, true);//XXX fixme
		if (scale == 0) {
			if (isLocal()) {
				console.log(m.units);
				console.log(this.dna.units);
			}
			error(getText("Wrong units generated for %s. Expected %s, and got %s.", "<i>" + clean(this.dna.name) + "</i>", "<i>" + clean(this.dna.units.toString()) + "</i>", "<i>" + clean(m.units.toString()) + "</i>"), this, true);
			return
		} else {
			//console.log("----+")
			//console.log("mod1")
			//console.log(m.units.exponents)
			m.value = m.value * scale;
			m.units = this.dna.units;
			//console.log(m.units.exponents)
			//console.log((this instanceof Flow));
			//console.log(ignoreFlow);
		}
	}
	if ((this instanceof Flow) && (ignoreFlow != true) && this.dna.flowUnitless) {
		//console.log("mod2")
		//console.log(m.units.exponents)
		var x = mult(m, new Material(1, simulate.timeUnits));
		m.value = x.value;
		m.units = x.units;

		//console.log(m.units.exponents)
		//console.log("done")
	}
});
Primitive.method("setValue", function () {
	throw "MSG: " + getText("You cannot set the value for that primitive.");
});
Primitive.method("printPastValues", function () {
	console.log(this.pastValues.map(function (x) { return x.value; }))
});

Primitive.method("value", function () {

	if (isUndefined(this.cachedValue) && this.frozen && this.pastValues.length > 0) {
		var v = this.pastValues[this.pastValues.length - 1];
		if (v.fullClone) {
			this.cachedValue = v.fullClone();
		} else {
			this.cachedValue = v;
		}
	}

	if (isUndefined(this.cachedValue)) {


		if (simulate.valuedPrimitives.indexOf(this) > -1) {
			throw "MSG: " + getText("Circular equation loop identified including the primitives: %s", simulate.valuedPrimitives.slice(simulate.valuedPrimitives.indexOf(this)).map(function (x) { return x.dna.name }).join(", "));
		}
		simulate.valuedPrimitives.push(this);

		try {
			var x = this.calculateValue().toNum();
			if ((x instanceof Material) && !isFinite(x.value)) {
				if (isLocal()) {
					console.log(x)
				}
				if (this instanceof Stock) {
					throw ("MSG: " + getText("The stock has become infinite in size. Check the flows into it for rapid growth."));
				} else {
					throw ("MSG: " + getText("The result of this calculation is not a number (are you dividing by 0?)."));
				}
			}
		} catch (err) {
			if (!err.substr) {
				throw err; //it's already an object, let's kick it up the chain
			}
			if (isLocal()) {
				console.log(err);
			}
			if (err.substr(0, 4) == "MSG:") {
				error(err.substr(4, err.length), this, true);
			} else {
				error(err, this, true);
			}
		}
		if (!(this instanceof State)) {
			this.testUnits(x);
			this.testConstraints(x);
		}
		//if (this.pastValues.length - 1 < simulate.timeIndex-1) {
		//	this.pastValues = [];
		//this.pastValues.push(null);
		//	this.cutoff = simulate.timeIndex;
		//}
		this.cachedValue = x;
	}


	if (this.cachedValue.fullClone) {
		return this.cachedValue.fullClone();
	} else {
		return this.cachedValue;
	}
});
Primitive.method("testConstraints", function (x) {
	var me = this;
	var test = function (x) {
		if ((me.dna.maxConstraintType == 1 && x.value > me.dna.maxConstraint) || (me.dna.maxConstraintType == 2 && x.value >= me.dna.maxConstraint)) {
			constraintAlert(me, "max", x);
		}
		if ((me.dna.minConstraintType == 1 && x.value < me.dna.minConstraint) || (me.dna.minConstraintType == 2 && x.value <= me.dna.minConstraint)) {
			constraintAlert(me, "min", x);
		}
		return x;
	}
	if (x instanceof Vector) {
		x.recurseApply(test);
	} else {
		test(x);
	}
});
Primitive.method("setEquation", function (tree, neighborhood) {

	//console.log("==");
	//console.log(this.name);
	//console.log(tree);
	if (this instanceof Flow || this instanceof Transition) {
		if (this.omega !== null) {
			neighborhood.omega = this.omega;
		}
		if (this.alpha !== null) {
			neighborhood.alpha = this.alpha;
		}
	}

	try {
		this.equation = trimTree(tree, neighborhood);
	} catch (err) {
		if (isLocal()) {
			console.log(err);
		}
		error(err.substr(4, err.length), this, true);
	}
})

function Placeholder(dna, primitive) {
	this.dna = dna;
	this.id = dna.id;
	this.primitive = primitive;
}
Placeholder.inherits(Primitive);
Placeholder.method("calculateValue", function () {
	error(getText("[%s] is a placeholder and cannot be used as a direct value in equations.", clean(this.dna.name)), this.primitive, true);
});

function State() {
	Primitive.call(this);
	this.active = null;
	this.downStreamTransitions = [];
	this.constructorFunction = State;
}
State.inherits(Primitive);
State.method("innerClone", function (p) {
	p.setValue(this.active);

});
State.method("setValue", function (value) {
	this.setActive(trueValue(value));
	this.cachedValue = undefined;
	simulate.valuedPrimitives = [];
	this.value();
	if (this.agentId) {
		this.container.updateStates();
	}
});
State.method("calculateValue", function () {
	if (this.active === null) {
		//console.log("calc");
		this.setInitialActive(true);
	}

	if (this.active) {
		return new Material(1);
	} else {
		return new Material(0);
	}

});
State.method("setInitialActive", function (suppress) {
	var init;

	try {
		init = evaluateTree(this.equation, globalVars(this)).toNum();
	} catch (err) {
		if (!err.substr) {
			throw err; //it's already an object, let's kick it up the chain
		}
		if (isLocal()) {
			console.log(err);
		}
		if (err.substr(0, 4) == "MSG:") {
			error(err.substr(4, err.length), this, true);
		} else {
			error(err, this, true);
		}
	}

	//console.log("--")
	//console.log(this.dna.name)
	//console.log("init")

	this.setActive(trueValue(init), suppress);
	if (this.agentId) {
		this.container.updateStates();
	}

});
State.method("setActive", function (active, suppress) {
	this.active = active;

	if ((!active) || this.dna.residency === null) {
		if (!suppress) {
			if (active) {
				if (!simulate.transitionPrimitives) {
					simulate.transitionPrimitives = [];
				}

				if (simulate.transitionPrimitives.length > 1200 && simulate.transitionPrimitives.indexOf(this) > -1) {
					throw "MSG: " + getText("Circular fully active transition loop identified including the states: %s", simulate.transitionPrimitives.slice(0, 5).map(function (x) { return x.dna.name }).join(", "));
				}
				simulate.transitionPrimitives.push(this);
			}

			for (var i = 0; i < this.downStreamTransitions.length; i++) {
				scheduleTrigger.call(this.downStreamTransitions[i]);
			}

			if (active) {
				simulate.transitionPrimitives = [];
			}

		}
	} else {
		var me = this;
		simulate.tasks.add(new Task({
			name: "State Residency",
			time: plus(simulate.time(), this.dna.residency),
			priority: 5,
			expires: 1,
			action: function () {
				for (var i = 0; i < me.downStreamTransitions.length; i++) {
					scheduleTrigger.call(me.downStreamTransitions[i]);
				}
			}
		}));
	}

});
State.method("getActive", function () {
	if (this.active === null) {
		//console.log("get");
		this.setInitialActive(true);
	}
	return this.active;
});


function Transition() {
	Primitive.call(this);
	this.alpha = null;
	this.omega = null;
	this.scheduledTrigger = null;
	this.constructorFunction = Transition;
}
Transition.inherits(Primitive);
Transition.method("innerClone", function (p) {
});
Transition.method("setEnds", function (alpha, omega) {
	this.alpha = alpha;
	this.omega = omega;
	if (alpha) {
		alpha.downStreamTransitions.push(this);
	}
});
Transition.method("canTrigger", function () {
	return (!this.alpha) || (this.alpha && this.alpha.getActive()) || (this.dna.repeat && this.dna.trigger != "Condition");
});
Transition.method("trigger", function () {
	//console.log("--")
	//console.log(this.dna.name)
	//console.log(simulate.time().value);
	//console.log("transition");

	this.scheduledTrigger = null;

	if (this.frozen) {
		return;
	}

	if (this.alpha) {
		this.alpha.setActive(false);
	}
	if (this.omega) {
		this.omega.setActive(true);
	}
	if (this.agentId) {
		this.container.updateStates();
	}
	if (this.dna.repeat && this.dna.trigger != "Condition") {
		scheduleTrigger.call(this);
	}
});

function scheduleTrigger() {
	updateTrigger.call(this, true);

}

function clearTrigger(force) {
	if (this.scheduledTrigger && (force || (!this.dna.repeat))) {
		this.scheduledTrigger.kill();
		this.scheduledTrigger = null;
	}
}

function updateTrigger(clear) {
	if (clear) {
		clearTrigger.call(this);
	}


	if (this.canTrigger()) {
		try {
			var v = evaluateTree(this.equation, globalVars(this)).toNum();
		} catch (err) {
			if (!err.substr) {
				throw err; //it's already an object, let's kick it up the chain
			}
			if (isLocal()) {
				console.log(err);
			}
			if (err.substr(0, 4) == "MSG:") {
				error(err.substr(4, err.length), this, true);
			} else {
				error(err, this, true);
			}
		}

		if (this.dna.trigger == "Condition") {
			if (trueValue(v)) {
				//console.log("triggering")
				//console.log(v);
				this.trigger();
				//console.log("end triggering")
			}
		} else {
			if (!(v instanceof Material)) {
				error(getText("The value of this trigger must evaluate to a number."), this, true);
			}

			var t;

			if (this.dna.trigger == "Timeout") {

				if (!v.units) {
					v.units = simulate.timeUnits;
				}

				if (this.scheduledTrigger && eq(v, this.scheduledTrigger.data.value)) {
					return;
				}
				if (this.dna.repeat && v.value == 0) {
					error(getText("A trigger Timeout of 0 with 'Repeat' set to true results in an infinite loop."), this, true);
				}

				t = v;

			} else if (this.dna.trigger == "Probability") {

				if (v.units) {
					error(getText("The probability for the trigger had units of %s. Probabilities must be unitless.", this.value().units.toString()), this, true);
				}
				var v = v.value
				if (this.scheduledTrigger && eq(v, this.scheduledTrigger.data.value)) {
					return;
				}

				if (v == 1) {
					if (this.dna.repeat) {
						error(getText("A trigger probability of 1 with 'Repeat' as true results in an infinite loop."), this, true);
					}
					t = new Material(0, simulate.timeUnits);
				} else if (v > 1) {
					error(getText("The probability for the trigger must be less than or equal to 1."), this, true);
				} else if (v < 0) {
					error(getText("The probability for the trigger must be greater than or equal to 0."), this, true);
				} else if (v == 0) {
					if (!this.scheduledTrigger) {
						return;
					}
				} else {
					var l = -Math.log(1 - v);
					t = new Material(RandExp(l), simulate.timeUnits);
				}

			}

			/*console.log("--");
			console.log(this);
			console.log(v);
			console.log(t);
			debugger;*/

			var start = simulate.time()

			if (this.scheduledTrigger) {

				this.scheduledTrigger.kill();
				if (this.dna.trigger == "Timeout") {
					if (lessThanEq(t, minus(simulate.time(), this.scheduledTrigger.data.start))) {
						this.scheduledTrigger = null;
						this.trigger();
						return;
					} else {
						start = this.scheduledTrigger.data.start;
						t = minus(t, minus(simulate.time(), start));
						this.scheduledTrigger = null;
					}
				} else if (this.dna.trigger == "Probability") {
					if (v == 0) {
						this.scheduledTrigger = null;
						return;
					}
					t = minus(this.scheduledTrigger.time, simulate.time());

					var l0 = -Math.log(1 - this.scheduledTrigger.data.value);
					var l = -Math.log(1 - v);

					t = mult(t, new Material(l0 / l));

					start = this.scheduledTrigger.data.start;

					this.scheduledTrigger = null;
				}
			}
			//console.log(t);
			t = plus(t, simulate.time());

			var me = this;
			this.scheduledTrigger = new Task({
				name: "Trigger",
				time: t,
				priority: 5,
				expires: 1,
				action: function () {
					me.trigger();
				},
				data: { start: start, value: v }
			})
			simulate.tasks.add(this.scheduledTrigger);
		}
	}
}

function Action() {
	Primitive.call(this);
	this.action = null;
	this.scheduledTrigger = null;
	this.block = false;
	this.constructorFunction = Action;
}
Action.inherits(Primitive);
Action.method("innerClone", function (p) {

});
Action.method("canTrigger", function () {
	return !this.block;
});
Action.method("resetTimer", function () {
	scheduleTrigger.call(this);
});
Action.method("trigger", function () {

	this.scheduledTrigger = null;

	if (this.frozen) {
		return;
	}

	try {
		//console.log("action")
		evaluateTree(this.action, globalVars(this));
		//console.log("end action")
		if (this.dna.repeat) {
			if (this.dna.trigger !== "Condition") {
				scheduleTrigger.call(this);
			}
		} else {
			this.block = true;
		}
	} catch (err) {
		if (!err.substr) {
			throw err; //it's already an object, let's kick it up the chain
		}
		if (isLocal()) {
			console.log(err);
		}
		if (err.substr(0, 4) == "MSG:") {
			error(err.substr(4, err.length), this, true);
		} else {
			error(err, this, true);
		}
	}
});

function Agents() {
	Primitive.call(this);
	this.size = null;
	this.agents = null;
	this.geoWidth = null;
	this.geoHeight = null;
	this.halfWidth = null;
	this.halfHeight = null;
	this.geoDimUnits = null;
	this.geoDimUnitsObject = null;
	this.geoWrap = null;
	this.DNAs = null;
	this.stateIds = [];
	this.constructorFunction = Agents;

	this.vector = new Vector([], [], PrimitiveBase);
}
Agents.inherits(Primitive);
Agents.method("collectData", function () {
	var x = [];
	for (var i = 0; i < this.agents.length; i++) {
		var agent = this.agents[i];
		x.push({ instanceId: agent.instanceId, connected: agent.connected.map(function (x) { return x.instanceId }), location: simpleNum(agent.location.clone(), this.geoDimUnitsObject), state: agent.states.length > 0 ? agent.states.slice() : null });
	}
	return x;
});
Agents.method("states", function () {
	return this.stateIds.slice(0);
});
Agents.method("toNum", function () {
	throw ("MSG: " + getText("[%s] is a population of agents and cannot be used as a direct value in equations.", clean(this.dna.name)));
});
Agents.method("add", function (base) {
	this.size = 1 + parseInt(this.size, 10);
	//console.log("----");
	if (base) {
		var agent = base.agentClone();
		agent.agentId = this.agentId;
		agent.setIndex(this.size - 1);
		agent.createAgentIds();

		for (var i = 0; i < this.DNAs.length; i++) {
			var x = agent.children[i];
			var dna = this.DNAs[i];

			x.container = agent;

			linkPrimitive(x, dna);

		}

		agent.updateStates();

	} else {
		//console.log("-----");
		var agent = new Agent();
		agent.container = this;
		agent.children = [];
		agent.childrenId = {};
		agent.agentId = this.agentId;

		for (var i = 0; i < this.DNAs.length; i++) {
			decodeDNA(this.DNAs[i], agent);
		}

		agent.setIndex(this.size - 1);
		agent.createAgentIds();

		for (var i = 0; i < this.DNAs.length; i++) {
			linkPrimitive(agent.children[i], this.DNAs[i]);
		}

		setAgentInitialValues(agent);

		var hood = getPrimitiveNeighborhood(this, this.dna);
		//console.log(hood);
		if (this.placement == "Custom Function") {
			hood.self = agent;
			agent.location = simpleUnitsTest(simpleEquation(this.placementFunction, { "-parent": varBank, self: agent }, hood), this.geoDimUnitsObject);
			if (!agent.location.names) {
				agent.location.names = ["x", "y"];
				agent.location.namesLC = ["x", "y"];
			}
		} else {
			agent.location = new Vector([mult(this.geoWidth, new Material(Rand())), mult(this.geoHeight, new Material(Rand()))], ["x", "y"]);
		}
		if (this.network == "Custom Function") {
			var tree = trimTree(createTree(this.networkFunction), hood);
			for (var j = i + 1; j < this.agents.length; j++) {
				if (trueValue(simpleEquation(this.networkFunction, { "-parent": varBank, "a": agent, "b": this.agents[j] }, hood, tree))) {
					agent.connect(this.agents[j]);
				}
			}
		}



	}

	var me = this;
	simulate.tasks.add(new Task({
		priority: 10,
		expires: 1,
		name: "Add Agent",
		time: simulate.time(),
		action: function () {
			me.agents.push(agent);

			for (var i = 0; i < agent.children.length; i++) {
				var x = agent.children[i];

				var dna = me.DNAs[i];

				if ((x instanceof Action) || (x instanceof Transition)) {
					if (dna.trigger != "Condition") {
						scheduleTrigger.call(x);
					}
				}

				if (base) {
					if (x instanceof Action) {
						dna.solver.actions.push(x);
					} else if (x instanceof Transition) {
						dna.solver.transitions.push(x);
					} else if (!(x instanceof Agents)) {
						dna.solver.valued.push(x)
						if (x instanceof Flow) {
							dna.solver.flows.push(x);
						} else if (x instanceof Stock) {
							dna.solver.stocks.push(x);
						} else if (x instanceof State) {
							dna.solver.states.push(x);
						}
					}
				}


			}


		}
	}));

	return agent;
});


function Agent() {
	this.agentId = null;
	this.instanceId = null;
	this.index = null;
	this.children = null;
	this.location = null;
	this.connected = [];
	this.connectedWeights = [];
	this.dead = false;
	this.constructorFunction = Agent;
	this.stateIDs = [];
	this.states = [];

	this.vector = new Vector([], [], AgentBase);
}
Agent.prototype.createIds = Primitive.prototype.createIds;
Agent.method("toString", function () {
	return "Agent " + (this.index + 1);
})
Agent.method("toNum", function () {
	return this;
	//throw("MSG: Invalid attempt to use an agent as a valued primitive.");
});
Agent.method("updateStates", function () {
	this.states = [];
	this.stateIDs = [];
	for (var c = 0; c < this.children.length; c++) {
		if (this.children[c].active) {
			this.states.push(this.children[c]);
			this.stateIDs.push(this.children[c].dna.id);
		}
	}
});
Agent.method("agentClone", function () {
	var agent = new Agent();
	agent.dna = this.dna;
	agent.children = [];
	agent.childrenId = {};

	for (var i = 0; i < this.children.length; i++) {
		agent.children.push(this.children[i].clone());
		agent.childrenId[agent.children[i].dna.id] = agent.children[i];
	}

	agent.location = this.location.clone();
	agent.connected = this.connected.slice(0);
	agent.connectedWeights = this.connectedWeights.slice(0);
	agent.container = this.container;


	return agent;
});
Agent.method("setIndex", function (index) {
	this.index = index;
	for (var i = 0; i < this.children.length; i++) {
		this.children[i].index = index;
	}
});
Agent.method("createAgentIds", function () {
	this.createIds();
	for (var i = 0; i < this.children.length; i++) {
		this.children[i].createIds();
	}
})
Agent.method("die", function () {
	while (this.connected.length > 0) {
		this.unconnect(this.connected[0]);
	}

	for (var i = 0; i < this.container.agents.length; i++) {
		if (this.container.agents[i] == this) {
			this.container.agents.splice(i, 1);
			break;
		}
	}

	for (var i = 0; i < this.children.length; i++) {
		var x = this.children[i];
		var solver = x.dna.solver;
		if (x instanceof Action) {
			solver.actions.splice(solver.actions.indexOf(x), 1);
			clearTrigger.call(x, true);
		} else if (x instanceof Transition) {
			solver.transitions.splice(solver.transitions.indexOf(x), 1);
			clearTrigger.call(x, true);
		} else if (!(x instanceof Agents)) {
			solver.valued.splice(solver.valued.indexOf(x), 1);
			if (x instanceof Flow) {
				solver.flows.splice(solver.flows.indexOf(x), 1);
			}
			else if (x instanceof Stock) {
				solver.stocks.splice(solver.stocks.indexOf(x), 1);
			}
			else if (x instanceof State) {
				solver.states.splice(solver.states.indexOf(x), 1);
			}
		}
	}


	this.dead = true;
});
Agent.method("connect", function (x, weight) {

	var w = (weight === undefined) ? new Material(1) : weight;
	if (x !== this) {
		if (this.connected.indexOf(x) == -1) {
			if (x instanceof Agent) {
				this.connected.push(x);
				this.connectedWeights.push(w);
				x.connected.push(this);
				x.connectedWeights.push(w);
			} else {
				throw ("MSG: Only agents may be connected.");
			}
		} else if (weight !== undefined) {
			this.connectedWeights[this.connected.indexOf(x)] = weight;
			x.connectedWeights[x.connected.indexOf(x)] = weight;
		}
	}

});
Agent.method("unconnect", function (x) {
	if (x !== this) {
		var i = this.connected.indexOf(x);
		if (i != -1) {
			this.connected.splice(i, 1);
			this.connectedWeights.splice(i, 1);
			i = x.connected.indexOf(this);
			x.connected.splice(i, 1);
			x.connectedWeights.splice(i, 1);
		}
	}
});

Agent.method("connectionWeight", function (x) {
	if (x !== this) {
		var i = this.connected.indexOf(x);

		if (i != -1) {
			return this.connectedWeights[i].fullClone();
		}
	}
	throw "MSG: Agents are not connected and so do not have a connection weight.";
});

Agent.method("setConnectionWeight", function (x, w) {
	if (x !== this) {
		var i = this.connected.indexOf(x);
		if (i != -1) {
			this.connectedWeights[i] = w.fullClone();
			return;
		}
	}
	throw "MSG: Agents are not connected and so do not have a connection weight.";
});

function Stock() {
	Primitive.call(this);
	this.level = null;
	this.constructorFunction = Stock;
	this.delay = undefined;
	this.tasks = [];
	this.initRate = null;
	this.oldLevel = null;
}
Stock.inherits(Primitive);
Stock.method("innerClone", function (p) {
	p.level = this.level;
	p.oldLevel = this.oldLevel;
	p.tasks = this.tasks;
	p.delay = this.delay;
});
Stock.method("setValue", function (value) {
	//console.log("--")
	this.level = value;
	this.cachedValue = undefined;
	simulate.valuedPrimitives = [];
	this.value();
});
Stock.method("print", function () {
	console.log(this.level.map(function (x) { return x.value }));
});
Stock.method("preserveLevel", function () {
	//console.log("PRESERVING")
	//console.log("total:"+this.level.value)
	for (var i = this.tasks.length - 1; i >= 0; i--) {
		this.tasks[i].data.tentative = false;
	}
	this.oldLevel = this.level;
});
Stock.method("restoreLevel", function () {
	//console.log("RESTORING")
	for (var i = this.tasks.length - 1; i >= 0; i--) {
		if (this.tasks[i].data.tentative) {
			this.tasks[i].remove();
			this.tasks.splice(i, 1);
		}
	}
	this.level = this.oldLevel;
	//console.log("total: "+this.level.value)
});
Stock.method("setDelay", function (delay) {
	delay = delay || this.dna.delay;
	this.delay = delay;
});
Stock.method("setInitialValue", function () {
	var me = this;
	var init;

	//console.log("Setting Initial value:"+this.dna.name);
	try {
		//console.log(this.equation);
		//console.log(globalVars(this))
		init = evaluateTree(this.equation, globalVars(this)).toNum();
		//	console.log(init);
	} catch (err) {
		if (!err.substr) {
			throw err; //it's already an object, let's kick it up the chain
		}
		if (isLocal()) {
			console.log(err);
		}
		if (err.substr(0, 4) == "MSG:") {
			error(err.substr(4, err.length), this, true);
		} else {
			error(err, this, true);
		}
	}

	if (typeof init == "boolean") {
		if (init) {
			init = new Material(1);
		} else {
			init = new Material(0);
		}
	}

	if (init instanceof Vector) {
		var d = this.dna;
		init.recurseApply(function (x) {
			if (d.nonNegative && x.value < 0) {
				x = new Material(0, d.units);
			}
			if (!x.units) {
				x.units = d.units;
			}
			return x;
		})
	} else {
		if (this.dna.nonNegative && init.value < 0) {
			init = new Material(0, this.dna.units);
		}
		if (!init.units) {
			init.units = this.dna.units;
		}
	}


	if (isUndefined(this.delay)) {
		// it's a non-serialized stock;
		this.level = init;
	} else {
		// it's serialized
		var startVal = mult(init, div(simulate.userTimeStep, this.delay))
		this.initRate = div(init, this.delay.forceUnits(simulate.timeUnits));

		this.level = startVal;

		simulate.tasks.addEvent(function (timeChange, oldTime, newTime) {
			if (timeChange.value > 0) {
				if (lessThanEq(minus(newTime, simulate.timeStart), minus(me.delay, simulate.userTimeStep))) {
					timeChange = functionBank["min"]([timeChange, minus(me.delay, minus(oldTime, simulate.timeStart))]);
					me.level = plus(me.level, mult(timeChange, me.initRate));
				}
			}
		});
	}
});
Stock.method("subtract", function (amnt, time) {
	this.level = minus(this.level, amnt);
	if (this.dna.nonNegative) {
		if (this.level instanceof Vector) {
			var d = this.dna;
			this.level.recurseApply(function (x) {
				if (x.value < 0) {
					return new Material(0, d.units);
				} else {
					return x;
				}
			});
		} else if (this.level.value < 0) {
			this.level = new Material(0, this.dna.units);
		}
	}
});
Stock.method("add", function (amnt, time) {
	if (isUndefined(this.delay)) {
		this.level = plus(this.level, amnt);
		if (this.dna.nonNegative) {
			if (this.level instanceof Vector) {
				var d = this.dna;
				this.level.recurseApply(function (x) {
					if (x.value < 0) {
						return new Material(0, d.units);
					} else {
						return x;
					}
				});
			} else if (this.level.value < 0) {
				this.level = new Material(0, this.dna.units);
			}
		}
	} else {
		this.scheduleAdd(amnt, time);
	}
});
Stock.method("scheduleAdd", function (amnt, time, delay) {
	//console.log("SCEDULING ADD "+time)
	//console.log(amnt)

	var me = this;
	delay = delay || this.delay;

	var oldLevel;

	var t = new Task({
		time: plus(time, delay),
		data: {
			amnt: amnt,
			tentative: true
		},
		priority: -100,
		name: "Conveyor Add (" + this.dna.name + ")",
		action: function () {
			oldLevel = me.level;
			//console.log("ADDING "+amnt.value);
			me.level = plus(me.level, amnt);
			//console.log("total "+me.level.value);
			if (me.dna.nonNegative) {
				if (me.level instanceof Vector) {
					var d = me.dna;
					me.level.recurseApply(function (x) {
						if (x.value < 0) {
							return new Material(0, d.units);
						} else {
							return x;
						}
					});
				} else if (me.level.value < 0) {
					me.level = new Material(0, me.dna.units);
				}
			}
		},
		rollback: function () {
			me.level = oldLevel;
		}
	});
	this.tasks.push(t);
	simulate.tasks.add(t);
})
Stock.method("totalContents", function () {
	if (isDefined(this.delay)) {
		var res = this.level;
		for (var i = 0; i < this.tasks.length; i++) {
			if (greaterThan(this.tasks[i].time, simulate.time()) && lessThanEq(this.tasks[i].time, plus(simulate.time(), this.delay))) {
				res = plus(res, this.tasks[i].data.amnt);
			}
		}

		var x = minus(this.delay, simulate.userTimeStep);
		if (greaterThan(x, simulate.timeProgressed())) {
			var timeLeft = minus(x, simulate.timeProgressed());
			res = plus(res, mult(this.initRate, timeLeft));
		}

		return res;
	} else {
		return this.level;
	}
});
Stock.method("calculateValue", function () {
	if (this.level === null) {
		this.setInitialValue();
	}
	if (isDefined(this.delay) && this.dna.solver.RKOrder == 4) {
		var res = this.level;
		for (var i = 0; i < this.tasks.length; i++) {
			if (greaterThan(this.tasks[i].time, simulate.time()) && lessThanEq(this.tasks[i].time, plus(simulate.time(), this.dna.solver.timeStep))) {
				res = plus(res, this.tasks[i].data.amnt);
			}
		}
		return res;
	} else {
		return this.level;
	}
});

function Converter() {
	Primitive.call(this);
	this.source = null;
	this.constructorFunction = Converter;
}
Converter.inherits(Primitive);
Converter.method("innerClone", function (p) {
});
Converter.method("setSource", function (source) {
	this.source = source;
});
Converter.method("getInputValue", function () {
	var inp;
	if (this.source == "*time") {
		inp = simulate.time();
	} else {
		inp = this.source.value().toNum();
		if (!inp) {
			error(getText("Undefined input value."), this, false);
		}
		if (inp instanceof Vector) {
			error(getText("Converters do not accept vectors as input values."), this, false);
		}
		//console.log(inp);
	}
	return inp;
}
);
Converter.method("calculateValue", function () {
	return new Material(this.getOutputValue().value, this.dna.units);
});
Converter.method("getOutputValue", function () {
	//console.log("---")

	var inp = this.getInputValue();

	if (this.dna.inputs.length == 0) {
		return new Material(0);
	}
	//console.log("+++")
	for (var i = 0; i < this.dna.inputs.length; i++) {
		if (this.dna.interpolation == "discrete") {

			if (greaterThan(this.dna.inputs[i], inp)) {
				if (i == 0) {
					return this.dna.outputs[0];
				} else {
					return this.dna.outputs[i - 1];
				}
			}

		} else if (this.dna.interpolation == "linear") {
			//console.log(i)
			if (eq(this.dna.inputs[i], inp)) {
				//console.log("eq")
				return this.dna.outputs[i];
			} else if (greaterThan(this.dna.inputs[i], inp)) {
				//console.log("gt")
				if (i == 0) {
					return this.dna.outputs[0];
				} else {
					///console.log("----")
					//console.log(mult(minus(inp, this.inputs[i - 1]), this.outputs[i]));
					//console.log(mult(minus(this.inputs[i], inp), this.outputs[i - 1]))
					var x = div(
						plus(
							mult(minus(inp, this.dna.inputs[i - 1]), this.dna.outputs[i]),
							mult(minus(this.dna.inputs[i], inp), this.dna.outputs[i - 1])
						),
						minus(this.dna.inputs[i], this.dna.inputs[i - 1]));
					//console.log("===")
					return x;
				}
			}
		}
	}
	return this.dna.outputs[this.dna.outputs.length - 1];
});


function Variable() {
	Primitive.call(this);
	this.constructorFunction = Variable;
}
Variable.inherits(Primitive);
Variable.method("innerClone", function (p) {
});
Variable.method("calculateValue", function () {
	//console.log("--")
	//console.log(this)
	//console.log("calc!");
	//console.log("--");
	//console.log(this.dna.name);
	//console.log(this.equation);
	//try{
	var x = evaluateTree(this.equation, globalVars(this));
	//console.log(x);
	//}catch(err){
	//	console.log(this.dna.name);
	//	throw "calc value error";
	//}
	//console.log(x);
	//return x;
	//console.log(x);
	if (typeof x == "boolean") {
		if (x) {
			x = new Material(1);
		} else {
			x = new Material(0);
		}
	} else if (x instanceof Vector) {
		return x;
		//	error("Cannot set a variable value to a vector.", this, true)
	}
	if (!x.units) {
		x.units = this.dna.units;
	}
	return x;
});

function Flow() {
	Primitive.call(this);
	this.alpha = null;
	this.omega = null;
	this.rate = null;
	this.RKPrimary = [];
	this.constructorFunction = Flow;
}
Flow.inherits(Primitive);
Flow.method("innerClone", function (p) {
});
Flow.method("setEnds", function (alpha, omega) {
	this.alpha = alpha;
	this.omega = omega;
});
Flow.method("calculateValue", function () {
	//while(this.RKPrimary.length < this.dna.solver.RKPosition){
	this.predict();
	//}
	return this.rate.fullClone();
});
Flow.method("clean", function () {
	this.rate = null;
	this.RKPrimary = [];
});
Flow.method("predict", function (override) {
	if (this.rate === null || override) {

		try {
			//console.log("---");
			var x = evaluateTree(this.equation, globalVars(this)).toNum();
			//console.log(this.equation);
			//console.log(x);
			if (!((x instanceof Vector) || isFinite(x.value))) {
				throw ("MSG: " + getText("The result of this calculation is not finite. Flows must have finite values. Are you dividing by 0?"));
			}

		} catch (err) {
			if (!err.substr) {
				throw err; //it's already an object, let's kick it up the chain
			}
			if (isLocal()) {
				console.log(err);
			}
			if (err.substr(0, 4) == "MSG:") {
				error(err.substr(4, err.length), this, true);
			} else {
				error(err, this, true);
			}
		}
		if (typeof x == "boolean") {
			if (x) {
				x = new Material(1);
			} else {
				x = new Material(0);
			}
		}

		this.rate = x.fullClone();

		if (this.rate instanceof Vector) {
			var d = this.dna;
			this.rate.recurseApply(function (x) {
				if (!x.units) {
					x.units = d.units;
				}
				return x
			})
		} else if (!this.rate.units) {
			this.rate.units = this.dna.units;
		}

		this.testUnits(this.rate, true);

		this.rate = mult(this.rate, this.dna.solver.timeStep);

		if (override) {
			if (this.RKPrimary.length > 0) {
				this.RKPrimary[this.RKPrimary.length - 1] = this.rate;
			} else {
				this.RKPrimary.push(this.rate);
			}

		} else {
			this.RKPrimary.push(this.rate);
		}

		if (this.dna.solver.RKOrder == 4) {
			if (this.dna.solver.RKPosition == 1) {
				this.rate = this.RKPrimary[0];
			} else if (this.dna.solver.RKPosition == 2) {
				this.rate = this.RKPrimary[1];
			} else if (this.dna.solver.RKPosition == 3) {
				this.rate = this.RKPrimary[2];
			} else if (this.dna.solver.RKPosition == 4) {
				this.rate = div((plus(plus(plus(this.RKPrimary[0], mult(new Material(2), this.RKPrimary[1])), mult(new Material(2), this.RKPrimary[2])), this.RKPrimary[3])), new Material(6));
			}
		}

		this.rate = div(this.rate, this.dna.solver.timeStep);

		if (this.dna.onlyPositive) {
			if (this.rate instanceof Vector) {
				this.rate.recurseApply(function (x) {
					if (x.value >= 0) {
						return x
					} else {
						return new Material(0, x.units);
					}
				});
			} else {
				if (this.rate.value <= 0) {
					this.rate = new Material(0, this.rate.units);
				}
			}
		}



	}
});
Flow.method("apply", function (timeChange, oldTime, newTime) {

	try {

		//console.log(this.dna.name+" - apply")
		//console.log("RKPosition: "+this.dna.solver.RKPosition);
		//console.log(this.RKPrimary.map(function(x){return x.value}));
		//console.log(this.rate.value);

		if (this.rate === null) {
			return;
		}

		var rate = this.rate.fullClone();

		rate = mult(rate, timeChange);


		var in_rate = rate;
		var out_rate = rate;
		var collapsed = false;

		if (this.alpha !== null) {
			var v = this.alpha.level;
			if ((rate instanceof Vector) && ((!(v instanceof Vector)) || v.depth() < rate.depth())) {
				in_rate = rate.fullClone().collapseDimensions(v);
				collapsed = true;
			} else if ((v instanceof Vector) && ((!(rate instanceof Vector)) || v.depth() > rate.depth())) {
				error(getText("The alpha of the flow is a vector with a higher order than the flow rate. There has to be at least one element in the flow rate for each element in the alpha."), this, true)
			}
		}
		if (this.omega !== null) {
			//console.log("c")
			var v = this.omega.level;
			if ((rate instanceof Vector) && ((!(v instanceof Vector)) || v.depth() < rate.depth())) {
				out_rate = rate.fullClone().collapseDimensions(v);
				collapsed = true;
			} else if ((v instanceof Vector) && ((!(rate instanceof Vector)) || v.depth() > rate.depth())) {
				error(getText("The omega of the flow is a vector with a higher order than the flow rate. There has to be at least one element in the flow rate for each element in the omega."), this, true)
			}
		}

		if (!collapsed) {
			var constraints = 0;

			if (this.omega !== null && this.omega.dna.nonNegative) {
				var modifier = plus(this.omega.level.toNum(), rate);
				if (modifier instanceof Vector) {
					modifier.recurseApply(function (x) {
						if (x.value < 0) {
							return x;
						} else {
							return new Material(0, x.units);
						}
					});
					rate = minus(rate, modifier);
				} else {
					if (modifier.value < 0) {
						rate = negate(this.omega.level.toNum());
					}
				}
				constraints++;
			}

			if (this.alpha !== null && this.alpha.dna.nonNegative) {

				var modifier = minus(this.alpha.level.toNum(), rate);
				if (modifier instanceof Vector) {
					modifier.recurseApply(function (x) {
						if (x.value < 0) {
							return x;
						} else {
							return new Material(0, x.units);
						}
					})
					rate = minus(rate, modifier);
					rate = minus(rate, modifier);
				} else {
					if (modifier.value < 0) {
						rate = this.alpha.level.toNum();
					}
				}
				constraints++;
			}

			if (this.omega !== null && this.omega.dna.nonNegative) {

				if (rate instanceof Vector) {
					var vec = functionBank["flatten"]([plus(this.omega.level.toNum(), rate)]);
					for (var i = 0; i < vec.items.length; i++) {
						if (vec.items[i].value < 0) {
							error(getText("Inconsistent non-negative constraints for flow."), this, false);
						}
					}
				} else {
					if (plus(this.omega.level.toNum(), rate).value < 0) {

						error(getText("Inconsistent non-negative constraints for flow."), this, false);
					}
				}
			}
		} else {
			if (this.alpha !== null && this.alpha.dna.nonNegative) {
				error(getText("Cannot use non-negative stocks when the flow rate is a vector that needs to be collapsed."), this.alpha, false);
			}
			if (this.omega !== null && this.omega.dna.nonNegative) {
				error(getText("Cannot use non-negative stocks when the flow rate is a vector that needs to be collapsed."), this.omega, false);
			}
		}

		var additionTest = 0;
		try {
			if (this.omega !== null) {
				additionTest = 1;
				if (collapsed) {
					this.omega.add(out_rate, oldTime);
				} else {
					this.omega.add(rate, oldTime);
				}
			}
			if (this.alpha !== null) {
				additionTest = 2;

				if (collapsed) {
					this.alpha.subtract(in_rate, oldTime);
				} else {
					this.alpha.subtract(rate, oldTime);
				}
			}
		} catch (err) {
			//throw err;
			var stock = "";
			if (additionTest == 1) {
				stock = this.omega;
			} else if (additionTest == 2) {
				stock = this.alpha;
			}

			if (err == "MSG: Keys do not match for vector operation.") {
				error(getText("Incompatible vector keys for flow %s and connected stock %s.", "<i>[" + clean(this.dna.name) + "]</i>", "<i>[" + clean(stock.dna.name) + "]</i>"), this, false);
			} else {
				error(getText("Incompatible units for flow %s and connected stock %s. Stock has units of %s. The flow should have the equivalent units divided by some time unit such as Years.", "<i>[" + clean(this.dna.name) + "]</i>", "<i>[" + clean(stock.dna.name) + "]</i>", "<i>" + (stock.dna.units ? clean(stock.dna.units.toString()) : "unitless") + "</i>"), this, false);
			}

		}

		//console.log("null: "+this.id)
	} catch (err) {
		if (!err.substr) {
			throw err; //it's already an object, let's kick it up the chain
		}
		if (err.substr(0, 4) == "MSG:") {
			error(err.substr(4, err.length), this, true);
		} else {
			error(err, this, true);
		}
	}
});

function globalVars(primitive) {
	if (primitive instanceof Agent) {
		return { "-parent": varBank, "self": primitive };
	} else if (primitive.container) {
		return { "-parent": varBank, "self": primitive.container };
	} else {
		return varBank;
	}
}


"use strict";
/*

Copyright 2010-2020 Scott Fortmann-Roe. All rights reserved.

This file may distributed and/or modified under the
terms of the Insight Maker Public License (https://InsightMaker.com/impl).

*/

/*

	var t = new TaskQueue({start: new Material(0), end: new Material(20)});
	var a = new Task({
		name: "A",
		time: new Material(10),
		priority: 0,
		action: function(){
			console.log("A");
		}
	});
	var b = new Task({
		name: "B",
		time: new Material(10),
		priority: 1,
		action: function(){
			console.log("B");
			b.kill();
		}
	});
	var c = new Task({
		name: "C",
		time: new Material(10),
		priority: 1,
		action: function(){
			console.log("C");
		}
	});
	t.add(a);
	t.add(b);
	t.add(c);
	t.tasks.goMin();
	while(! t.completed()){
		t.step();
	}

	var t = new TaskQueue;
	t.add(new Task({
		name:"test 1",
		time: new Material(10),
		priority: -10,
		expires: 1,
		action: function(){},
		rollback: function(){}
	}));


var t =  new RedBlackTree();
function N(x){
	this.value = x;
}
N.prototype.toString = function(){
	return this.value.toString()
}
N.prototype.compare = function(other){
   if(this.value ==  other.value){
     return 0
   }else if(this.value < other.value){
		return -1
   }else{
		return 1;
   }
}
t.add(new N(10))
t.add(new N(5))
t.add(new N(2))
t.add(new N(11))
t.add(new N(3))
t.add(new N(12))
t.add(new N(15))
t.toString()

	var t = new TaskQueue(new Material(20));
	t.add(new Task({
		name:"test 1",
		time: new Material(10),
		priority: -10,
		expires: 1,
		action: function(){},
		rollback: function(){}
	}));

	var z = new Task({
		name:"test 12",
		time: new Material(10),
		priority: -10
	});
	t.add(z)
	
	t.add(new Task({
		name:"test 2",
		time: new Material(10),
		priority: -5
	}))
	t.add(new Task({
		name:"test 3",
		time: new Material(10),
		priority: -20
	}))

	t.add(new Task({
		name:"test b 1",
		time: new Material(20),
		priority: -10
	}))
	
	t.add(new Task({
		name:"test b 2",
		time: new Material(20),
		priority: -5
	}))
	t.add(new Task({
		name:"test b 3",
		time: new Material(20),
		priority: -20
	}))

	t.step();
	t.stepBack();
	t.step();
	t.stepBack();
	t.step();
	t.stepBack();
	t.step();
	t.stepBack();
	t.step();
	t.stepBack();
	t.step(); t.step()
	
	t.print();

	t.add(new Task({
		name:"test 4",
		time: new Material(10),
		priority: 0
	}))
	var q = new Task({
		name:"Early 1",
		time: new Material(5),
		priority: -10
	});
	t.add(q)
	t.add(new Task({
		name:"Late 1",
		time: new Material(15),
		priority: -10
	}))
	t.add(new Task({
		name:"test b 1",
		time: new Material(20),
		priority: -10
	}))
	
	t.add(new Task({
		name:"test b 2",
		time: new Material(20),
		priority: -5
	}))
	t.add(new Task({
		name:"test b 3",
		time: new Material(20),
		priority: -20
	}))
	t.add(new Task({
		name:"test b 4",
		time: new Material(20),
		priority: 0
	}))
	t.print()
	q.remove();
	z.remove();
	console.log("---")
	t.print();
	
	var t = new TaskQueue;
	scheduleRepeated(t, {name: "a", priority: -10}, new Material(0), new Material(10), new Material(30));
	scheduleRepeated(t, {name: "b", priority: -5}, new Material(0), new Material(10), new Material(30));
	t.print();
*/


function TaskQueue(config) {
	config = config || {};
	this.tasks = new RedBlackTree();
	this.onMoveEvents = [];
	this.setTime(config.start);
	this.debug = false;
	this.end = config.end;
	this.states = {};
}

TaskQueue.prototype.print = function () {
	console.log("Current Time: " + this.time.value);
	this.tasks.goMin();
	while (this.tasks.current() !== null) {
		console.log(this.tasks.current().name);
		console.log("    Time: " + this.tasks.current().time.value);
		console.log("    Priority: " + this.tasks.current().priority);
		if (isDefined(this.tasks.current().expires)) {
			console.log("    Expires: " + this.tasks.current().expires);
		}
		if (isDefined(this.tasks.current().skip)) {
			console.log("    Skip: " + this.tasks.current().skip);
		}
		this.tasks.next()
	}
}

TaskQueue.prototype.addEvent = function (event) {
	this.onMoveEvents.push(event)
}

TaskQueue.prototype.fireEvents = function (timeChange, oldTime, newTime) {
	if (this.debug) {
		console.log("Firing Events")
	}
	for (var i = 0; i < this.onMoveEvents.length; i++) {
		this.onMoveEvents[i](timeChange, oldTime, newTime);
	}
}

TaskQueue.prototype.setTime = function (t) {
	if (isUndefined(this.time) || neq(t, this.time)) {
		var oldTime = this.time;

		this.time = t;

		if (isDefined(oldTime)) {
			this.fireEvents(minus(t, oldTime), oldTime, t);
		}

	}
}

TaskQueue.prototype.moveTime = function (timeChange) {
	if (this.debug) {
		console.log("Shifting time by: " + timeChange.value);
	}
	this.moveTo(timePlus(this.time, timeChange));
}

TaskQueue.prototype.moveTo = function (newTime) {
	if (eq(this.time, newTime)) {
		return;
	} else {
		if (this.debug) {
			console.log("Shifting time to: " + newTime.value);
		}

		if (this.tasks.current() !== null) { // we have something defined
			var maxTime = this.tasks.max().time;
			var minTime = this.tasks.min().time;

			while (lessThan(this.time, newTime) && (!greaterThan(this.time, maxTime))) {
				this.step()
			}
			while (greaterThan(this.time, newTime) && greaterThan(this.time, minTime)) {
				this.stepBack();
			}
		}

		this.setTime(newTime);

		if (this.debug) {
			console.log("Time shift to  " + newTime.value + " completed.");
		}
	}
}

TaskQueue.prototype.add = function (task) {
	task.queue = this;

	this.tasks.add(task);
}

TaskQueue.prototype.step = function () {
	if (isUndefined(this.time)) {
		this.tasks.goMin();
		this.setTime(this.tasks.current().time);
	}

	var t = this.tasks.current().time;
	//debugger;

	//	console.log("--")
	if (this.tasks.current() !== null /*&& eq(t, this.tasks.current().time)*/) {
		var dead = this.tasks.current().deadAction;
		this.tasks.current().execute();
		if ((!dead) && this.tasks.current().timeShift) {
			this.tasks.current().timeShift()
			return;
		}
		//console.log(this.tasks.current());
		this.tasks.next();
	}

	//	console.log(this.tasks.current());

	if (this.tasks.current() !== null) {
		this.setTime(this.tasks.current().time);
	} else {
		//		console.log("null");
		this.tasks.next();
		//		console.log(this.tasks.current())
		this.setTime(mult(this.tasks.max().time, new Material(10)));
	}
}

TaskQueue.prototype.stepBack = function () {
	if (isUndefined(this.time)) {
		this.tasks.goMin();
		this.setTime(this.tasks.current().time);
		return;
	}

	if (this.tasks.current() === null) {
		this.tasks.goMax();
	} else {
		this.tasks.previous();
	}

	var t = this.tasks.current().time;
	while (this.tasks.current() !== null && eq(t, this.tasks.current().time)) {
		this.tasks.current().rollback();
		this.tasks.previous();
	}

	if (this.tasks.current() === null) {
		this.tasks.goMin();
	} else {
		this.tasks.next();
	}

	this.setTime(this.tasks.current().time);
}

TaskQueue.prototype.atStart = function () {
	return isUndefined(this.time) || this.tasks.current() === this.tasks.min();
}

TaskQueue.prototype.completed = function () {
	return isDefined(this.time) && (greaterThan(this.time, this.end) || (this.tasks.current() === null));
}

TaskQueue.prototype.remove = function (task) {
	//var c;
	if (task == this.tasks.current()) {
		//console.log("overlap!!!")
		//console.log(this.time.value);
		this.tasks.next();
		//if(this.tasks.current() !== null){
		//	this.setTime(this.tasks.current().time);
		//}else{
		//	this.tasks.next();
		//	this.setTime(mult(this.tasks.max().time, new Material(10)));
		//}
		//var c = this.tasks._cursor;
	}
	this.tasks.remove(task);
	//if(c){
	//	this.tasks._cursor = c;
	//console.log(this.time.value);
	//console.log(this.tasks.current().name);
	//}
}

var TaskId = 0
// new Take({name: "solver", time: t, action: fn(), rollback: fn(), priority: -10, expires: 1})
function Task(config) {
	this.id = TaskId++;
	this.name = config.name;
	this.time = config.time;
	this.action = config.action;
	this.reverse = config.rollback;
	this.priority = config.priority || 0; // Lower priorities will be run before higher priorities at the same time
	this.expires = config.expires; // if defined, the number of times this is called before it expires
	this.skip = config.skip;
	this.timeShift = config.timeShift;
	this.data = config.data; //optional data object to be carried along, the task scheduler makes no use of this
	this.blocker = config.blocker;

	this.deadAction = false; // once dead no longer executes
	this.deadReverse = false; // once dead no longer executes

	if (this.action) {
		this.action.task = this;
	}
	if (this.reverse) {
		this.action.reverse = this
	}

}

Task.prototype.execute = function () {
	if (this.action && (!this.deadAction) && ((!this.blocker) || !this.queue.states[this.blocker])) {
		if (isDefined(this.skip) && this.skip > 0) {
			this.skip--;
			if (this.queue.debug) {
				console.log("Skipping: " + this.name);
			}
		} else {
			if (this.queue.debug) {
				console.log("%c Executing: " + this.name + " (Time: " + this.time.value + ")", "color:blue");
			}

			if (isDefined(this.expires)) {
				this.expires--;
				if (this.queue.debug) {
					console.log("    Current count before expire: " + this.expires);
				}
				if (this.expires <= 0) {
					if (this.queue.debug) {
						console.log("    Task expired.");
					}
					this.deadAction = true;
				}
			}
		}


		this.action();
	}
}

Task.prototype.rollback = function () {
	if (this.reverse && (!this.deadReverse) && ((!this.blocker) || !this.queue.states[this.blocker])) {
		if (this.queue.debug) {
			console.log("Rolling back: " + this.name + " (Time: " + this.time.value + ")");
		}

		if (isDefined(this.expires)) {
			if (this.expires <= 0) {
				if (this.queue.debug) {
					console.log("    Rollback expired.");
				}
				this.deadReverse = true;
			}
		}

		this.reverse();
	}
}

Task.prototype.reschedule = function (newTime) {
	this.queue.remove(this);
	this.time = newTime;
	this.queue.add(this);
}

Task.prototype.remove = function () {
	this.queue.remove(this);
}

Task.prototype.kill = function () {
	this.deadAction = true;
	this.deadReverse = true;
}

Task.prototype.block = function (id) {
	id = id || this.blocker;
	this.queue.states[id] = true;
}

Task.prototype.unblock = function (id) {
	id = id || this.blocker;
	this.queue.states[id] = false;
}

Task.prototype.compare = function (other) {
	if (eq(other.time, this.time)) {
		if (other.priority == this.priority) {
			if (other.id == this.id) {
				return 0;
			} else if (other.id < this.id) {
				return 1;
			} else {
				return -1;
			}
		} else if (other.priority < this.priority) {
			return 1
		} else {
			return -1;
		}
	} else {
		if (lessThan(other.time, this.time)) {
			return 1
		} else {
			return -1;
		}
	}
	throw "Comparison error";
}

Task.prototype.toString = function () {
	return this.name + " - " + this.id;
}


function scheduleRepeated(queue, config, start, step, end) {
	var count = div(minus(end, start), step);
	for (var i = 0; i <= count; i++) {
		config.time = plus(start, mult(step, new Material(i)));
		queue.add(new Task(config));
	}
}



/*****
*
*   RedBlackNode.js
*
*   copyright 2004, Kevin Lindsey
*   licensing info available at: http://www.kevlindev.com/license.txt
*
*****/

/*****
*
*   class variables
*
*****/
RedBlackNode.VERSION = 1.0;


/*****
*
*   constructor
*
*****/
function RedBlackNode(value, parent) {
    this._left   = null;
    this._right  = null;
    this._value  = value;
    this._height = 1;
	this.parent = parent;
}


/*****
*
*   add
*
*****/
RedBlackNode.prototype.add = function(value) {
    var relation = value.compare(this._value);
    var addResult;
    var result;
    var newNode;

    if ( relation != 0 ) {
        if ( relation < 0 ) {
            if ( this._left != null ) {
                addResult = this._left.add(value);
                this._left = addResult[0];
				this._left.parent = this;
                newNode = addResult[1];
            } else {
                newNode = this._left = new RedBlackNode(value, this);
            }
        } else if ( relation > 0 ) {
            if ( this._right != null ) {
                addResult = this._right.add(value);
                this._right = addResult[0];
				this._right.parent = this;
                newNode = addResult[1];
            } else {
                newNode = this._right = new RedBlackNode(value, this);
            }
        }
        result = [this.balanceTree(), newNode];
    } else {
        result = [this, this];
    }

    return result;
};


/*****
*
*   balanceTree
*
*****/
RedBlackNode.prototype.balanceTree = function() {
    var leftHeight  = (this._left  != null) ? this._left._height  : 0;
    var rightHeight = (this._right != null) ? this._right._height : 0;
    var result;

    if ( leftHeight > rightHeight + 1 ) {
        result = this.swingRight();
    } else if ( rightHeight > leftHeight + 1 ) {
        result = this.swingLeft();
    } else {
        this.setHeight();
        result = this;
    }

    return result;
};


/*****
*
*   join
*
*****/
RedBlackNode.prototype.join = function(that) {
    var result;

    if ( that == null ) {
        result = this;
    } else {
        var top;

        if ( this._height > that._height ) {
            top = this;
            top._right = that.join(top._right);
			top._right.parent = top;
        } else {
            top = that;
            top._left = this.join(top._left);
			top._left.parent = top;
        }

        result = top.balanceTree();
    }

    return result;
};


/*****
*
*   moveLeft
*
*****/
RedBlackNode.prototype.moveLeft = function() {
    var right = this._right;
    var rightLeft = right._left;
    
    this._right = rightLeft;
	if(this._right){
		this._right.parent = this;
	}
	
    right._left = this;
	right._left.parent = right;
	
    this.setHeight();
    right.setHeight();

    return right;
};


/*****
*
*   moveRight
*
*****/
RedBlackNode.prototype.moveRight = function() {
    var left = this._left;
    var leftRight = left._right;
    
    this._left = leftRight;
	if(this._left){
		this._left.parent = this;
	}
	
    left._right = this;
	left._right.parent = left;
	
    this.setHeight();
    left.setHeight();

    return left;
};


/*****
*
*   remove
*
*****/
RedBlackNode.prototype.remove = function(value) {
    var relation = value.compare(this._value);
    var remResult;
    var result;
    var remNode;

    if ( relation != 0 ) {
        if ( relation < 0 ) {
            if ( this._left != null ) {
                remResult = this._left.remove(value);
                this._left = remResult[0];
				if(this._left){
					this._left.parent = this;
				}
                remNode = remResult[1];
            } else {
                remNode = null;
            }
        } else {
            if ( this._right != null ) {
                remResult = this._right.remove(value);
                this._right = remResult[0];
				if(this._right){
                	this._right.parent = this;
				}
                remNode = remResult[1];
            } else {
                remNode = null;
            }
        }

        result = this;
    } else {
        remNode = this;

        if ( this._left == null ) {
            result = this._right;
        } else if ( this._right == null ) {
            result = this._left;
        } else {
            result = this._left.join(this._right);
            this._left = null;
            this._right = null;
        }
    }

    if ( remNode != null ) {
        if ( result != null ) {
            return [result.balanceTree(), remNode];
        } else {
            return [result, remNode];
        }
    } else {
        return [this, null];
    }
};


/*****
*
*   setHeight
*
*****/
RedBlackNode.prototype.setHeight = function() {
    var leftHeight  = (this._left  != null) ? this._left._height  : 0;
    var rightHeight = (this._right != null) ? this._right._height : 0;
    
    this._height = (leftHeight < rightHeight) ? rightHeight + 1 : leftHeight + 1;
};


/*****
*
*   swingLeft
*
*****/
RedBlackNode.prototype.swingLeft = function() {
    var right      = this._right;
    var rightLeft  = right._left;
    var rightRight = right._right;
    var left       = this._left;

    var leftHeight       = (left       != null ) ? left._height       : 0;
    var rightLeftHeight  = (rightLeft  != null ) ? rightLeft._height  : 0;
    var rightRightHeight = (rightRight != null ) ? rightRight._height : 0;

    if ( rightLeftHeight > rightRightHeight ) {
        this._right = right.moveRight();
		this._right.parent = this;
    }

    return this.moveLeft();
};


/*****
*
*   swingRight
*
*****/
RedBlackNode.prototype.swingRight = function() {
    var left      = this._left;
    var leftRight = left._right;
    var leftLeft  = left._left;
    var right     = this._right;

    var rightHeight     = (right     != null ) ? right._height     : 0;
    var leftRightHeight = (leftRight != null ) ? leftRight._height : 0;
    var leftLeftHeight  = (leftLeft  != null ) ? leftLeft._height  : 0;

    if ( leftRightHeight > leftLeftHeight ) {
        this._left = left.moveLeft();
		this._left.parent = this;
    }

    return this.moveRight();
};


/*****
*
*   traverse
*
*****/
RedBlackNode.prototype.traverse = function(func) {
    if ( this._left  != null ) this._left.traverse(func);
    func(this);
    if ( this._right != null ) this._right.traverse(func);
};


/*****
*
*   toString
*
*****/
RedBlackNode.prototype.toString = function() {
    return this._value.toString();
};

RedBlackNode.prototype.validateParents = function(){
	if(this._right){
		if(this._right.parent !== this){
			console.log("Invalid right");
			console.log(this)
		}
		this._right.validateParents();
	}
	if(this._left){
		if(this._left.parent !== this){
			console.log("Invalid left");
			console.log(this)
		}
		this._left.validateParents();
	}
}



/*****
*
*   RedBlackTree.js
*
*   copyright 2004, Kevin Lindsey
*   licensing info available at: http://www.kevlindev.com/license.txt
*
*****/

/*****
*
*   class variables
*
*****/
RedBlackTree.VERSION = 1.0;


/*****
*
*   constructor
*
*****/
function RedBlackTree() {
    this._root      = null;
    this._cursor    = null;
}


/*****  private methods *****/

/*****
*
*   _findNode
*
*****/
RedBlackTree.prototype._findNode = function(value) {

    var result = this._root;

    
    while ( result != null ) {
        var relation = value.compare(result._value);

        if ( relation != 0 ) {
            if ( relation < 0 ) {
                result = result._left;
            } else {
                result = result._right;
            }
        } else {
            break;
        }
    }

    return result;
};


/*****
*
*   _maxNode
*
*****/
RedBlackTree.prototype._maxNode = function(node) {
    if ( node == null ) node = this._root;

    if ( node != null ) {
        while ( node._right != null ) {
            node = node._right;
        }
    }

    return node;
};


/*****
*
*   _minNode
*
*****/
RedBlackTree.prototype._minNode = function(node) {
    if ( node == null ) node = this._root;

    if ( node != null ) {
        while ( node._left != null ) {
            node = node._left;
        }
    }

    return node;
};


/*****
*
*   _nextNode
*
*****/
RedBlackTree.prototype._nextNode = function(node) {
    if ( node != null ) {
        if ( node._right != null ) {
            node = this._minNode(node._right);
        } else {
			//console.log("--")
			//console.log(node._value.value)
            while ( node.parent != null && node.parent._right === node ) {
                node = node.parent;

			//	console.log(node._value.value)
            }

            node = node.parent;
			//console.log("-")
			//console.log(node._value.value)
        }
    } else {
        node = this._minNode(this._root);
    }

    return node;
};


/*****
*
*   _previousNode
*
*****/
RedBlackTree.prototype._previousNode = function(node) {
    if ( node != null ) {
        if ( node._left != null ) {
            node = this._maxNode(node._left);
        } else {
            
            while ( node.parent != null && node.parent._left === node ) {
                node = node.parent;
            }

            node = node.parent;
        }
    } else {
        node = this._maxNode(this._root);
    }

    return node;
};


/*****  public methods  *****/

/*****
*
*   add
*
*****/
RedBlackTree.prototype.add = function(value) {
    var result;
    
    if ( this._root == null ) {
        result = this._root = new RedBlackNode(value);
    } else {
        var addResult = this._root.add(value);

        this._root = addResult[0];
		this._root.parent = null;
        result = addResult[1];
    }

    return result;
};


/*****
*
*   find
*
*****/
RedBlackTree.prototype.find = function(value) {
    var node = this._findNode(value);
    
    return ( node != null ) ? node : null;
};


/*****
*
*   findNext
*
*****/
RedBlackTree.prototype.findNext = function(value) {
    var current = this._findNode(value, true);

    current = this._nextNode(current);

    return (current != null ) ? current._value : null;
};


/*****
*
*   findPrevious
*
*****/
RedBlackTree.prototype.findPrevious = function(value) {
    var current = this._findNode(value, true);

    current = this._previousNode(current);

    return (current != null ) ? current._value : null;
};


/*****
*
*   max
*
*****/
RedBlackTree.prototype.max = function() {
    var result = this._maxNode();

    return ( result != null ) ? result._value : null;
};


/*****
*
*   min
*
*****/
RedBlackTree.prototype.min = function() {
    var result = this._minNode();

    return ( result != null ) ? result._value : null;
};


/*****
*
*   next
*
*****/
RedBlackTree.prototype.next = function() {
    this._cursor = this._nextNode(this._cursor);

    return ( this._cursor ) ? this._cursor._value : null;
};


/*****
*
*   previous
*
*****/
RedBlackTree.prototype.previous = function() {
    this._cursor = this._previousNode(this._cursor);

    return ( this._cursor ) ? this._cursor._value : null;
};


/*****
*
*   remove
*
*****/
RedBlackTree.prototype.remove = function(value) {
    var result;

    if ( this._root != null ) {
        var remResult = this._root.remove(value);

        this._root = remResult[0];
        result = remResult[1];
    } else {
        result = null;
    }

    return result;
};


/*****
*
*   set
*
*****/
RedBlackTree.prototype.goMin = function() {
    this._cursor = this._minNode(this._root);
};

RedBlackTree.prototype.goMax = function() {
	this._cursor = this._maxNode(this._root);
};


RedBlackTree.prototype.current = function() {
    return this._cursor?this._cursor._value:null;
};



/*****
*
*   traverse
*
*****/
RedBlackTree.prototype.traverse = function(func) {
    if ( this._root != null ) {
        this._root.traverse(func);
    }
};


/*****
*
*   toString
*
*****/
RedBlackTree.prototype.toString = function() {
    var lines = [];

    if ( this._root != null ) {
        var indentText = "  ";
        var stack = [[this._root, 0, "^"]];

        while ( stack.length > 0 ) {
            var current = stack.pop();
            var node    = current[0];
            var indent  = current[1];
            var line    = "";

            for ( var i = 0; i < indent; i++ ) {
                line += indentText;
            }
            
            line += current[2] + "(" + node.toString() + ")";
            lines.push(line);

            if ( node._right != null ) stack.push([node._right, indent+1, "R"]);
            if ( node._left  != null ) stack.push([node._left,  indent+1, "L"]);
        }
    }
    
    return lines.join("\n");
};

RedBlackTree.prototype.validateParents = function(){
	if(! (this._root.parent == null)){
		console.log("Invalid root node parent");
		this._root.validateParents();
	}
	console.log("done");
}

"use strict";
/*

Copyright 2010-2020 Scott Fortmann-Roe. All rights reserved.

This file may distributed and/or modified under the
terms of the Insight Maker Public License (https://InsightMaker.com/impl).

*/



var simulate;
var model;

var strictUnits = null;
var strictAgentResolution = false;
var strictLinks = false;


function runSimulation(config) {

	try {
		return innerRunSimulation(config); //have an inner function call to escape try-catch performance pathologies
	} catch (err) {
		console.error(err);
		return checkErr(err, config);
	}
}

function checkErr(err, config, results) {
	if (simulate) {
		simulate.terminate();
	}
	if (isLocal()) {
		console.log(err);
	}

	var errOut;
	if (err.msg) {
		errOut = {
			error: err.msg,
			errorPrimitive: isDefined(err.primitive) ? findID(err.primitive.id) : null
		};
	} else {
		errOut = {
			error: getText("An unknown simulation error occurred. Please report this issue to the Insight Maker team."),
			errorPrimitive: null
		};
		if (typeof err == "string") {
			if (err.substr(0, 4) === "MSG:") {
				errOut.error = err.substr(4);
			}
			err = {
				msg: errOut.error
			};
		} else {
			err.msg = errOut.msg;
		}
	}

	if (!simulate.results) {
		simulate.results = {};
	}
	simulate.results.error = err.msg;


	if (config.onError) {
		config.onError(errOut);
	}

	if (!config.silent) {
		handleErrorObject(err)
	} else {
		return errOut;
	}
}

var timeUnits = null;

function innerRunSimulation(config) {

	evaluatingLine = null;

	simulate = new Simulator();

	if (config.resultsWindow) {
		simulate.resultsWindow = config.resultsWindow;
	}

	bootCalc();


	allPlaceholders = [];
	model = {};
	model.submodels = {
		"base": {
			id: "base",
			"DNAs": [],
			agents: [{
				children: [],
				childrenId: {}
			}],
			size: 1
		}
	};
	var setting = getSetting();

	strictUnits = isTrue(setting.getAttribute("StrictUnits"));
	//strictUnits = false; //Historical mode, can do "{1 cow}+5"
	strictAgentResolution = isTrue(setting.getAttribute("StrictAgentResolution"));
	//strictAgentResolution = false // Historical mode, [stoctk].move() will resolve the stock to the agent
	strictLinks = isTrue(getSetting().getAttribute("StrictLinks"));
	//strictLinks = false // All links are implicitly bidirectional


	//Begin custom units setup

	var customUnits = setting.getAttribute("Units");
	if (isDefined(customUnits)) {
		var units = setting.getAttribute("Units").split("\n");
		var newSources = [],
			newScalings = [],
			newTargets = [];
		for (var i = 0; i < units.length; i++) {
			var us = units[i].split("<>");
			if (us[2] && us[2].trim() != "") { //It has a synonym, otherwise we don't need to add it
				newSources.push(us[0]);
				newScalings.push(us[1]);
				var newU = createUnitStore(us[2]);
				if (isUndefined(newU)) {
					throw {
						msg: 'You cannot define a units synonym for "unitless".'
					};
				} else {
					newTargets.push(newU.toStringShort());
				}
			}
		}
		loadUnits(newSources, newTargets, newScalings);

	}

	//End custom units setup

	//Set Up simulation time settings

	timeUnits = setting.getAttribute("TimeUnits").toLowerCase();
	var u = getUnitStore([timeUnits], [1]);
	model["timeLength"] = new Material(sn("#i" + setting.getAttribute("TimeLength")), u);
	model["timeStart"] = new Material(sn("#i" + setting.getAttribute("TimeStart")), u);
	model["timeStep"] = new Material(sn("#i" + setting.getAttribute("TimeStep")), u);
	if (setting.getAttribute("TimePause") > 0) {
		model["timePause"] = new Material(sn("#i" + setting.getAttribute("TimePause")), u);
	}
	simulate.timeUnits = u;


	//End Simulation time settings setup

	var solvers = {}; // Simulation solvers
	solvers.base = {
		timeStep: new Material(sn("#i" + setting.getAttribute("TimeStep")), u),
		algorithm: setting.getAttribute("SolutionAlgorithm"),
		id: "base",
		maxLoaded: -1
	};

	model.solvers = solvers;
	var folders = findType("Folder");
	for (var i = 0; i < folders.length; i++) {
		var json = folders[i].getAttribute("Solver");
		if (json) {
			var solver = JSON.parse(json);
			if (solver.enabled) {
				solvers[folders[i].id] = solver;
				solvers[folders[i].id].timeStep = new Material(sn("#i" + solvers[folders[i].id].timeStep), u);
				solvers[folders[i].id].id = folders[i].id;
				solvers[folders[i].id].maxLoaded = -1;
			}
		}
	}

	var solverKeys = Object.keys(solvers);
	for (var i = 0; i < solverKeys.length; i++) {
		var solver = solvers[solverKeys[i]];

		solver.userTimeStep = solver.timeStep;
		if (solver.algorithm == "RK4") {
			solver.RKOrder = 4;
		} else {
			solver.RKOrder = 1;
		}
		if (solver.RKOrder == 4) {
			solver.timeStep = div(solver.userTimeStep, new Material(2));
		} else {
			solver.timeStep = solver.userTimeStep;
		}

		solver.stocks = [];
		solver.flows = [];
		solver.transitions = [];
		solver.actions = [];
		solver.states = [];
		solver.valued = [];
		solver.displayed = [];
	}

	if (isDefined(setting.getAttribute("Macros"))) {
		// try {
			evaluateMacros(setting.getAttribute("Macros"));
		// } catch (err) {
		// 	var annotations = [];

		// 	var msg = getText("An error with the macros prevented the simulation from running.");

		// 	if (err.msg) {
		// 		msg = msg + "<br/><br/>" + err.msg;
		// 	} else if (err.toString && err.toString().substr(0, 4) == "MSG:") {
		// 		msg = msg + "<br/><br/>" + err.toString().substr(4);
		// 	} else if (err.toString) {
		// 		if (err.match && err.match(/line (\d+)/i)) {
		// 			var l = err.match(/line (\d+)/i)[1];

		// 			annotations.push({
		// 				type: "error",
		// 				row: (l !== undefined) ? (l - 1) : (evaluatingLine - 1),
		// 				text: err
		// 			})
		// 		}
		// 	}

		// 	showMacros(annotations);

		// 	throw {
		// 		msg: msg
		// 	};

		// }
	}

	var modelItems = primitives();

	for (var i = 0; i < modelItems.length; i++) {

		if (modelItems[i].value.nodeName == "Agents") {
			var item = modelItems[i];

			var id = item.getAttribute("Agent");
			var z = parseInt(id, 10);
			if (z == id) {
				id = z;
			}
			if (isUndefined(id)) {
				throw {
					msg: getText("You must select a base agent for the primitive %s. You can create agent definitions using Folder primitives.", "<i>" + clean(item.getAttribute("name")) + "</i>"),
					primitive: item,
					showEditor: false
				};
			}

			var x = new Agents();

			x.dna = new DNA(item, id);
			x.id = item.id;

			x.agentId = id;
			x.createIds();

			x.dna.solver = folderSolvers(item, solvers);
			x.dna.solver.displayed.push(x);

			x.geoDimUnits = item.getAttribute("GeoDimUnits");
			x.geoDimUnitsObject = createUnitStore(item.getAttribute("GeoDimUnits"));
			x.geoWidth = simpleUnitsTest(simpleEquation(item.getAttribute("GeoWidth")), x.geoDimUnitsObject, item);
			x.geoHeight = simpleUnitsTest(simpleEquation(item.getAttribute("GeoHeight")), x.geoDimUnitsObject, item);
			x.halfWidth = div(x.geoWidth, new Material(2));
			x.halfHeight = div(x.geoHeight, new Material(2));
			x.geoWrap = isTrue(item.getAttribute("GeoWrap"));
			x.placement = item.getAttribute("Placement");
			x.placementFunction = item.getAttribute("PlacementFunction");
			x.network = item.getAttribute("Network");
			x.networkFunction = item.getAttribute("NetworkFunction");
			x.agentBase = findID(id).getAttribute("AgentBase") || "";
			if (x.agentBase.trim() != "") {
				x.agentBase = simpleEquation(x.agentBase, varBank);
			}

			var agentCells = getChildren(findID(id));

			x.DNAs = [];
			for (var j = 0; j < agentCells.length; j++) {
				if (modelType(agentCells[j].value.nodeName)) {
					x.DNAs.push(getDNA(agentCells[j], solvers));
				}
				if (agentCells[j].value.nodeName == "State") {
					x.stateIds.push(agentCells[j].id);
				}
			}

			x.size = item.getAttribute("Size");

			x.agents = [];

			x.dna.agents = x;

			model.submodels[item.id] = x;
			model.submodels.base.DNAs.push(x.dna);
		} else if (!inAgent(modelItems[i])) {
			if (modelType(modelItems[i].value.nodeName)) {
				model.submodels.base.DNAs.push(getDNA(modelItems[i], solvers));
			}
		}
	};


	for (var submodel in model.submodels) {
		submodel = model.submodels[submodel];
		for (var j = 0; j < submodel.size; j++) {
			var agent;
			if (submodel.id == "base") {
				agent = submodel.agents[0];
			} else {
				agent = new Agent();
				agent.container = submodel;
				agent.index = j;
				agent.children = [];
				agent.childrenId = {};
				agent.agentId = submodel.id;
				agent.createIds();
				if (submodel.agentBase) {
					agent.vector.parent = submodel.agentBase;
				}

				submodel.agents.push(agent);
			}
			for (var i = 0; i < submodel.DNAs.length; i++) {
				decodeDNA(submodel.DNAs[i], agent);
			}
		}
	}


	// Initialize Actual Simulation
	simulate.setup({
		model: model
	});

	for (var submodel in model.submodels) {
		submodel = model.submodels[submodel];
		for (var j = 0; j < submodel.size; j++) {
			for (var i = 0; i < submodel.DNAs.length; i++) {
				linkPrimitive(submodel.agents[j].children[i], submodel.DNAs[i]);
			}
		}
	}

	for (var submodel in model.submodels) {
		submodel = model.submodels[submodel];
		for (var j = 0; j < submodel.size; j++) {
			setAgentInitialValues(submodel.agents[j]);
		}
	}

	for (var submodel in model.submodels) {
		if (submodel != "base") {
			try {
				buildNetwork(model.submodels[submodel]);
			} catch (err) {
				if (isLocal()) {
					console.log(err);
				}
				var msg = getText("An error with the custom network function prevented the simulation from running.");
				if (err.msg) {
					msg = msg + "<br/><br/>" + err.msg;
				} else if (err.toString().substr(0, 4) == "MSG:") {
					msg = msg + "<br/><br/>" + err.toString().substr(4);
				}

				throw {
					msg: msg,
					primitive: model.submodels[submodel].cell,
					showEditor: false
				};
			}


			try {

				buildPlacements(model.submodels[submodel]);

			} catch (err) {
				if (isLocal()) {
					console.log(err);
				}
				var msg = getText("An error with the agent placement function prevented the simulation from running.");
				if (err.msg) {
					msg = msg + "<br/><br/>" + err.msg;
				} else if (err.toString().substr(0, 4) == "MSG:") {
					msg = msg + "<br/><br/>" + err.toString().substr(4);
				}

				throw {
					msg: msg,
					primitive: model.submodels[submodel].cell,
					showEditor: false
				};
			}

		}
	}



	simulate.results = {
		Time: [],
		data: []
	};
	simulate.displayInformation = {
		ids: [],
		times: [],
		objects: []
	};
	model.submodels["base"].agents[0].children.forEach(function (x) {
		if (!((x instanceof Action) || (x instanceof Transition))) {
			simulate.displayInformation.objects.push(x);
			simulate.displayInformation.ids.push(x.id);
			var data = {};
			if (x instanceof Agents) {
				data.width = x.geoWidth;
				data.height = x.geoHeight
				data.units = x.geoDimUnitsObject;
				data.states = x.states();
			} else {
				x.dna.solver.displayed.push(x);
			}
			simulate.results[x.id] = {
				data: data,
				results: [],
				dataMode: "float"
			};
		}
	});



	if (config.silent) {
		if (config.onPause) {
			simulate.run(config);
		} else {
			return formatSimResults(simulate.run(config));
		}

	} else {


		var count = div(model.timeLength, model.timeStep);
		for (var i = 0; i <= count; i++) {
			simulate.displayInformation.times.push(plus(model.timeStart, mult(model.timeStep, new Material(i))).value);
		}


		var oldSuccess = config.onSuccess;
		config.onSuccess = function (res) {
			updateDisplayed(null);

			simulate.resultsWindow.results = formatSimResults(simulate.results);

			//simulate.tasks.print()

			if (oldSuccess) {
				oldSuccess(res)
			};
		}

		config.onCompletedFirstPass = function () {
			if (config.resultsWindow) {
				//console.log("foo")

				config.resultsWindow.displayInformation.store.suspendEvents();
				config.resultsWindow.displayInformation.store.maxLoaded = -1

				config.resultsWindow.displayInformation.store.clearFilter();

				config.resultsWindow.displayInformation.store.removeAll();

				simulate.displayInformation = config.resultsWindow.displayInformation;

				var scripter = config.resultsWindow.displayInformation.scripter;

				scripter.simulator = simulate;

				scripter.playBut.setGlyph(0xf04c);
				scripter.combo.setValue(-1);
				scripter.time = 0;
				scripter.timeIndex = 0;
				scripter.isFinished = false;
				scripter.updatingSlider = true;
				scripter.slider.setValue(scripter.minTime);
				scripter.updatingSlider = false;

				//console.log("Changed")
				scripter.advanceTimer();
				//console.log("Changed 2")

				config.resultsWindow.displayInformation.store.resumeEvents();
				//window.x = config.resultsWindow.displayInformation.store;

				clearInterval(scripter.animInter);
				scripter.animInter = setInterval(function () {
					scripter.advanceTimer()
				}, 200);


				for (var i = 0; i < simulate.displayInformation.origIds.length; i++) {

					var id = simulate.displayInformation.origIds[i];
					var object = simulate.displayInformation.objects[i];
					var dna = object.dna;

					if (dna.type == "Agents") {
						simulate.results[id].states = object.stateIds;

						simulate.displayInformation.agents[id.toString()].data = simulate.results[id].data;
						simulate.displayInformation.agents[id.toString()].results = simulate.results[id].results;


					} else if ((simulate.results.data[0][id] instanceof Vector) && simulate.results.data[0][id].names) {

						var names = simulate.results.data[0][id].fullNames();

						simulate.results[id].indexedFullNames = names.slice();
						for (var j = 0; j < names.length; j++) {
							names[j] = names[j].join(", ");
						}
						simulate.results[id].indexedNames = names;

					}
				}

			} else {
				simulate.displayInformation.colors = [];
				simulate.displayInformation.headers = [];
				simulate.displayInformation.agents = [];
				simulate.displayInformation.displayedHeaders = [];
				simulate.displayInformation.displayedIds = [];
				simulate.displayInformation.renderers = [];
				simulate.displayInformation.elementIds = [];
				simulate.displayInformation.res = simulate.results;

				var ids = [];

				simulate.displayInformation.origIds = simulate.displayInformation.ids.slice();
				for (var i = 0; i < simulate.displayInformation.origIds.length; i++) {
					var id = simulate.displayInformation.origIds[i];
					var object = simulate.displayInformation.objects[i];
					var dna = object.dna;

					simulate.displayInformation.displayedIds.push(id);
					simulate.displayInformation.displayedHeaders.push(dna.name);

					//console.log(simulate.results);

					if (dna.type == "Agents") {
						var states = object.stateIds;

						simulate.results[id].states = states;

						for (var j = 0; j < states.length; j++) {
							var innerItem = findID(states[j]);
							ids.push(id);
							simulate.displayInformation.elementIds.push("e" + id + "-" + states[j]);
							simulate.displayInformation.headers.push(getName(innerItem));
							simulate.displayInformation.colors.push(getLineColor(innerItem));
							if (simulate.results[id].dataMode == "float") {
								simulate.displayInformation.renderers.push(commaStr);
							} else if (simulate.results[id].dataMode == "agents") {
								simulate.displayInformation.renderers.push(function (x) {
									return x;
								});
							} else {
								simulate.displayInformation.renderers.push(undefined);
							}
						}

						//console.log("--")
						//console.log(simulate.results[id].results);

						simulate.displayInformation.agents[id.toString()] = {
							id: id,
							item: dna.cell,
							data: simulate.results[id].data,
							results: simulate.results[id].results
						};


					} else if ((simulate.results.data[0][id] instanceof Vector) && simulate.results.data[0][id].names) {

						var col = getLineColor(dna.cell);

						var names = simulate.results.data[0][id].fullNames();

						simulate.results[id].indexedFullNames = names.slice();
						for (var j = 0; j < names.length; j++) {
							names[j] = names[j].join(", ");
						}
						simulate.results[id].indexedNames = names;

						for (var j = 0; j < names.length; j++) {
							ids.push(id);
							simulate.displayInformation.elementIds.push("e" + id + "-" + j);
							simulate.displayInformation.headers.push(dna.name + " (" + names[j] + ")");
							simulate.displayInformation.colors.push(col);
							simulate.displayInformation.renderers.push(commaStr);
						}

					} else {
						ids.push(id)
						simulate.displayInformation.elementIds.push("e" + id);
						simulate.displayInformation.headers.push(dna.name);
						simulate.displayInformation.colors.push(getLineColor(dna.cell));
						if (simulate.results[id].dataMode == "float") {
							simulate.displayInformation.renderers.push(commaStr);
						} else {
							simulate.displayInformation.renderers.push(undefined);
						}
					}

				}

				var storeFields = [{
					type: "float",
					name: "Time"
				}, {
					type: "int",
					name: "id"
				}];

				for (var i = 0; i < simulate.displayInformation.elementIds.length; i++) {
					storeFields.push({
						type: 'auto',
						name: simulate.displayInformation.elementIds[i],
						defaultValue: undefined
					});
				}


				simulate.displayInformation.store = new Ext.data.Store({
					fields: storeFields,
					data: undefined
				});
				simulate.displayInformation.store.maxLoaded = -1;
				simulate.displayInformation.ids = ids;
			}



		}



		var oldStep = config.onStep;
		config.onStep = function (solver) {

			// See if we should sleep to let the main UI update

			var updated = false;
			var progress = simulate.progress();


			if (!simulate.shouldSleep) {
				var timeTaken = new Date().getTime() - simulate.wakeUpTime;

				if (((!simulate.resultsWindow) && timeTaken > 100) || timeTaken > 600) {

					updateDisplayed(solver);
					updated = true;


					simulate.timer = setTimeout(function () {
						simulate.resume();
					}, 20);

					simulate.sleep();
				}
			}

			if (progress == 1 && !updated) {
				updateDisplayed(solver);
			}

			// Call any user defined step function

			if (oldStep) {
				oldStep(solver);
			}
		}

		var oldError = config.onError;
		config.onError = function (res) {

			try {
				for (var solver in simulate.model.solvers) {
					updateDisplayed(simulate.model.solvers[solver]);
				}
			} catch (err) {

			}

			if (simulate.resultsWindow) {
				simulate.resultsWindow.scripter.pause(false);
				simulate.resultsWindow.scripter.finished();
			}

			if (oldError) {
				oldError(res);
			};
		}

		simulate.run(config);
	}


}

function formatSimResults(res) {
	var makeMap = function (returnNonVecs) {
		return function (x) {
			if (x instanceof Vector) {
				if (x.names) {
					var r = {};
					for (var i = 0; i < x.names.length; i++) {
						r[x.names[i]] = vecMap(x.items[i]);
					}
					return r;
				} else {
					return x.items.slice().map(vecMap);
				}
			} else {
				if (returnNonVecs) {
					return x;
				} else {
					return undefined;
				}
			}
		}
	}

	var vecMap = makeMap(true);

	res = deepClone({}, res, 3, makeMap(false));

	if (isUndefined(res.error)) {
		res.error = "none";
		res.errorPrimitive = null;
	}
	res.names = {};
	var items = model.submodels["base"].agents[0].children;
	for (var i = 0; i < items.length; i++) {
		res.names[items[i].name] = items[i].id;
	}
	res.value = function (item) {
		return this[item.id].results;
	};
	res.lastValue = function (item) {
		return this[item.id].results[this[item.id].results.length - 1];
	};
	if (res.Time) {
		res.periods = res.Time.length;
		res.times = res.Time;
	}

	return res;
}

function createUnitStore(u) {
	if ((!u) || u.trim() == "" || u.trim().toLowerCase() == "unitless") {
		return undefined;
	}
	return simpleEquation("{1 " + u + "}").units;
}

function simpleEquation(eq, scope, primitiveBank, tree) {
	if (!scope) {
		scope = {};
	}
	if (!primitiveBank) {
		primitiveBank = {};
	}
	if (!tree) {
		tree = trimTree(createTree(eq), primitiveBank);
	}

	var res = evaluateTree(tree, scope);

	return res;
}

function simpleNum(mat, units) {
	if (mat instanceof Vector) {
		return new Vector(mat.items.map(function (x) {
			return simpleNum(x, units);
		}));
	}

	if ((!units) && (mat.units)) {
		throw (getText("The result of the calculation has units %s, but no units are specified for the calculation. Please set the units for the calculation so we can determine the proper output.", mat.units.toString()));
	}

	if (!mat.units) {
		return 0 + mat.value;
	} else {

		mat.units.addBase();
		units.addBase();

		return 0 + fn["*"](mat.value, fn["/"](sn("#e" + mat.units.toBase), units.toBase));
	}

}

function simpleUnitsTest(mat, units, primitive, showEditor) {
	if (mat instanceof Vector) {
		return new Vector(mat.items.map(function (x) {
			return simpleUnitsTest(x, units, primitive, showEditor);
		}));
	}


	if ((!mat.units) && (!units)) {
		return mat;
	} else if ((!mat.units)) {
		mat.units = units;
		return mat;
	} else if (mat.units === units) {
		return mat;
	} else {
		var scale = convertUnits(mat.units, units, false); //XXX fixme true
		if (scale == 0) {
			if (isLocal()) {
				console.log(mat.units);
				console.log(units);
			}
			throw {
				msg: getText("Wrong units generated. Expected %s, and got %s.", "<i>" + clean(units ? units.toString() : "unitless") + "</i>", "<i>" + clean(mat.units ? mat.units.toString() : "unitless") + "</i>"),
				primitive: primitive,
				showEditor: showEditor
			};
		} else {
			//console.log("----+")
			mat.value = mat.value * scale;
			mat.units = units;
			return mat;
		}
	}
}

function handleErrorObject(err) {
	if (isLocal()) {
		console.log(err);
		if (console.trace) {
			console.trace();
		}
	}
	if (err.msg) {
		if (isDefined(err.primitive)) {
			var cell = findID(err.primitive.id)
			highlight(cell);
			if (err.showEditor) {
				//console.log( err);
				showEditor(cell, [{
					type: "error",
					row: (err.line !== undefined) ? (err.line - 1) : (evaluatingLine - 1),
					text: err.details ? err.details : "Error"
				}]);
			}
		}
		mxUtils.alert(err.msg);
	} else if (err.error) {
		mxUtils.alert(err);
	} else {
		mxUtils.alert(getText("An unknown model simulation error occurred. Please report this issue to the Insight Maker team."));
	}
}

function evaluateMacros(macros) {
	evaluateTree(trimTree(createTree(macros), {}), varBank);
}

function DNA(cell, id) {
	this.type = cell.value.nodeName;
	this.cell = cell;
	id = id || cell.id;
	var x = parseInt(cell.id, 10);
	if (x == cell.id) {
		this.id = x;
	} else {
		this.id = id;
	}
	this.name = cell.getAttribute("name");
	this.units = null;

}

function getDNA(cell, solvers) {
	var dna = new DNA(cell);
	dna.solver = folderSolvers(cell, solvers);
	if (cell) {
		var p = getParent(cell);
		if (p) {
			dna.frozen = isTrue(getFrozen(p));
		}
	}

	if (dna.type === "Variable" || dna.type == "Flow") {
		if (isTrue(cell.getAttribute("ShowSlider"))) {
			dna.slider = true;
		}
	}

	if (dna.type == "Flow" || dna.type == "Transition") {
		if (cell.target !== null) {
			dna.targetId = orig(cell.target).id;
		}
		if (cell.source !== null) {
			dna.sourceId = orig(cell.source).id;
		}
	}

	if (dna.type == "Converter") {
		dna.value = getValue(cell);
	} else {
		try {
			dna.value = createTree(getValue(cell));
		} catch (err) {
			if (isLocal()) {
				//console.log(this);
				//console.log(eq);
				//console.log(neighborhood);
				console.log(err);
			}
			var msg = getText("The primitive %s has an equation error that must be corrected before the model can be run.", "<i>[" + clean(dna.name) + "]</i>");
			if (err.substr && err.substr(0, 4) == "MSG:") {
				msg += "<br/><br/>" + err.toString().substr(4);
			}

			var l = undefined;
			if (err.match && err.match(/line (\d+)/i)) {
				l = err.match(/line (\d+)/i)[1];
			}

			error(msg, cell, true, l, err.match ? err : undefined);

		}
	}


	if (dna.type == "Action") {
		dna.trigger = cell.getAttribute("Trigger");
		dna.repeat = isTrue(cell.getAttribute("Repeat"));
		dna.recalculate = isTrue(cell.getAttribute("Recalculate")) || dna.trigger == "Condition";
		try {
			dna.triggerValue = createTree("" + cell.getAttribute("Value"));
		} catch (err) {
			var msg = getText("The trigger for %s has an equation error that must be corrected before the model can be run.", "<i>[" + clean(dna.name) + "]</i>");
			if (err.substr && err.substr(0, 4) == "MSG:") {
				msg += "<br/><br/>" + err.toString().substr(4);
			}
			error(msg, dna.cell, false, l);
		}
	} else if (dna.type == "Transition") {
		dna.trigger = cell.getAttribute("Trigger");
		dna.repeat = isTrue(cell.getAttribute("Repeat"));
		dna.recalculate = isTrue(cell.getAttribute("Recalculate")) || dna.trigger == "Condition";
	} else if (dna.type == "State") {
		if (isUndefined(cell.getAttribute("Residency")) || cell.getAttribute("Residency").trim() == "") {
			dna.residency = null;
		} else {
			try {
				dna.residency = evaluateTree(trimTree(createTree(cell.getAttribute("Residency")), {}));
				if (!dna.residency.units) {
					dna.residency.units = simulate.timeUnits;
				}
				if (eq(dna.residency, new Material(0, simulate.timeUnits))) {
					dna.residency = null;
				}
			} catch (err) {
				if (isLocal()) {
					console.log(err);
				}

				throw ({
					msg: getText("Invalid state residency."),
					primitive: cell,
					showEditor: false
				});
			}
		}
	} else if (dna.type == "Stock") {
		dna.nonNegative = isTrue(cell.getAttribute("NonNegative"));
		if (cell.getAttribute("StockMode") == "Conveyor") {
			dna.stockType = "Conveyor";
			try {
				dna.delay = evaluateTree(trimTree(createTree(cell.getAttribute("Delay")), {}));
				if (!dna.delay.units) {
					dna.delay.units = simulate.timeUnits;
				}
			} catch (err) {
				if (isLocal()) {
					console.log(err);
				}

				throw ({
					msg: getText("Invalid stock delay."),
					primitive: cell,
					showEditor: false
				});
			}
		}
	} else if (dna.type == "Flow") {
		dna.onlyPositive = isTrue(cell.getAttribute("OnlyPositive"));
	} else if (dna.type == "Converter") {
		dna.source = cell.getAttribute("Source");
		dna.interpolation = cell.getAttribute("Interpolation") == "Linear" ? "linear" : "discrete";


		if (isUndefined(cell.getAttribute("Data")) || cell.getAttribute("Data").trim() == "") {

			throw ({
				msg: getText("The converter %s does not have any data.", "<i>" + clean(dna.name) + "</i>"),
				primitive: cell,
				showEditor: true
			});
		}

		var data = cell.getAttribute("Data").split(";");


		var inp = [];
		var out = [];
		var myU;
		if (dna.source == "Time") {
			myU = simulate.timeUnits;
		} else {
			myU = createUnitStore(orig(findID(dna.source)).getAttribute("Units"));
		}
		for (var i = 0; i < data.length; i++) {
			var b = data[i].split(",");
			inp.push(new Material(sn(b[0].trim()), myU));
			out.push(new Material(sn(b[1].trim())));
		}
		dna.inputs = inp;
		dna.outputs = out;
	}

	if (dna.type != "State") {
		if (dna.type != "Transition" && dna.type != "Action") {
			var u = cell.getAttribute("Units");
			try {
				if (dna.type != "Flow" || (u && u.trim() != "" && u.trim().toLowerCase() != "unitless")) {
					dna.units = createUnitStore(u);
				} else {
					dna.units = getUnitStore([timeUnits], [-1]);
					dna.flowUnitless = true;
				}
			} catch (err) {
				if (isLocal()) {
					console.log(err);
				}
				throw {
					msg: getText("Invalid units specified for primitive: \"%s\".", clean(u)),
					primitive: cell,
					showEditor: true
				};

			}
		} else {
			if (dna.trigger == "Timeout") {
				dna.units = simulate.timeUnits;
			}
		}
		dna.maxConstraint = cell.getAttribute("MaxConstraint");
		dna.maxConstraintType = isTrue(cell.getAttribute("MaxConstraintUsed")) ? 1 : null;
		dna.minConstraint = cell.getAttribute("MinConstraint");
		dna.minConstraintType = isTrue(cell.getAttribute("MinConstraintUsed")) ? 1 : null;

	}

	if (dna.units) {
		dna.units.addBase();
		dna.toBase = dna.units.toBase;
	} else {
		dna.toBase = 1;
	}

	dna.unitless = !dna.units;

	return dna;
}

function folderSolvers(cell, solvers) {
	if ((!cell) || cell == null) {
		return solvers.base;
	}
	if (cell.value.nodeName == "Agents") {
		//console.log("AGENTS")
		var x = cell.getAttribute("Agent");
		//console.log(x)
		if (solvers[x]) {
			//console.log("SET!")
			//console.log(solvers[x])
			return solvers[x];
		}
	}

	var p = getParent(cell);
	if (p && solvers[p.id]) {
		return solvers[p.id];
	}

	return folderSolvers(p, solvers);
}


function decodeDNA(dna, agent) {
	var type = dna.type;
	var x;
	if (type == "Variable") {
		x = new Variable();
	} else if (type == "State") {
		x = new State();
	} else if (type == "Transition") {
		x = new Transition();
	} else if (type == "Action") {
		x = new Action();
	} else if (type == "Stock") {
		x = new Stock();
	} else if (type == "Flow") {
		x = new Flow();
	} else if (type == "Converter") {
		x = new Converter();
	}

	if (x) {
		x.dna = dna;
		x.id = dna.id;
		x.index = agent.index;
		x.agentId = agent.agentId;
		x.container = agent;
		x.createIds();

		x.frozen = dna.frozen;

		agent.children.push(x);
		agent.childrenId[x.id] = x;

		if (dna.slider) {
			if (simulate.sliders[dna.id]) {
				simulate.sliders[dna.id].push(x);
			} else {
				simulate.sliders[dna.id] = [x];
			}
		}


		if (x instanceof Action) {
			dna.solver.actions.push(x);
		} else if (x instanceof Transition) {
			dna.solver.transitions.push(x);
		} else if (!(x instanceof Agents)) {
			dna.solver.valued.push(x)
			if (x instanceof Flow) {
				dna.solver.flows.push(x);
			} else if (x instanceof Stock) {
				dna.solver.stocks.push(x);
			} else if (x instanceof State) {
				dna.solver.states.push(x);
			}
		}
	} else if (type == "Agents") {
		agent.children.push(dna.agents);
		agent.childrenId[dna.id] = dna;
	}

}

function linkPrimitive(primitive, dna) {
	var type = dna.type;
	//console.log("--"+dna.name);
	if (type != "Agents") {
		var myNeighborhood = getPrimitiveNeighborhood(primitive, dna);

		if (type == "Flow" || type == "Transition") {
			var alpha = null,
				omega = null;

			if (myNeighborhood["[alpha"]) {
				alpha = myNeighborhood["[alpha"];
				if (!myNeighborhood["alpha"]) {
					myNeighborhood["alpha"] = alpha;
				}
			}

			if (myNeighborhood["[omega"]) {
				omega = myNeighborhood["[omega"];
				if (!myNeighborhood["omega"]) {
					myNeighborhood["omega"] = omega;
				}
			}

			primitive.setEnds(alpha, omega);
		}

		if (type == "Action") {
			//console.log(myNeighborhood);
			try {
				primitive.equation = trimTree(dna.triggerValue, myNeighborhood);
			} catch (err) {
				var msg = getText("The primitive %s has an equation error that must be corrected before the model can be run.", "<i>[" + clean(dna.name) + "]</i>");
				if (err.substr && err.substr(0, 4) == "MSG:") {
					msg += "<br/><br/>" + err.toString().substr(4);
				}
				error(msg, dna.cell, false, l);
			}
			try {
				primitive.action = trimTree(dna.value, myNeighborhood);
			} catch (err) {
				var msg = getText("The primitive %s has an equation error that must be corrected before the model can be run.", "<i>[" + clean(dna.name) + "]</i>");
				if (err.substr && err.substr(0, 4) == "MSG:") {
					msg += "<br/><br/>" + err.toString().substr(4);
				}
				var l = undefined;
				if (err.match && err.match(/line (\d+)/i)) {
					l = err.match(/line (\d+)/i)[1]
				}
				error(msg, dna.cell, true, l, err.match ? err : undefined);
			}
			//primitive.resetTimer();
		} else if (type == "Converter") {
			if (dna.source == "Time") {
				primitive.setSource("*time");
			} else {
				var source = orig(findID(dna.source)).id;
				var sourceSet = false;
				for (var neighbor in myNeighborhood) {
					if (source == myNeighborhood[neighbor].id) {
						primitive.setSource(myNeighborhood[neighbor]);
						sourceSet = true;
						break;
					}
				}

				if (!sourceSet) {
					error("Converter source could not be found. Please redefine it.", dna.cell, false);
				}


			}
		} else {
			//console.log("setting: "+dna.name);
			//console.log(dna.value);
			primitive.setEquation(dna.value, myNeighborhood);
		}
	}
}

function setAgentInitialValues(agent) {

	for (var i = 0; i < agent.children.length; i++) {
		if (agent.children[i] instanceof Stock) {
			agent.children[i].setDelay();
			try {
				agent.children[i].setInitialValue();
			} catch (err) {
				if (isLocal()) {
					console.log(err);
				}
				if (err instanceof String) {
					error(err.substr(4, err.length), agent.children[i], true);
				} else {
					throw err;
				}
			}
		} else if (agent.children[i] instanceof State) {
			try {
				if (agent.children[i].active === null) {
					agent.children[i].setInitialActive(true);
				}
			} catch (err) {
				if (isLocal()) {
					console.log(err);
				}
				if (err instanceof String) {
					error(err.substr(4, err.length), agent.children[i], true);
				} else {
					throw err;
				}
			}
		}
	}

}

function buildNetwork(submodel) {
	if (submodel.network == "Custom Function") {
		var hood = getPrimitiveNeighborhood(submodel, submodel.dna);
		var tree = trimTree(createTree(submodel.networkFunction), hood);
		for (var i = 0; i < submodel.agents.length - 1; i++) {
			for (var j = i + 1; j < submodel.agents.length; j++) {
				if (trueValue(simpleEquation(submodel.networkFunction, {
					"-parent": varBank,
					"a": submodel.agents[i],
					"b": submodel.agents[j]
				}, hood, tree))) {
					submodel.agents[i].connect(submodel.agents[j]);
				}
			}
		}
	} else if (submodel.network == "None") {
		//nothing to do
	} else {
		throw {
			msg: "Unknown network type: " + submodel.network + ".",
			primitive: submodel.cell,
			showEditor: false
		};
	}
}

function buildPlacements(submodel, items) {
	var tree;
	var wCount, hCount;


	if (submodel.placement == "Random") {
		submodel.agents.forEach(function (s) {
			s.location = new Vector([mult(submodel.geoWidth, new Material(Rand())), mult(submodel.geoHeight, new Material(Rand()))], ['x', 'y']);
		});
	} else if (submodel.placement == "Custom Function") {
		submodel.agents.forEach(function (s) {
			var n = getPrimitiveNeighborhood(submodel, submodel.dna);
			n.self = s;
			s.location = simpleUnitsTest(simpleEquation(submodel.placementFunction, {
				"-parent": varBank,
				"self": s
			}, n), submodel.geoDimUnitsObject);
			if (!s.location.names) {
				s.location.names = ['x', 'y'];
				s.location.namesLC = ['x', 'y'];
			}
		});
	} else if (submodel.placement == "Grid") {
		tree = trimTree(createTree("{x: x*width(self), y: y*height(self)}"), {});
		var size = submodel.agents.length;
		var ratio = simpleNum(simpleEquation("width(self)/height(self)", {
			"-parent": varBank,
			"self": submodel
		}, {}), submodel.geoDimUnitsObject);
		//console.log(ratio)
		hCount = Math.sqrt(size / ratio);
		wCount = Math.floor(hCount * ratio);

		hCount = Math.ceil(hCount);
		if (!hCount * wCount >= size) {
			wCount = wCount + 1
		}

		var j = 0;
		submodel.agents.forEach(function (s) {
			var xPos = ((j % wCount) + 0.5) / wCount;
			var yPos = (Math.floor(j / wCount) + 0.5) / hCount;
			s.location = simpleUnitsTest(simpleEquation("{x: x*width(self), y: y*height(self)}", {
				"self": s,
				"x": new Material(xPos),
				"y": new Material(yPos),
				"-parent": varBank
			}, {}, tree), submodel.geoDimUnitsObject);
			j++;
		});
	} else if (submodel.placement == "Ellipse") {
		tree = trimTree(createTree("{width(self), height(self)}/2+{sin(index(self)/size*2*3.14159), cos(index(self)/size*2*3.14159)}*{width(self), height(self)}/2"), {});
		var size = new Material(submodel.agents.length);
		submodel.agents.forEach(function (s) {
			s.location = simpleUnitsTest(simpleEquation("{width(self), height(self)}/2+{sin(index(self)/size*2*3.14159), cos(index(self)/size*2*3.14159)}*{width(self), heigh(self)}/2", {
				"self": s,
				"size": size,
				"-parent": varBank
			}, {}, tree), submodel.geoDimUnitsObject);
		});
	} else if (submodel.placement == "Network") {
		tree = trimTree(createTree("{x: x*width(self), y: y*height(self)}"), {});

		var graph = new Graph();

		var nodes = submodel.agents.map(function (s) {
			return graph.newNode({
				data: s
			});
		});
		var getNode = function (item) {
			for (var i = 0; i < nodes.length; i++) {

				if (nodes[i].data.data === item) {
					return nodes[i];
				}
			}
			return null;
		}
		submodel.agents.forEach(function (a) {
			a.connected.forEach(function (target) {
				graph.newEdge(getNode(a), getNode(target));
			});
		});
		//console.log("ZZ");
		var layout = new Layout.ForceDirected(graph, 400.0, 600.0, 0.5);

		for (var i = 0; i < 60; i++) {
			layout.applyCoulombsLaw();
			layout.applyHookesLaw();
			layout.attractToCentre();
			layout.updateVelocity(0.03);
			layout.updatePosition(0.03);
		}

		/*while(layout.totalEnergy() > 0.01) {
			layout.applyCoulombsLaw();
			layout.applyHookesLaw();
			layout.attractToCentre();
			layout.updateVelocity(0.03);
			layout.updatePosition(0.03);
		}*/

		var bb = layout.getBoundingBox();
		//console.log(bb);
		bb.width = bb.topright.x - bb.bottomleft.x;
		bb.height = bb.topright.y - bb.bottomleft.y;
		//console.log(bb);
		var scalePoint = function (p) {
			return {
				x: (p.x - bb.bottomleft.x) / bb.width,
				y: (p.y - bb.bottomleft.y) / bb.height
			};
		}

		layout.eachNode(function (node, point) {
			var p = scalePoint(point.p);
			//console.log(scalePoint(p));
			node.data.data.location = simpleUnitsTest(simpleEquation("{x: x*width(self), y: y*height(self)}", {
				"self": submodel,
				"x": new Material(p.x),
				"y": new Material(p.y),
				"-parent": varBank
			}, {}, tree), submodel.geoDimUnitsObject);
		});
		//console.log("done");

	} else {
		throw {
			msg: "Unknown placement type: " + submodel.placement + ".",
			primitive: submodel.cell,
			showEditor: false
		};
	}

}


var allPlaceholders = {};

function getPrimitiveNeighborhood(primitive, dna) {

	var neighbors = neighborhood(dna.cell);
	var placeholders = allPlaceholders[dna.id] ? allPlaceholders[dna.id] : {};

	var hood = {
		self: primitive
	};

	/*console.log("----");
	console.log(dna.name);
	console.log(neighbors)*/

	if (!neighbors.placeholders) {
		if (dna.type == "Agents") {
			for (var i = 0; i < primitive.DNAs.length; i++) {
				placeholders[primitive.DNAs[i].name.toLowerCase()] = new Placeholder(primitive.DNAs[i], primitive);
			}
		}
	}

	for (var k = 0; k < neighbors.length; k++) {
		var item = neighbors[k].item;
		if (item.value.nodeName == "Agents") {
			hood[model.submodels[item.id].dna.name.toLowerCase()] = model.submodels[item.id];
			if (!neighbors.placeholders) {
				for (var i = 0; i < model.submodels[item.id].DNAs.length; i++) {
					hood[model.submodels[item.id].DNAs[i].name.toLowerCase()] = new Placeholder(model.submodels[item.id].DNAs[i], primitive);
				}
			}
		} else if (neighbors[k].type != "agent") {



			var found = false;
			if (primitive.container) {
				if (primitive.container.childrenId[item.id]) {
					var hoodName = primitive.container.childrenId[item.id].dna.name.toLowerCase();
					//while(hood[hoodName]){
					//hoodName += ".extra";
					//}
					hood[hoodName] = primitive.container.childrenId[item.id];
					found = true;
				}
			}
			if (!found) {
				if (model.submodels["base"]["agents"][0].childrenId[item.id]) {
					var hoodName = model.submodels["base"]["agents"][0].childrenId[item.id].dna.name.toLowerCase();
					//while(hood[hoodName]){
					//	hoodName += ".extra";
					//}
					hood[hoodName] = model.submodels["base"]["agents"][0].childrenId[item.id];
					found = true;
				}
			}


			if ((!found) && (dna.type == "Flow" || dna.type == "Transition") && item == findID(item.id)) {

				error(dna.type + " primitives may not cross agent boundaries.", dna.cell, false);
			}

			if (dna.type == "Flow" || dna.type == "Transition") {

				if (hood[hoodName]) {
					if (dna.targetId == hood[hoodName].id) {
						hood["[omega"] = hood[hoodName];
					} else if (dna.sourceId == hood[hoodName].id) {
						hood["[alpha"] = hood[hoodName];
					}
				}
			}
		}
	}


	var keys = Object.keys(placeholders);
	for (var i = 0; i < keys.length; i++) {
		hood[keys[i]] = placeholders[keys[i]];
	}
	allPlaceholders[dna.id] = placeholders;

	//console.log(hood);

	return hood;
}

function modelType(type) {
	return !(type == "Link" || type == "Picture" || type == "Text" || type == "Button" || type == "Folder" || type == "Setting" || type == "Display" || type == "Ghost");
}

function updateDisplayed(solver) {
	var displayed = solver ? solver.displayed : [];

	if (simulate.displayInformation.store) {
		if (displayed.length > 0) {
			var storeData = [];
			var maxTime = solver.maxLoaded;
			maxTime = isDefined(maxTime) ? (maxTime + 1) : 0;
			var maxInData = solver.maxLoaded;
			for (var k = maxTime; k < simulate.results.Time.length; k++) {
				var inStore = simulate.displayInformation.store.getById(k);
				var d = {};
				if (!inStore) {
					d["id"] = k;
					d["Time"] = simulate.results["Time"][k];
				}
				//console.log("--");
				//console.log(solver);
				//console.log(displayed.length);
				//console.log(d.Time+" -"+k)

				if (isUndefined(simulate.results.data[k][displayed[0].id])) {
					//continue;
				} else {
					maxInData = k;
					for (var j = 0; j < displayed.length; j++) {

						//console.log(displayed[j].id)
						var i = simulate.displayInformation.ids.indexOf(displayed[j].id);

						if (i > -1) {
							if (simulate.results[simulate.displayInformation.ids[i]].states) {
								var states = simulate.results[simulate.displayInformation.ids[i]].states;

								//console.log("--")
								//console.log(k);
								//console.log(displayed[j].id)
								//console.log(simulate.results.data);
								if (simulate.results.data[k][displayed[j].id]) {
									var current = simulate.results.data[k][displayed[j].id].current;

									var tally = {};
									for (var q = 0; q < current.length; q++) {
										if (current[q].state) {
											for (var s = 0; s < current[q].state.length; s++) {
												tally[current[q].state[s].id.toString()] = (tally[current[q].state[s].id.toString()] + 1) || 1;
											}
										}
									}

									for (var q = 0; q < states.length; q++) {
										d[simulate.displayInformation.elementIds[i + q]] = tally[states[q]] || 0;
									}
								}
							} else if (simulate.results[simulate.displayInformation.ids[i]].indexedNames) {
								var z = 0;
								while (i < simulate.displayInformation.ids.length && simulate.displayInformation.ids[i] == displayed[j].id) {
									try {
										d[simulate.displayInformation.elementIds[i]] = selectFromMatrix(simulate.results.data[k][displayed[j].id].fullClone(), simulate.results[simulate.displayInformation.ids[i]].indexedFullNames[z].slice());
									} catch (err) {
										throw ({
											msg: getText("Cannot change vector keys during a simulation."),
											primitive: displayed[j].dna.cell,
											showEditor: true
										});

									}

									z++;
									i++;
								}

							} else {
								/*console.log("--")
								console.log(d);
								console.log(simulate.displayInformation.elementIds);
								console.log(i);
								console.log(simulate.results.data);
								console.log(k);
								console.log(displayed[j].id)*/
								d[simulate.displayInformation.elementIds[i]] = simulate.results.data[k][displayed[j].id];
							}
						}
					}
				}

				if (inStore) {
					inStore.set(d);
					inStore.commit();
				} else {
					storeData.push(d);
				}
			}
			solver.maxLoaded = maxInData;
			simulate.displayInformation.store.maxLoaded = Math.max(simulate.displayInformation.store.maxLoaded, solver.maxLoaded)

			//console.log(storeData)

			simulate.displayInformation.store.suspendEvents();
			simulate.displayInformation.store.add(storeData);
			simulate.displayInformation.store.resumeEvents();
			simulate.displayInformation.store.filter();
		}
		//window.store = simulate.displayInformation.store;

		if (!simulate.resultsWindow) {
			simulate.resultsWindow = createResultsWindow(simulate.displayInformation, simulate.config);


			simulate.resultsWindow.scripter.loadTime(0);

			var period = (simulate.resultsWindow.scripter.combo.getValue() == -1) ? 200 : 100 / Math.min(0.5, simulate.resultsWindow.scripter.combo.getValue());

			var s = simulate.resultsWindow.scripter;
			simulate.resultsWindow.scripter.animInter = setInterval(function () {
				s.advanceTimer()
			}, period);
		}

		simulate.resultsWindow.sliders = simulate.sliders;

		if (k == simulate.displayInformation.times.length) {
			simulate.resultsWindow.scripter.finished();
		}
	}
}

module.exports = {is_owner, translations, analysisCount, isSendingtoServer, waitingToSendToServer, waitingToSendTimeout, primitiveCache, neighborhoodCache, downloadButton, executeLayout, trusted, globalVarBank, FormulaLexer, FormulaParser, baseSources, baseTargets, baseScalings, conScalings, conTargets, conSourceNames, conUnitTargets, conSourceRegEx, cachedUnits, findSourceIndex, unitsBank, titleCaseReg, titleCaseFunc, SchemeNumber, SchemeNumber, functionBank, functionLoaders, PrimitiveStore, Primitive, StringObject, VectorObject, VectorBase, Vector, PB, TreeNode, funcEvalMap, evaluatingLine, unitEvalMap, trimEvalMap, AgentObject, PrimitiveObject, TaskId, strictUnits, strictAgentResolution, strictLinks, timeUnits, allPlaceholders, isLocal, getText, SimpleNode, loadXML, simpleCloneNode, mxGraphToJson, setAttributeUndoable, getGraphXml, sendGraphtoServer, validPrimitiveName, isPrimitive, cellsContainNodename, connectionType, setAllConnectable, primitives, childrenCells, clearPrimitiveCache, neighborhood, doubleArray, isValued, setSaveEnabled, hasDisplay, urlImage, setPicture, setLabelPosition, removeAgent, deletePrimitive, linkBroken, testConverterSource, downloadModel, getSetting, handelCursors, updateProperties, isTrue, customUnits, orig, currentStyleIs, setStyles, stringArray, quickLabel, processLabel, replaceAll, loadBackgroundColor, isUndefined, isDefined, isTouch, propagateGhosts, propagateName, map, unitsUsedInModel, changeNodeName, cmd, inAgent, parentAgent, isGray, colourNameToHex, flatten, deepClone, exportSvg, showMessage, showPrompt, showChoice, showURL, downloadFile, showData, frontWindow, closeAllWindows, openFile, runModel, simulationRunning, endRunningSimulation, saveModel, clearModel, layoutModel, setZoom, getTimeStep, setTimeStep, getTimeStart, setTimeStart, getTimeLength, setTimeLength, getPauseInterval, setPauseInterval, getTimeUnits, setTimeUnits, getAlgorithm, setAlgorithm, getMacros, setMacros, findName, findAll, findType, findID, findValue, findNote, createPrimitive, createConnector, removePrimitive, highlight, getSelected, setSelected, isSelected, getID, getType, getName, setName, getUnits, setUnits, getConstraints, setConstraints, getNote, setNote, showNote, hideNote, showEditor, getValue, setValue, getSize, getPosition, setPosition, flash, getShowSlider, setShowSlider, getSliderMin, setSliderMin, getSliderMax, setSliderMax, getSliderStep, setSliderStep, getOpacity, setOpacity, getLineColor, setLineColor, getFontColor, setFontColor, getFillColor, setFillColor, getImage, setImage, getNonNegative, setNonNegative, getStockType, setStockType, getDelay, setDelay, getEnds, setEnds, connected, getResidency, setResidency, getTriggerType, setTriggerType, getTriggerValue, setTriggerValue, getTriggerRepeat, setTriggerRepeat, getTriggerRecalculate, setTriggerRecalculate, getData, setData, getConverterInput, setConverterInput, getInterpolation, setInterpolation, pressButton, runAction, getPopulationSize, setPopulationSize, getAgentBase, setAgentBase, getGeometryWrap, setGeometryWrap, getGeometryUnits, setGeometryUnits, getGeometryWidth, setGeometryWidth, getGeometryHeight, setGeometryHeight, getAgentPlacement, setAgentPlacement, getAgentNetwork, setAgentNetwork, collapseFolder, expandFolder, getCollapsed, getParent, setParent, getFrozen, setFrozen, getChildren, getFolderType, setFolderType, getFolderAgentParent, setFolderAgentParent, getFolderSolver, setFolderSolver, excludeType, primitiveIndex, uniquePrimitives, setGlobal, getGlobal, topBarShown, toggleTopBar, sideBarShown, toggleSideBar, updateSideBar, Simulator, loadUnits, Material, unitAlert, sortAndCollapseUnits, getUnitStore, getUnitsId, UnitStore, unitsFromString, toTitleCase, convertUnits, bootCalc, keysMatch, strictEquals, createTree, trimTree, evaluateTree, evaluate, convertToObject, funAnd, funOr, funXor, fNot, neq, eq, comparisonValid, lessThan, lessThanEq, greaterThan, greaterThanEq, plus, minus, mult, div, power, doMod, createMatrixSelector, selectFromMatrix, doBreakouts, selectFromVector, selectElementFromVector, makeFunctionCall, createSelector, functionGenerator, evaluateUnits, evaluateNode, isConst, trimNode, trueValue, isLocal, isUndefined, isDefined, fireEvent, ObjToVec, s, makeObjectBase, factorial, testArgumentsSize, distance, agent, agents, getPopulation, shiftLocation, isUndefined, isDefined, constraintAlert, error, testPrimitive, prepareDisplay, AggregateSeries, DataBank, ExpGroup, Primitive, Placeholder, State, Transition, scheduleTrigger, clearTrigger, updateTrigger, Action, Agents, Agent, Stock, Converter, Variable, Flow, globalVars, TaskQueue, Task, scheduleRepeated, RedBlackNode, RedBlackTree, runSimulation, checkErr, innerRunSimulation, formatSimResults, createUnitStore, simpleEquation, simpleNum, simpleUnitsTest, handleErrorObject, evaluateMacros, DNA, getDNA, folderSolvers, decodeDNA, linkPrimitive, setAgentInitialValues, buildNetwork, buildPlacements, getPrimitiveNeighborhood, modelType, updateDisplayed}